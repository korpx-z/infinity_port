/// <reference types="react" />
import { SortOrder, DataQuery as DataQuery$1, DataSourceRef as DataSourceRef$1, TimeZone as TimeZone$1, TimeZoneBrowser as TimeZoneBrowser$1, TimeZoneUtc as TimeZoneUtc$1, MatcherConfig, DataTransformerConfig, MapLayerOptions, LogsSortOrder, ComparisonOperation } from '@grafana/schema';
export { DataTransformerConfig, FrameGeometrySource, FrameGeometrySourceMode, LogsDedupStrategy, LogsSortOrder, MapLayerOptions, MatcherConfig } from '@grafana/schema';
import React$1, { ComponentType, ComponentClass, ReactNode, PropsWithChildren, ReactElement } from 'react';
import moment from 'moment';
import { Observable, Unsubscribable, MonoTypeOperatorFunction } from 'rxjs';
import { Location } from 'history';
import * as lodash from 'lodash';
import { Interval, Duration } from 'date-fns';
import { Map } from 'ol';
import BaseLayer from 'ol/layer/Base';

/** @internal */
declare function moveItemImmutably<T>(arr: T[], from: number, to: number): T[];
declare function sortValues(sort: SortOrder.Ascending | SortOrder.Descending): (a: unknown, b: unknown) => number;

declare const arrayUtils_d_moveItemImmutably: typeof moveItemImmutably;
declare const arrayUtils_d_sortValues: typeof sortValues;
declare namespace arrayUtils_d {
  export {
    arrayUtils_d_moveItemImmutably as moveItemImmutably,
    arrayUtils_d_sortValues as sortValues,
  };
}

declare const GAUGE_DEFAULT_MINIMUM = 0;
declare const GAUGE_DEFAULT_MAXIMUM = 100;
declare const DEFAULT_SAML_NAME = "SAML";

interface FormattedValue {
    text: string;
    prefix?: string;
    suffix?: string;
}
declare function formattedValueToString(val: FormattedValue): string;
declare type ValueFormatter = (value: number, decimals?: DecimalCount, scaledDecimals?: DecimalCount, timeZone?: TimeZone, showMs?: boolean) => FormattedValue;
interface ValueFormat {
    name: string;
    id: string;
    fn: ValueFormatter;
}
interface ValueFormatCategory {
    name: string;
    formats: ValueFormat[];
}
interface ValueFormatterIndex {
    [id: string]: ValueFormatter;
}
declare function toFixed(value: number, decimals?: DecimalCount): string;
declare function toFixedScaled(value: number, decimals: DecimalCount, ext?: string): FormattedValue;
declare function toFixedUnit(unit: string, asPrefix?: boolean): ValueFormatter;
declare function isBooleanUnit(unit?: string): boolean | "" | undefined;
declare function booleanValueFormatter(t: string, f: string): ValueFormatter;
declare function scaledUnits(factor: number, extArray: string[], offset?: number): ValueFormatter;
declare function locale(value: number, decimals: DecimalCount): FormattedValue;
declare function simpleCountUnit(symbol: string): ValueFormatter;
declare function stringFormater(value: number): FormattedValue;
declare function getValueFormat(id?: string | null): ValueFormatter;
declare function getValueFormatterIndex(): ValueFormatterIndex;
declare function getValueFormats(): {
    text: string;
    submenu: {
        text: string;
        value: string;
    }[];
}[];

declare type DisplayProcessor = (value: unknown, decimals?: DecimalCount) => DisplayValue;
interface DisplayValue extends FormattedValue {
    /**
     *  Use isNaN to check if it is a real number
     */
    numeric: number;
    /**
     *  0-1 between min & max
     */
    percent?: number;
    /**
     *  Color based on mappings or threshold
     */
    color?: string;
    /**
     *  Icon based on mappings or threshold
     */
    icon?: string;
    title?: string;
    /**
     * Used in limited scenarios like legend reducer calculations
     */
    description?: string;
}
/**
 * These represents the display value with the longest title and text.
 * Used to align widths and heights when displaying multiple DisplayValues
 */
interface DisplayValueAlignmentFactors extends FormattedValue {
    title?: string;
}
declare type DecimalCount = number | null | undefined;
interface DecimalInfo {
    decimals: DecimalCount;
    scaledDecimals: DecimalCount;
}

interface ScopedVar<T = any> {
    text?: any;
    value: T;
}
interface ScopedVars {
    __dataContext?: DataContextScopedVar;
    [key: string]: ScopedVar | undefined;
}
/**
 * Used by data link macros
 */
interface DataContextScopedVar {
    value: {
        frame: DataFrame;
        field: Field;
        rowIndex?: number;
        calculatedValue?: DisplayValue;
    };
}

/**
 * @deprecated use the type from @grafana/schema
 */
interface DataQuery extends DataQuery$1 {
}
/**
 * @deprecated use the type from @grafana/schema
 */
interface DataSourceRef extends DataSourceRef$1 {
}
/**
 * Attached to query results (not persisted)
 *
 * @public
 */
declare enum DataTopic {
    Annotations = "annotations"
}
/**
 * Abstract representation of any label-based query
 * @internal
 */
interface AbstractQuery extends DataQuery$1 {
    labelMatchers: AbstractLabelMatcher[];
}
/**
 * @internal
 */
declare enum AbstractLabelOperator {
    Equal = "Equal",
    NotEqual = "NotEqual",
    EqualRegEx = "EqualRegEx",
    NotEqualRegEx = "NotEqualRegEx"
}
/**
 * @internal
 */
declare type AbstractLabelMatcher = {
    name: string;
    value: string;
    operator: AbstractLabelOperator;
};
/**
 * @internal
 */
interface DataSourceWithQueryImportSupport<TQuery extends DataQuery$1> {
    importFromAbstractQueries(labelBasedQuery: AbstractQuery[]): Promise<TQuery[]>;
}
/**
 * @internal
 */
interface DataSourceWithQueryExportSupport<TQuery extends DataQuery$1> {
    exportToAbstractQueries(query: TQuery[]): Promise<AbstractQuery[]>;
}
/**
 * @internal
 */
declare const hasQueryImportSupport: <TQuery extends DataQuery$1>(datasource: unknown) => datasource is DataSourceWithQueryImportSupport<TQuery>;
/**
 * @internal
 */
declare const hasQueryExportSupport: <TQuery extends DataQuery$1>(datasource: unknown) => datasource is DataSourceWithQueryExportSupport<TQuery>;

interface DateTimeBuiltinFormat {
    __momentBuiltinFormatBrand: any;
}
declare const ISO_8601: DateTimeBuiltinFormat;
declare type DateTimeInput = Date | string | number | Array<string | number> | DateTime | null;
declare type FormatInput = string | DateTimeBuiltinFormat | undefined;
declare type DurationInput = string | number | DateTimeDuration;
declare type DurationUnit = 'year' | 'years' | 'y' | 'month' | 'months' | 'M' | 'week' | 'weeks' | 'isoWeek' | 'w' | 'day' | 'days' | 'd' | 'hour' | 'hours' | 'h' | 'minute' | 'minutes' | 'm' | 'second' | 'seconds' | 's' | 'millisecond' | 'milliseconds' | 'ms' | 'quarter' | 'quarters' | 'Q';
interface DateTimeLocale {
    firstDayOfWeek: () => number;
}
interface DateTimeDuration {
    asHours: () => number;
    hours: () => number;
    minutes: () => number;
    seconds: () => number;
    asSeconds: () => number;
}
interface DateTime extends Object {
    add: (amount?: DateTimeInput, unit?: DurationUnit) => DateTime;
    set: (unit: DurationUnit, amount: DateTimeInput) => void;
    diff: (amount: DateTimeInput, unit?: DurationUnit, truncate?: boolean) => number;
    endOf: (unitOfTime: DurationUnit) => DateTime;
    format: (formatInput?: FormatInput) => string;
    fromNow: (withoutSuffix?: boolean) => string;
    from: (formaInput: DateTimeInput) => string;
    isSame: (input?: DateTimeInput, granularity?: DurationUnit) => boolean;
    isBefore: (input?: DateTimeInput) => boolean;
    isValid: () => boolean;
    local: () => DateTime;
    locale: (locale: string) => DateTime;
    startOf: (unitOfTime: DurationUnit) => DateTime;
    subtract: (amount?: DateTimeInput, unit?: DurationUnit) => DateTime;
    toDate: () => Date;
    toISOString: () => string;
    isoWeekday: (day?: number | string) => number | string;
    valueOf: () => number;
    unix: () => number;
    utc: () => DateTime;
    utcOffset: () => number;
    hour?: () => number;
    minute?: () => number;
}
declare const setLocale: (language: string) => void;
declare const getLocale: () => string;
declare const getLocaleData: () => DateTimeLocale;
declare const isDateTimeInput: (value: unknown) => value is DateTimeInput;
declare const isDateTime: (value: unknown) => value is DateTime;
declare const toUtc: (input?: DateTimeInput, formatInput?: FormatInput) => DateTime;
declare const toDuration: (input?: DurationInput, unit?: DurationUnit) => DateTimeDuration;
declare const dateTime: (input?: DateTimeInput, formatInput?: FormatInput) => DateTime;
declare const dateTimeAsMoment: (input?: DateTimeInput) => moment.Moment;
declare const dateTimeForTimeZone: (timezone?: TimeZone, input?: DateTimeInput, formatInput?: FormatInput) => DateTime;
declare const getWeekdayIndex: (day: string) => number;
declare const getWeekdayIndexByEnglishName: (day: string) => number;
declare const setWeekStart: (weekStart?: string) => void;

interface RawTimeRange {
    from: DateTime | string;
    to: DateTime | string;
}
interface TimeRange {
    from: DateTime;
    to: DateTime;
    raw: RawTimeRange;
}
/**
 * Type to describe relative time to now in seconds.
 * @internal
 */
interface RelativeTimeRange {
    from: number;
    to: number;
}
interface AbsoluteTimeRange {
    from: number;
    to: number;
}
interface IntervalValues {
    interval: string;
    intervalMs: number;
}
interface TimeOption {
    from: string;
    to: string;
    display: string;
}
/** @deprecated use TimeZone from schema  */
declare type TimeZone = TimeZone$1;
/** @deprecated use TimeZoneBrowser from schema  */
declare type TimeZoneBrowser = TimeZoneBrowser$1;
/** @deprecated use TimeZoneUtc from schema  */
declare type TimeZoneUtc = TimeZoneUtc$1;
/** @deprecated use defaultTimeZone from schema  */
declare const DefaultTimeZone: string;
interface TimeOptions {
    [key: string]: TimeOption[];
}
declare type TimeFragment = string | DateTime;
declare const TIME_FORMAT = "YYYY-MM-DD HH:mm:ss";
declare function getDefaultTimeRange(): TimeRange;
/**
 * Returns the default realtive time range.
 *
 * @public
 */
declare function getDefaultRelativeTimeRange(): RelativeTimeRange;

declare type AnyQuery = DataQuery & Record<string, any>;
/** @internal */
interface ExploreUrlState<T extends DataQuery = AnyQuery> {
    datasource: string;
    queries: T[];
    range: RawTimeRange;
    context?: string;
    panelsState?: ExplorePanelsState;
    isFromCompactUrl?: boolean;
}
interface ExplorePanelsState extends Partial<Record<PreferredVisualisationType, {}>> {
    trace?: ExploreTracePanelState;
}
interface ExploreTracePanelState {
    spanId?: string;
}
interface SplitOpenOptions<T> {
    datasourceUid: string;
    /** @deprecated Will be removed in a future version. Use queries instead. */
    query?: T;
    queries?: T[];
    range?: TimeRange;
    panelsState?: ExplorePanelsState;
}
/**
 * SplitOpen type is used in Explore and related components.
 */
declare type SplitOpen = <T extends DataQuery = any>(options?: SplitOpenOptions<T> | undefined) => void;

/**
 * @alpha
 * internal interface
 */
interface BusEvent {
    readonly type: string;
    readonly payload?: any;
    readonly origin?: EventBus;
}
/**
 * @alpha
 * Base event type
 */
declare abstract class BusEventBase implements BusEvent {
    readonly type: string;
    readonly payload?: any;
    readonly origin?: EventBus;
    constructor();
}
/**
 * @alpha
 * Base event type with payload
 */
declare abstract class BusEventWithPayload<T> extends BusEventBase {
    readonly payload: T;
    constructor(payload: T);
}
interface BusEventType<T extends BusEvent> {
    type: string;
    new (...args: any[]): T;
}
/**
 * @alpha
 * Event callback/handler type
 */
interface BusEventHandler<T extends BusEvent> {
    (event: T): void;
}
/**
 * @alpha
 * Main minimal interface
 */
interface EventFilterOptions {
    onlyLocal: boolean;
}
/**
 * @alpha
 * Main minimal interface
 */
interface EventBus {
    /**
     * Publish single event
     */
    publish<T extends BusEvent>(event: T): void;
    /**
     * Get observable of events
     */
    getStream<T extends BusEvent>(eventType: BusEventType<T>): Observable<T>;
    /**
     * Subscribe to an event stream
     *
     * This function is a wrapper around the `getStream(...)` function
     */
    subscribe<T extends BusEvent>(eventType: BusEventType<T>, handler: BusEventHandler<T>): Unsubscribable;
    /**
     * Remove all event subscriptions
     */
    removeAllListeners(): void;
    /**
     * Returns a new bus scoped that knows where it exists in a heiarchy
     *
     * @internal -- This is included for internal use only should not be used directly
     */
    newScopedBus(key: string, filter: EventFilterOptions): EventBus;
}
/**
 * @public
 * @deprecated event type
 */
interface AppEvent<T> {
    readonly name: string;
    payload?: T;
}
/** @public */
interface LegacyEmitter {
    /**
     * @deprecated use $emit
     */
    emit<T>(event: AppEvent<T> | string, payload?: T): void;
    /**
     * @deprecated use $on
     */
    on<T>(event: AppEvent<T> | string, handler: LegacyEventHandler<T>, scope?: any): void;
    /**
     * @deprecated use $on
     */
    off<T>(event: AppEvent<T> | string, handler: (payload?: T | any) => void): void;
}
/** @public */
interface LegacyEventHandler<T> {
    (payload: T): void;
    wrapper?: (event: BusEvent) => void;
}
/** @alpha */
interface EventBusExtended extends EventBus, LegacyEmitter {
}

declare function eventFactory<T = undefined>(name: string): AppEvent<T>;

/**
 * @alpha
 */
declare class EventBusSrv implements EventBus, LegacyEmitter {
    private emitter;
    private subscribers;
    constructor();
    publish<T extends BusEvent>(event: T): void;
    subscribe<T extends BusEvent>(typeFilter: BusEventType<T>, handler: BusEventHandler<T>): Unsubscribable;
    getStream<T extends BusEvent = BusEvent>(eventType: BusEventType<T>): Observable<T>;
    newScopedBus(key: string, filter?: EventFilterOptions): EventBus;
    /**
     * Legacy functions
     */
    emit<T>(event: AppEvent<T> | string, payload?: T | any): void;
    on<T>(event: AppEvent<T> | string, handler: LegacyEventHandler<T>, scope?: any): void;
    off<T>(event: AppEvent<T> | string, handler: LegacyEventHandler<T>): void;
    removeAllListeners(): void;
}

/**
 * When hovering over an element this will identify
 *
 * For performance reasons, this object will usually be mutated between updates.  This
 * will avoid creating new objects for events that fire frequently (ie each mouse pixel)
 *
 * @alpha
 */
interface DataHoverPayload {
    data?: DataFrame;
    rowIndex?: number;
    columnIndex?: number;
    dataId?: string;
    point: Record<string, any>;
    down?: Record<string, any>;
}
/** @alpha */
declare class DataHoverEvent extends BusEventWithPayload<DataHoverPayload> {
    static type: string;
}
/** @alpha */
declare class DataHoverClearEvent extends BusEventBase {
    static type: string;
}
/** @alpha */
declare class DataSelectEvent extends BusEventWithPayload<DataHoverPayload> {
    static type: string;
}
/** @alpha */
declare class AnnotationChangeEvent extends BusEventWithPayload<Partial<AnnotationEvent>> {
    static type: string;
}
declare type DashboardLoadedEventPayload<T> = {
    dashboardId: string;
    orgId?: number;
    userId?: number;
    grafanaVersion?: string;
    queries: Record<string, T[]>;
};
/** @alpha */
declare class DashboardLoadedEvent<T> extends BusEventWithPayload<DashboardLoadedEventPayload<T>> {
    static type: string;
}

/** @public */
declare abstract class FunctionalVector<T = any> implements Vector<T>, Iterable<T> {
    abstract get length(): number;
    abstract get(index: number): T;
    iterator(): Generator<T, void, unknown>;
    [Symbol.iterator](): Generator<T, void, unknown>;
    forEach(iterator: (row: T) => void): void;
    map<V>(transform: (item: T, index: number) => V): V[];
    filter(predicate: (item: T) => boolean): T[];
    toArray(): T[];
    toJSON(): any;
}
/**
 * Use functional programming with your vector
 */
declare function vectorator<T>(vector: Vector<T>): {
    [Symbol.iterator](): Generator<T, void, unknown>;
    forEach(iterator: (row: T) => void): void;
    map<V>(transform: (item: T, index: number) => V): V[];
    /** Add a predicate where you return true if it should *keep* the value */
    filter(predicate: (item: T) => boolean): T[];
};

/**
 * This abstraction will present the contents of a DataFrame as if
 * it were a well typed javascript object Vector.
 *
 * @remarks
 * The {@link DataFrameView.get} is optimized for use in a loop and will return same object.
 * See function for more details.
 *
 * @typeParam T - Type of object stored in the DataFrame.
 * @beta
 */
declare class DataFrameView<T = any> extends FunctionalVector<T> {
    private data;
    private index;
    private obj;
    readonly fields: {
        readonly [Property in keyof T]: Field<T[Property]>;
    };
    constructor(data: DataFrame);
    get dataFrame(): DataFrame;
    get length(): number;
    /**
     * Helper function to return the {@link DisplayProcessor} for a given field column.
     * @param colIndex - the field column index for the data frame.
     */
    getFieldDisplayProcessor(colIndex: number): DisplayProcessor | undefined;
    /**
     * The contents of the object returned from this function
     * are optimized for use in a loop. All calls return the same object
     * but the index has changed.
     *
     * @example
     * ```typescript
     *   // `first`, `second` and `third` will all point to the same contents at index 2:
     *   const first = view.get(0);
     *   const second = view.get(1);
     *   const third = view.get(2);
     *
     *   // If you need three different objects, consider something like:
     *   const first = { ...view.get(0) };
     *   const second = { ...view.get(1) };
     *   const third = { ...view.get(2) };
     * ```
     * @param idx - The index of the object you currently are inspecting
     */
    get(idx: number): T;
    toArray(): T[];
}

declare enum GrafanaThemeType {
    Light = "light",
    Dark = "dark"
}
interface GrafanaThemeCommons {
    name: string;
    breakpoints: {
        xs: string;
        sm: string;
        md: string;
        lg: string;
        xl: string;
        xxl: string;
    };
    typography: {
        fontFamily: {
            sansSerif: string;
            monospace: string;
        };
        size: {
            base: string;
            xs: string;
            sm: string;
            md: string;
            lg: string;
        };
        weight: {
            light: number;
            regular: number;
            semibold: number;
            bold: number;
        };
        lineHeight: {
            xs: number;
            sm: number;
            md: number;
            lg: number;
        };
        heading: {
            h1: string;
            h2: string;
            h3: string;
            h4: string;
            h5: string;
            h6: string;
        };
        link: {
            decoration: string;
            hoverDecoration: string;
        };
    };
    spacing: {
        base: number;
        insetSquishMd: string;
        d: string;
        xxs: string;
        xs: string;
        sm: string;
        md: string;
        lg: string;
        xl: string;
        gutter: string;
        formSpacingBase: number;
        formMargin: string;
        formFieldsetMargin: string;
        formInputHeight: number;
        formButtonHeight: number;
        formInputPaddingHorizontal: string;
        formInputAffixPaddingHorizontal: string;
        formInputMargin: string;
        formLabelPadding: string;
        formLabelMargin: string;
        formValidationMessagePadding: string;
        formValidationMessageMargin: string;
        inlineFormMargin: string;
    };
    border: {
        radius: {
            sm: string;
            md: string;
            lg: string;
        };
        width: {
            sm: string;
        };
    };
    height: {
        sm: number;
        md: number;
        lg: number;
    };
    panelPadding: number;
    panelHeaderHeight: number;
    zIndex: {
        dropdown: number;
        navbarFixed: number;
        sidemenu: number;
        tooltip: number;
        modalBackdrop: number;
        modal: number;
        portal: number;
        typeahead: number;
    };
}
interface GrafanaTheme extends GrafanaThemeCommons {
    type: GrafanaThemeType;
    isDark: boolean;
    isLight: boolean;
    palette: {
        black: string;
        white: string;
        dark1: string;
        dark2: string;
        dark3: string;
        dark4: string;
        dark5: string;
        dark6: string;
        dark7: string;
        dark8: string;
        dark9: string;
        dark10: string;
        gray1: string;
        gray2: string;
        gray3: string;
        gray4: string;
        gray5: string;
        gray6: string;
        gray7: string;
        gray98: string;
        gray97: string;
        gray95: string;
        gray90: string;
        gray85: string;
        gray70: string;
        gray60: string;
        gray33: string;
        gray25: string;
        gray15: string;
        gray10: string;
        gray05: string;
        blue95: string;
        blue85: string;
        blue80: string;
        blue77: string;
        red88: string;
        redBase: string;
        redShade: string;
        greenBase: string;
        greenShade: string;
        red: string;
        yellow: string;
        purple: string;
        orange: string;
        orangeDark: string;
        queryRed: string;
        queryGreen: string;
        queryPurple: string;
        queryOrange: string;
        brandPrimary: string;
        brandSuccess: string;
        brandWarning: string;
        brandDanger: string;
        online: string;
        warn: string;
        critical: string;
    };
    colors: {
        bg1: string;
        bg2: string;
        bg3: string;
        border1: string;
        border2: string;
        border3: string;
        bgBlue1: string;
        bgBlue2: string;
        dashboardBg: string;
        bodyBg: string;
        panelBg: string;
        panelBorder: string;
        pageHeaderBg: string;
        pageHeaderBorder: string;
        dropdownBg: string;
        dropdownShadow: string;
        dropdownOptionHoverBg: string;
        link: string;
        linkDisabled: string;
        linkHover: string;
        linkExternal: string;
        textStrong: string;
        textHeading: string;
        text: string;
        textSemiWeak: string;
        textWeak: string;
        textFaint: string;
        textBlue: string;
        formLabel: string;
        formDescription: string;
        formInputBg: string;
        formInputBgDisabled: string;
        formInputBorder: string;
        formInputBorderHover: string;
        formInputBorderActive: string;
        formInputBorderInvalid: string;
        formFocusOutline: string;
        formInputText: string;
        formInputDisabledText: string;
        formInputPlaceholderText: string;
        formValidationMessageText: string;
        formValidationMessageBg: string;
    };
    shadows: {
        listItem: string;
    };
    visualization: ThemeVisualizationColors;
}

/** @beta */
interface ThemeBreakpointValues {
    xs: number;
    sm: number;
    md: number;
    lg: number;
    xl: number;
    xxl: number;
}
/** @beta */
declare type ThemeBreakpointsKey = keyof ThemeBreakpointValues;
/** @beta */
interface ThemeBreakpoints {
    values: ThemeBreakpointValues;
    keys: string[];
    unit: string;
    up: (key: ThemeBreakpointsKey | number) => string;
    down: (key: ThemeBreakpointsKey | number) => string;
}

/** @beta */
interface ThemeShadows {
    z1: string;
    z2: string;
    z3: string;
}

/** @beta */
interface ThemeComponents {
    /** Applies to normal buttons, inputs, radio buttons, etc */
    height: {
        sm: number;
        md: number;
        lg: number;
    };
    input: {
        background: string;
        borderColor: string;
        borderHover: string;
        text: string;
    };
    tooltip: {
        text: string;
        background: string;
    };
    panel: {
        padding: number;
        headerHeight: number;
        borderColor: string;
        boxShadow: string;
        background: string;
    };
    dropdown: {
        background: string;
    };
    overlay: {
        background: string;
    };
    dashboard: {
        background: string;
        padding: number;
    };
    textHighlight: {
        background: string;
        text: string;
    };
    sidemenu: {
        width: number;
    };
    menuTabs: {
        height: number;
    };
    horizontalDrawer: {
        defaultHeight: number;
    };
}

/** @beta */
interface ThemeShape {
    borderRadius: (amount?: number) => string;
    radius: Radii;
}
interface Radii {
    default: string;
    pill: string;
    circle: string;
}
/** @internal */
interface ThemeShapeInput {
    borderRadius?: number;
}

/** @internal */
declare type ThemeSpacingOptions = {
    gridSize?: number;
};
/** @internal */
declare type ThemeSpacingArgument = number | string;
/**
 * @beta
 * The different signatures imply different meaning for their arguments that can't be expressed structurally.
 * We express the difference with variable names.
 * tslint:disable:unified-signatures */
interface ThemeSpacing {
    (): string;
    (value: ThemeSpacingArgument): string;
    (topBottom: ThemeSpacingArgument, rightLeft: ThemeSpacingArgument): string;
    (top: ThemeSpacingArgument, rightLeft: ThemeSpacingArgument, bottom: ThemeSpacingArgument): string;
    (top: ThemeSpacingArgument, right: ThemeSpacingArgument, bottom: ThemeSpacingArgument, left: ThemeSpacingArgument): string;
    gridSize: number;
}

declare const easing: {
    easeInOut: string;
    easeOut: string;
    easeIn: string;
    sharp: string;
};
declare const duration: {
    shortest: number;
    shorter: number;
    short: number;
    standard: number;
    complex: number;
    enteringScreen: number;
    leavingScreen: number;
};
/** @alpha */
interface CreateTransitionOptions {
    duration?: number | string;
    easing?: string;
    delay?: number | string;
}
/** @alpha */
declare function create(props?: string | string[], options?: CreateTransitionOptions): string;
declare function getAutoHeightDuration(height: number): number;
/** @alpha */
interface ThemeTransitions {
    create: typeof create;
    duration: typeof duration;
    easing: typeof easing;
    getAutoHeightDuration: typeof getAutoHeightDuration;
}

/** @beta */
interface ThemeTypography {
    fontFamily: string;
    fontFamilyMonospace: string;
    fontSize: number;
    fontWeightLight: number;
    fontWeightRegular: number;
    fontWeightMedium: number;
    fontWeightBold: number;
    htmlFontSize?: number;
    h1: ThemeTypographyVariant;
    h2: ThemeTypographyVariant;
    h3: ThemeTypographyVariant;
    h4: ThemeTypographyVariant;
    h5: ThemeTypographyVariant;
    h6: ThemeTypographyVariant;
    body: ThemeTypographyVariant;
    bodySmall: ThemeTypographyVariant;
    /**
     * @deprecated
     * from legacy old theme
     * */
    size: {
        base: string;
        xs: string;
        sm: string;
        md: string;
        lg: string;
    };
    pxToRem: (px: number) => string;
}
interface ThemeTypographyVariant {
    fontSize: string;
    fontWeight: number;
    lineHeight: number;
    fontFamily: string;
    letterSpacing?: string;
}
interface ThemeTypographyInput {
    fontFamily?: string;
    fontFamilyMonospace?: string;
    fontSize?: number;
    fontWeightLight?: number;
    fontWeightRegular?: number;
    fontWeightMedium?: number;
    fontWeightBold?: number;
    htmlFontSize?: number;
}

/**
 * @alpha
 */
interface ThemeVisualizationColors {
    /** Only for internal use by color schemes */
    palette: string[];
    /** Lookup the real color given the name */
    getColorByName: (color: string) => string;
    /** Colors organized by hue */
    hues: ThemeVizHue[];
}
/**
 * @alpha
 */
interface ThemeVizColor {
    color: string;
    name: string;
    aliases?: string[];
    primary?: boolean;
}
/**
 * @alpha
 */
interface ThemeVizHue {
    name: string;
    shades: ThemeVizColor[];
}

declare const zIndex: {
    navbarFixed: number;
    sidemenu: number;
    dropdown: number;
    typeahead: number;
    tooltip: number;
    modalBackdrop: number;
    modal: number;
    portal: number;
};
/** @beta */
declare type ThemeZIndices = typeof zIndex;

/**
 * @beta
 * Next gen theme model introduced in Grafana v8.
 */
interface GrafanaTheme2 {
    name: string;
    isDark: boolean;
    isLight: boolean;
    colors: ThemeColors;
    breakpoints: ThemeBreakpoints;
    spacing: ThemeSpacing;
    shape: ThemeShape;
    components: ThemeComponents;
    typography: ThemeTypography;
    zIndex: ThemeZIndices;
    shadows: ThemeShadows;
    visualization: ThemeVisualizationColors;
    transitions: ThemeTransitions;
    /** @deprecated Will be removed in a future version */
    v1: GrafanaTheme;
    /** feature flags that might impact component looks */
    flags: {
        topnav?: boolean;
    };
}
/** @alpha */
interface ThemeRichColor {
    /** color intent (primary, secondary, info, error, etc) */
    name: string;
    /** Main color */
    main: string;
    /** Used for hover */
    shade: string;
    /** Used for text */
    text: string;
    /** Used for borders */
    border: string;
    /** Used subtly colored backgrounds */
    transparent: string;
    /** Text color for text ontop of main */
    contrastText: string;
}
/** @internal */
declare type DeepPartial<T> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};

/** @internal */
declare type ThemeColorsMode = 'light' | 'dark';
/** @internal */
interface ThemeColorsBase<TColor> {
    mode: ThemeColorsMode;
    primary: TColor;
    secondary: TColor;
    info: TColor;
    error: TColor;
    success: TColor;
    warning: TColor;
    text: {
        primary: string;
        secondary: string;
        disabled: string;
        link: string;
        /** Used for auto white or dark text on colored backgrounds */
        maxContrast: string;
    };
    background: {
        /** Dashboard and body background */
        canvas: string;
        /** Primary content pane background (panels etc) */
        primary: string;
        /** Cards and elements that need to stand out on the primary background */
        secondary: string;
    };
    border: {
        weak: string;
        medium: string;
        strong: string;
    };
    gradients: {
        brandVertical: string;
        brandHorizontal: string;
    };
    action: {
        /** Used for selected menu item / select option */
        selected: string;
        /** Used for hovered menu item / select option */
        hover: string;
        /** Used for button/colored background hover opacity */
        hoverOpacity: number;
        /** Used focused menu item / select option */
        focus: string;
        /** Used for disabled buttons and inputs */
        disabledBackground: string;
        /** Disabled text */
        disabledText: string;
        /** Disablerd opacity */
        disabledOpacity: number;
    };
    hoverFactor: number;
    contrastThreshold: number;
    tonalOffset: number;
}
/** @beta */
interface ThemeColors extends ThemeColorsBase<ThemeRichColor> {
    /** Returns a text color for the background */
    getContrastText(background: string, threshold?: number): string;
    emphasize(color: string, amount?: number): string;
}
/** @internal */
declare type ThemeColorsInput = DeepPartial<ThemeColorsBase<ThemeRichColor>>;

/** @internal */
interface NewThemeOptions {
    name?: string;
    colors?: ThemeColorsInput;
    spacing?: ThemeSpacingOptions;
    shape?: ThemeShapeInput;
    typography?: ThemeTypographyInput;
}
/** @internal */
declare function createTheme(options?: NewThemeOptions): GrafanaTheme2;

/**
 * Converts a color from CSS hex format to CSS rgb format.
 * @param color - Hex color, i.e. #nnn or #nnnnnn
 * @returns A CSS rgb color string
 * @beta
 */
declare function hexToRgb(color: string): string;
/**
 * Converts a color from CSS rgb format to CSS hex format.
 * @param color - RGB color, i.e. rgb(n, n, n)
 * @returns A CSS rgb color string, i.e. #nnnnnn
 * @beta
 */
declare function rgbToHex(color: string): string;
/**
 * Converts a color to hex6 format if there is no alpha, hex8 if there is.
 * @param color - Hex, RGB, HSL color
 * @returns A hex color string, i.e. #ff0000 or #ff0000ff
 */
declare function asHexString(color: string): string;
/**
 * Converts a color to rgb string
 */
declare function asRgbString(color: string): string;
/**
 * Converts a color from hsl format to rgb format.
 * @param color - HSL color values
 * @returns rgb color values
 * @beta
 */
declare function hslToRgb(color: string | DecomposeColor): string;
/**
 * Returns an object with the type and values of a color.
 *
 * Note: Does not support rgb % values.
 * @param color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @returns {object} - A MUI color object: {type: string, values: number[]}
 * @beta
 */
declare function decomposeColor(color: string | DecomposeColor): DecomposeColor;
/**
 * Converts a color object with type and values to a string.
 * @param {object} color - Decomposed color
 * @param color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla'
 * @param {array} color.values - [n,n,n] or [n,n,n,n]
 * @returns A CSS color string
 * @beta
 */
declare function recomposeColor(color: DecomposeColor): string;
/**
 * Calculates the contrast ratio between two colors.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @param foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
 * @param canvas - A CSS color that alpha based backgrounds blends into
 * @returns A contrast ratio value in the range 0 - 21.
 * @beta
 */
declare function getContrastRatio(foreground: string, background: string, canvas?: string): number;
/**
 * The relative brightness of any point in a color space,
 * normalized to 0 for darkest black and 1 for lightest white.
 *
 * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
 * @param color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param background - CSS color that needs to be take in to account to calculate luminance for colors with opacity
 * @returns The relative brightness of the color in the range 0 - 1
 * @beta
 */
declare function getLuminance(color: string, background?: string): number;
/**
 * Darken or lighten a color, depending on its luminance.
 * Light colors are darkened, dark colors are lightened.
 * @param color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param coefficient=0.15 - multiplier in the range 0 - 1
 * @returns A CSS color string. Hex input values are returned as rgb
 * @beta
 */
declare function emphasize(color: string, coefficient?: number): string;
/**
 * Set the absolute transparency of a color.
 * Any existing alpha values are overwritten.
 * @param color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param value - value to set the alpha channel to in the range 0 - 1
 * @returns A CSS color string. Hex input values are returned as rgb
 * @beta
 */
declare function alpha(color: string, value: number): string;
/**
 * Darkens a color.
 * @param color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param coefficient - multiplier in the range 0 - 1
 * @returns A CSS color string. Hex input values are returned as rgb
 * @beta
 */
declare function darken(color: string, coefficient: number): string;
/**
 * Lightens a color.
 * @param color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
 * @param coefficient - multiplier in the range 0 - 1
 * @returns A CSS color string. Hex input values are returned as rgb
 * @beta
 */
declare function lighten(color: string, coefficient: number): string;
interface DecomposeColor {
    type: string;
    values: any;
    colorSpace?: string;
}

declare const colorManipulator_d_hexToRgb: typeof hexToRgb;
declare const colorManipulator_d_rgbToHex: typeof rgbToHex;
declare const colorManipulator_d_asHexString: typeof asHexString;
declare const colorManipulator_d_asRgbString: typeof asRgbString;
declare const colorManipulator_d_hslToRgb: typeof hslToRgb;
declare const colorManipulator_d_decomposeColor: typeof decomposeColor;
declare const colorManipulator_d_recomposeColor: typeof recomposeColor;
declare const colorManipulator_d_getContrastRatio: typeof getContrastRatio;
declare const colorManipulator_d_getLuminance: typeof getLuminance;
declare const colorManipulator_d_emphasize: typeof emphasize;
declare const colorManipulator_d_alpha: typeof alpha;
declare const colorManipulator_d_darken: typeof darken;
declare const colorManipulator_d_lighten: typeof lighten;
declare namespace colorManipulator_d {
  export {
    colorManipulator_d_hexToRgb as hexToRgb,
    colorManipulator_d_rgbToHex as rgbToHex,
    colorManipulator_d_asHexString as asHexString,
    colorManipulator_d_asRgbString as asRgbString,
    colorManipulator_d_hslToRgb as hslToRgb,
    colorManipulator_d_decomposeColor as decomposeColor,
    colorManipulator_d_recomposeColor as recomposeColor,
    colorManipulator_d_getContrastRatio as getContrastRatio,
    colorManipulator_d_getLuminance as getLuminance,
    colorManipulator_d_emphasize as emphasize,
    colorManipulator_d_alpha as alpha,
    colorManipulator_d_darken as darken,
    colorManipulator_d_lighten as lighten,
  };
}

/**
 * Options for how to turn DataFrames into an array of display values
 */
interface ReduceDataOptions {
    values?: boolean;
    /** if showing all values limit */
    limit?: number;
    /** When !values, pick one value for the whole field */
    calcs: string[];
    /** Which fields to show.  By default this is only numeric fields */
    fields?: string;
}
declare const VAR_SERIES_NAME = "__series.name";
declare const VAR_FIELD_NAME = "__field.displayName";
declare const VAR_FIELD_LABELS = "__field.labels";
declare const VAR_CALC = "__calc";
declare const VAR_CELL_PREFIX = "__cell_";
interface FieldSparkline {
    y: Field;
    x?: Field;
    timeRange?: TimeRange;
    highlightIndex?: number;
}
interface FieldDisplay {
    name: string;
    field: FieldConfig;
    display: DisplayValue;
    sparkline?: FieldSparkline;
    view?: DataFrameView;
    colIndex?: number;
    rowIndex?: number;
    getLinks?: () => LinkModel[];
    hasLinks: boolean;
}
interface GetFieldDisplayValuesOptions {
    data?: DataFrame[];
    reduceOptions: ReduceDataOptions;
    fieldConfig: FieldConfigSource;
    replaceVariables: InterpolateFunction;
    sparkline?: boolean;
    theme: GrafanaTheme2;
    timeZone?: TimeZone;
}
declare const DEFAULT_FIELD_DISPLAY_VALUES_LIMIT = 25;
declare const getFieldDisplayValues: (options: GetFieldDisplayValuesOptions) => FieldDisplay[];
declare function hasLinks(field: Field): boolean;
declare function getDisplayValueAlignmentFactors(values: FieldDisplay[]): DisplayValueAlignmentFactors;

interface DisplayProcessorOptions {
    field: Partial<Field>;
    /**
     * Will pick browser timezone if not defined
     */
    timeZone?: TimeZone;
    /**
     * Will pick 'dark' if not defined
     */
    theme: GrafanaTheme2;
}
declare function getDisplayProcessor(options?: DisplayProcessorOptions): DisplayProcessor;
declare function getEnumDisplayProcessor(theme: GrafanaTheme2, cfg?: EnumFieldConfig): DisplayProcessor;
declare function getRawDisplayProcessor(): DisplayProcessor;

/**
 * Base class for editor builders
 *
 * @beta
 */
interface OptionEditorConfig<TOptions, TSettings = any, TValue = any> {
    /**
     * Path of the option property to control.
     *
     * @example
     * Given options object of a type:
     * ```ts
     * interface Options {
     *   a: {
     *     b: string;
     *   }
     * }
     * ```
     *
     * path can be either 'a' or 'a.b'.
     */
    path: (keyof TOptions & string) | string;
    /**
     * Name of the option. Will be displayed in the UI as form element label.
     */
    name: string;
    /**
     * Description of the option. Will be displayed in the UI as form element description.
     */
    description?: string;
    /**
     * Custom settings of the editor.
     */
    settings?: TSettings;
    /**
     * Array of strings representing category of the option. First element in the array will make option render as collapsible section.
     */
    category?: string[];
    /**
     * Set this value if undefined
     */
    defaultValue?: TValue;
    /**
     * Function that enables configuration of when option editor should be shown based on current panel option properties.
     */
    showIf?: (currentOptions: TOptions, data?: DataFrame[]) => boolean | undefined;
}

/**
 * Option editor registry item
 */
interface OptionsEditorItem<TOptions, TSettings, TEditorProps, TValue> extends RegistryItem, OptionEditorConfig<TOptions, TSettings, TValue> {
    /**
     * React component used to edit the options property
     */
    editor: ComponentType<TEditorProps>;
    getItemsCount?: (value?: TValue) => number;
}
/**
 * Describes an API for option editors UI builder
 */
interface OptionsUIRegistryBuilderAPI<TOptions, TEditorProps, T extends OptionsEditorItem<TOptions, any, TEditorProps, any>> {
    addNumberInput?<TSettings extends NumberFieldConfigSettings = NumberFieldConfigSettings>(config: OptionEditorConfig<TOptions, TSettings, number>): this;
    addSliderInput?<TSettings extends SliderFieldConfigSettings = SliderFieldConfigSettings>(config: OptionEditorConfig<TOptions, TSettings, number>): this;
    addTextInput?<TSettings extends StringFieldConfigSettings = StringFieldConfigSettings>(config: OptionEditorConfig<TOptions, TSettings, string>): this;
    addStringArray?<TSettings extends StringFieldConfigSettings = StringFieldConfigSettings>(config: OptionEditorConfig<TOptions, TSettings, string[]>): this;
    addSelect?<TOption, TSettings extends SelectFieldConfigSettings<TOption>>(config: OptionEditorConfig<TOptions, TSettings, TOption>): this;
    addRadio?<TOption, TSettings extends SelectFieldConfigSettings<TOption> = SelectFieldConfigSettings<TOption>>(config: OptionEditorConfig<TOptions, TSettings, TOption>): this;
    addBooleanSwitch?<TSettings = any>(config: OptionEditorConfig<TOptions, TSettings, boolean>): this;
    addUnitPicker?<TSettings = any>(config: OptionEditorConfig<TOptions, TSettings, string>): this;
    addColorPicker?<TSettings = any>(config: OptionEditorConfig<TOptions, TSettings, string>): this;
    /**
     * Enables custom editor definition
     * @param config
     */
    addCustomEditor<TSettings, TValue>(config: OptionsEditorItem<TOptions, TSettings, TEditorProps, TValue>): this;
    /**
     * Returns registry of option editors
     */
    getRegistry: () => Registry<T>;
}
declare abstract class OptionsUIRegistryBuilder<TOptions, TEditorProps, T extends OptionsEditorItem<TOptions, any, TEditorProps, any>> implements OptionsUIRegistryBuilderAPI<TOptions, TEditorProps, T> {
    private properties;
    addCustomEditor<TSettings, TValue>(config: T & OptionsEditorItem<TOptions, TSettings, TEditorProps, TValue>): this;
    getRegistry(): Registry<T>;
    getItems(): T[];
}

interface DynamicConfigValue {
    id: string;
    value?: any;
}
interface ConfigOverrideRule {
    matcher: MatcherConfig;
    properties: DynamicConfigValue[];
}
/**
 * Describes config override rules created when interacting with Grafana.
 *
 * @internal
 */
interface SystemConfigOverrideRule extends ConfigOverrideRule {
    __systemRef: string;
}
/**
 * Guard functionality to check if an override rule is of type {@link SystemConfigOverrideRule}.
 * It will only return true if the {@link SystemConfigOverrideRule} has the passed systemRef.
 *
 * @param ref system override reference
 * @internal
 */
declare function isSystemOverrideWithRef<T extends SystemConfigOverrideRule>(ref: string): (override: ConfigOverrideRule) => override is T;
/**
 * Guard functionality to check if an override rule is of type {@link SystemConfigOverrideRule}.
 * It will return true if the {@link SystemConfigOverrideRule} has any systemRef set.
 *
 * @internal
 */
declare const isSystemOverride: (override: ConfigOverrideRule) => override is SystemConfigOverrideRule;
interface FieldConfigSource<TOptions = any> {
    defaults: FieldConfig<TOptions>;
    overrides: ConfigOverrideRule[];
}
interface FieldOverrideContext extends StandardEditorContext<any, any> {
    field?: Field;
    dataFrameIndex?: number;
}
interface FieldConfigEditorProps<TValue, TSettings extends {}> extends Omit<StandardEditorProps<TValue, TSettings>, 'item'> {
    item: FieldConfigPropertyItem<any, TValue, TSettings>;
    value: TValue;
    context: FieldOverrideContext;
    onChange: (value?: TValue) => void;
}
interface FieldOverrideEditorProps<TValue, TSettings> extends Omit<StandardEditorProps<TValue>, 'item'> {
    item: FieldConfigPropertyItem<TValue, TSettings>;
    context: FieldOverrideContext;
}
interface FieldConfigEditorConfig<TOptions, TSettings = any, TValue = any> extends OptionEditorConfig<TOptions, TSettings, TValue> {
    /**
     * Function that allows specifying whether or not this field config should apply to a given field.
     * @param field
     */
    shouldApply?: (field: Field) => boolean;
    /** Indicates that option shoukd not be available in the Field config tab */
    hideFromDefaults?: boolean;
    /** Indicates that option should not be available for the overrides */
    hideFromOverrides?: boolean;
}
interface FieldConfigPropertyItem<TOptions = any, TValue = any, TSettings extends {} = any> extends OptionsEditorItem<TOptions, TSettings, FieldConfigEditorProps<TValue, TSettings>, TValue> {
    override: ComponentType<FieldOverrideEditorProps<TValue, TSettings>>;
    /** true for plugin field config properties */
    isCustom?: boolean;
    /** Hides option from the Field config tab */
    hideFromDefaults?: boolean;
    /** Indicates that option should not be available for the overrides */
    hideFromOverrides?: boolean;
    /** Convert the override value to a well typed value */
    process: (value: any, context: FieldOverrideContext, settings?: TSettings) => TValue | undefined | null;
    /** Checks if field should be processed */
    shouldApply: (field: Field) => boolean;
}
interface ApplyFieldOverrideOptions {
    data?: DataFrame[];
    fieldConfig: FieldConfigSource;
    fieldConfigRegistry?: FieldConfigOptionsRegistry;
    replaceVariables: InterpolateFunction;
    theme: GrafanaTheme2;
    timeZone?: TimeZone;
}
declare enum FieldConfigProperty {
    Unit = "unit",
    Min = "min",
    Max = "max",
    Decimals = "decimals",
    DisplayName = "displayName",
    NoValue = "noValue",
    Thresholds = "thresholds",
    Mappings = "mappings",
    Links = "links",
    Color = "color",
    Filterable = "filterable"
}

declare class FieldConfigOptionsRegistry extends Registry<FieldConfigPropertyItem> {
}

interface StandardEditorContext<TOptions, TState = any> {
    data: DataFrame[];
    replaceVariables?: InterpolateFunction;
    eventBus?: EventBus;
    getSuggestions?: (scope?: VariableSuggestionsScope) => VariableSuggestion[];
    options?: TOptions;
    instanceState?: TState;
    isOverride?: boolean;
}
interface StandardEditorProps<TValue = any, TSettings = any, TOptions = any, TState = any> {
    value: TValue;
    onChange: (value?: TValue) => void;
    item: StandardEditorsRegistryItem<TValue, TSettings>;
    context: StandardEditorContext<TOptions, TState>;
    id?: string;
}
interface StandardEditorsRegistryItem<TValue = any, TSettings = any> extends RegistryItem {
    editor: ComponentType<StandardEditorProps<TValue, TSettings>>;
    settings?: TSettings;
}
declare const standardFieldConfigEditorRegistry: FieldConfigOptionsRegistry;
declare const standardEditorsRegistry: Registry<StandardEditorsRegistryItem<any, any>>;

declare const identityOverrideProcessor: <T>(value: T, _context: FieldOverrideContext, _settings: any) => T;
interface NumberFieldConfigSettings {
    placeholder?: string;
    integer?: boolean;
    min?: number;
    max?: number;
    step?: number;
}
declare const numberOverrideProcessor: (value: any, context: FieldOverrideContext, settings?: NumberFieldConfigSettings) => number | undefined;
declare const displayNameOverrideProcessor: (value: any, context: FieldOverrideContext, settings?: StringFieldConfigSettings) => any;
interface SliderFieldConfigSettings {
    min: number;
    max: number;
    step?: number;
    included?: boolean;
    marks?: SliderMarks;
    ariaLabelForHandle?: string;
}
interface DataLinksFieldConfigSettings {
}
declare const dataLinksOverrideProcessor: (value: any, _context: FieldOverrideContext, _settings?: DataLinksFieldConfigSettings) => DataLink<any>[];
interface ValueMappingFieldConfigSettings {
}
declare const valueMappingsOverrideProcessor: (value: any, _context: FieldOverrideContext, _settings?: ValueMappingFieldConfigSettings) => ValueMapping[];
interface SelectFieldConfigSettings<T> {
    allowCustomValue?: boolean;
    isClearable?: boolean;
    /** The default options */
    options: Array<SelectableValue<T>>;
    /** Optionally use the context to define the options */
    getOptions?: (context: FieldOverrideContext) => Promise<Array<SelectableValue<T>>>;
}
declare const selectOverrideProcessor: (value: any, _context: FieldOverrideContext, _settings?: SelectFieldConfigSettings<any>) => any;
interface StringFieldConfigSettings {
    placeholder?: string;
    maxLength?: number;
    expandTemplateVars?: boolean;
    useTextarea?: boolean;
    rows?: number;
}
declare const stringOverrideProcessor: (value: any, context: FieldOverrideContext, settings?: StringFieldConfigSettings) => any;
interface ThresholdsFieldConfigSettings {
}
declare const thresholdsOverrideProcessor: (value: any, _context: FieldOverrideContext, _settings?: ThresholdsFieldConfigSettings) => ThresholdsConfig;
interface UnitFieldConfigSettings {
    isClearable?: boolean;
}
declare const unitOverrideProcessor: (value: boolean, _context: FieldOverrideContext, _settings?: UnitFieldConfigSettings) => boolean;
declare const booleanOverrideProcessor: (value: boolean, _context: FieldOverrideContext, _settings?: ThresholdsFieldConfigSettings) => boolean;
interface FieldColorConfigSettings {
    /**
     * When switching to a visualization that does not support by value coloring then Grafana will
     * switch to a by series palette based color mode
     */
    byValueSupport?: boolean;
    /**
     * When switching to a visualization that has this set to true then Grafana will change color mode
     * to from thresholds if it was set to a by series palette
     */
    preferThresholdsMode?: boolean;
    /**
     * Set to true if the visualization supports both by value and by series
     * This will enable the Color by series UI option that sets the `color.seriesBy` option.
     */
    bySeriesSupport?: boolean;
}
interface StatsPickerConfigSettings {
    /**
     * Enable multi-selection in the stats picker
     */
    allowMultiple: boolean;
    /**
     * Default stats to be use in the stats picker
     */
    defaultStat?: string;
}
interface FieldNamePickerConfigSettings {
    /**
     * Function is a predicate, to test each element of the array.
     * Return a value that coerces to true to keep the field, or to false otherwise.
     */
    filter?: (field: Field) => boolean;
    /**
     * Show this text when no values are found
     */
    noFieldsMessage?: string;
    /**addFieldNamePicker
     * Sets the width to a pixel value.
     */
    width?: number;
    /**
     * Placeholder text to display when nothing is selected.
     */
    placeholderText?: string;
    /** When set to false, the value can not be removed */
    isClearable?: boolean;
}

interface ColorScaleValue {
    percent: number;
    threshold: Threshold;
    color: string;
}
declare type ScaleCalculator = (value: number) => ColorScaleValue;
declare function getScaleCalculator(field: Field, theme: GrafanaTheme2): ScaleCalculator;
declare function getMinMaxAndDelta(field: Field): NumericRange;
/**
 * @internal
 */
declare function getFieldConfigWithMinMax(field: Field, local?: boolean): FieldConfig;

/** @beta */
declare type FieldValueColorCalculator = (value: number, percent: number, Threshold?: Threshold) => string;
/** @beta */
interface FieldColorMode extends RegistryItem {
    getCalculator: (field: Field, theme: GrafanaTheme2) => FieldValueColorCalculator;
    getColors?: (theme: GrafanaTheme2) => string[];
    isContinuous?: boolean;
    isByValue?: boolean;
}
/** @internal */
declare const fieldColorModeRegistry: Registry<FieldColorMode>;
/** @beta */
declare function getFieldColorModeForField(field: Field): FieldColorMode;
/** @beta */
declare function getFieldColorMode(mode?: FieldColorModeId | string): FieldColorMode;
/**
 * @alpha
 * Function that will return a series color for any given color mode. If the color mode is a by value color
 * mode it will use the field.config.color.seriesBy property to figure out which value to use
 */
declare function getFieldSeriesColor(field: Field, theme: GrafanaTheme2): ColorScaleValue;

declare function getActiveThreshold(value: number, thresholds: Threshold[] | undefined): Threshold;
/**
 * Sorts the thresholds
 */
declare function sortThresholds(thresholds: Threshold[]): Threshold[];

/**
 * Fluent API for declarative creation of field config option editors
 */
declare class FieldConfigEditorBuilder<TOptions> extends OptionsUIRegistryBuilder<TOptions, FieldConfigEditorProps<any, any>, FieldConfigPropertyItem<TOptions>> {
    addNumberInput<TSettings>(config: FieldConfigEditorConfig<TOptions, TSettings & NumberFieldConfigSettings, number>): this;
    addSliderInput<TSettings>(config: FieldConfigEditorConfig<TOptions, TSettings & SliderFieldConfigSettings, number>): this;
    addTextInput<TSettings>(config: FieldConfigEditorConfig<TOptions, TSettings & StringFieldConfigSettings, string>): this;
    addSelect<TOption, TSettings extends SelectFieldConfigSettings<TOption>>(config: FieldConfigEditorConfig<TOptions, TSettings, TOption>): this;
    addRadio<TOption, TSettings = any>(config: FieldConfigEditorConfig<TOptions, TSettings, TOption>): this;
    addBooleanSwitch<TSettings = any>(config: FieldConfigEditorConfig<TOptions, TSettings, boolean>): this;
    addColorPicker<TSettings = any>(config: FieldConfigEditorConfig<TOptions, TSettings, string>): this;
    addUnitPicker<TSettings = any>(config: FieldConfigEditorConfig<TOptions, TSettings & UnitFieldConfigSettings, string>): this;
    addFieldNamePicker<TSettings = any>(config: FieldConfigEditorConfig<TOptions, TSettings & FieldNamePickerConfigSettings, string>): this;
}
interface NestedValueAccess {
    getValue: (path: string) => any;
    onChange: (path: string, value: any) => void;
    getContext?: (parent: StandardEditorContext<any, any>) => StandardEditorContext<any, any>;
}
interface NestedPanelOptions<TSub = any> {
    path: string;
    category?: string[];
    defaultValue?: TSub;
    build: PanelOptionsSupplier<TSub>;
    values?: (parent: NestedValueAccess) => NestedValueAccess;
}
/**
 * Fluent API for declarative creation of panel options
 */
declare class PanelOptionsEditorBuilder<TOptions> extends OptionsUIRegistryBuilder<TOptions, StandardEditorProps, PanelOptionsEditorItem<TOptions>> {
    addNestedOptions<Sub>(opts: NestedPanelOptions<Sub>): this;
    addNumberInput<TSettings>(config: PanelOptionsEditorConfig<TOptions, TSettings & NumberFieldConfigSettings, number>): this;
    addSliderInput<TSettings>(config: PanelOptionsEditorConfig<TOptions, TSettings & SliderFieldConfigSettings, number>): this;
    addTextInput<TSettings>(config: PanelOptionsEditorConfig<TOptions, TSettings & StringFieldConfigSettings, string>): this;
    addStringArray<TSettings>(config: PanelOptionsEditorConfig<TOptions, TSettings & StringFieldConfigSettings, string[]>): this;
    addSelect<TOption, TSettings extends SelectFieldConfigSettings<TOption>>(config: PanelOptionsEditorConfig<TOptions, TSettings, TOption>): this;
    addMultiSelect<TOption, TSettings extends SelectFieldConfigSettings<TOption>>(config: PanelOptionsEditorConfig<TOptions, TSettings, TOption>): this;
    addRadio<TOption, TSettings extends SelectFieldConfigSettings<TOption>>(config: PanelOptionsEditorConfig<TOptions, TSettings, TOption>): this;
    addBooleanSwitch<TSettings = any>(config: PanelOptionsEditorConfig<TOptions, TSettings, boolean>): this;
    addColorPicker<TSettings = any>(config: PanelOptionsEditorConfig<TOptions, TSettings, string>): this;
    addTimeZonePicker<TSettings = any>(config: PanelOptionsEditorConfig<TOptions, TSettings, string>): this;
    addUnitPicker<TSettings = any>(config: PanelOptionsEditorConfig<TOptions, TSettings & UnitFieldConfigSettings, string>): this;
    addFieldNamePicker<TSettings = any>(config: PanelOptionsEditorConfig<TOptions, TSettings & FieldNamePickerConfigSettings, string>): this;
    addDashboardPicker<TSettings = any>(config: PanelOptionsEditorConfig<TOptions, TSettings & FieldNamePickerConfigSettings, string>): this;
}

/** @beta */
declare type StandardOptionConfig = {
    defaultValue?: any;
    settings?: any;
};
/** @beta */
interface SetFieldConfigOptionsArgs<TFieldConfigOptions = any> {
    /**
     * Configuration object of the standard field config properites
     *
     * @example
     * ```typescript
     * {
     *   standardOptions: {
     *     [FieldConfigProperty.Decimals]: {
     *       defaultValue: 3
     *     }
     *   }
     * }
     * ```
     */
    standardOptions?: Partial<Record<FieldConfigProperty, StandardOptionConfig>>;
    /**
     * Array of standard field config properties that should not be available in the panel
     * @example
     * ```typescript
     * {
     *   disableStandardOptions: [FieldConfigProperty.Min, FieldConfigProperty.Max, FieldConfigProperty.Unit]
     * }
     * ```
     */
    disableStandardOptions?: FieldConfigProperty[];
    /**
     * Function that allows custom field config properties definition.
     *
     * @param builder
     *
     * @example
     * ```typescript
     * useCustomConfig: builder => {
     *   builder
     *    .addNumberInput({
     *      id: 'shapeBorderWidth',
     *      name: 'Border width',
     *      description: 'Border width of the shape',
     *      settings: {
     *        min: 1,
     *        max: 5,
     *      },
     *    })
     *    .addSelect({
     *      id: 'displayMode',
     *      name: 'Display mode',
     *      description: 'How the shape shout be rendered'
     *      settings: {
     *      options: [{value: 'fill', label: 'Fill' }, {value: 'transparent', label: 'Transparent }]
     *    },
     *  })
     * }
     * ```
     */
    useCustomConfig?: (builder: FieldConfigEditorBuilder<TFieldConfigOptions>) => void;
}
declare type PanelOptionsSupplier<TOptions> = (builder: PanelOptionsEditorBuilder<TOptions>, context: StandardEditorContext<TOptions>) => void;
declare class PanelPlugin<TOptions = any, TFieldConfigOptions extends object = any> extends GrafanaPlugin<PanelPluginMeta> {
    private _defaults?;
    private _fieldConfigDefaults;
    private _fieldConfigRegistry?;
    private _initConfigRegistry;
    private optionsSupplier?;
    private suggestionsSupplier?;
    panel: ComponentType<PanelProps<TOptions>> | null;
    editor?: ComponentClass<PanelEditorProps<TOptions>>;
    onPanelMigration?: PanelMigrationHandler<TOptions>;
    onPanelTypeChanged?: PanelTypeChangedHandler<TOptions>;
    noPadding?: boolean;
    dataSupport: PanelPluginDataSupport;
    /**
     * Legacy angular ctrl.  If this exists it will be used instead of the panel
     */
    angularPanelCtrl?: any;
    constructor(panel: ComponentType<PanelProps<TOptions>> | null);
    get defaults(): {};
    get fieldConfigDefaults(): FieldConfigSource<TFieldConfigOptions>;
    /**
     * @deprecated setDefaults is deprecated in favor of setPanelOptions
     */
    setDefaults(defaults: TOptions): this;
    get fieldConfigRegistry(): FieldConfigOptionsRegistry;
    /**
     * @deprecated setEditor is deprecated in favor of setPanelOptions
     */
    setEditor(editor: ComponentClass<PanelEditorProps<TOptions>>): this;
    setNoPadding(): this;
    /**
     * This function is called before the panel first loads if
     * the current version is different than the version that was saved.
     *
     * This is a good place to support any changes to the options model
     */
    setMigrationHandler(handler: PanelMigrationHandler<TOptions>): this;
    /**
     * This function is called when the visualization was changed. This
     * passes in the panel model for previous visualisation options inspection
     * and panel model updates.
     *
     * This is useful for supporting PanelModel API updates when changing
     * between Angular and React panels.
     */
    setPanelChangeHandler(handler: PanelTypeChangedHandler): this;
    /**
     * Enables panel options editor creation
     *
     * @example
     * ```typescript
     *
     * import { ShapePanel } from './ShapePanel';
     *
     * interface ShapePanelOptions {}
     *
     * export const plugin = new PanelPlugin<ShapePanelOptions>(ShapePanel)
     *   .setPanelOptions(builder => {
     *     builder
     *       .addSelect({
     *         id: 'shape',
     *         name: 'Shape',
     *         description: 'Select shape to render'
     *         settings: {
     *           options: [
     *             {value: 'circle', label: 'Circle' },
     *             {value: 'square', label: 'Square },
     *             {value: 'triangle', label: 'Triangle }
     *            ]
     *         },
     *       })
     *   })
     * ```
     *
     * @public
     **/
    setPanelOptions(builder: PanelOptionsSupplier<TOptions>): this;
    /**
     * This is used while building the panel options editor.
     *
     * @internal
     */
    getPanelOptionsSupplier(): PanelOptionsSupplier<TOptions>;
    /**
     * Tells Grafana if the plugin should subscribe to annotation and alertState results.
     *
     * @example
     * ```typescript
     *
     * import { ShapePanel } from './ShapePanel';
     *
     * interface ShapePanelOptions {}
     *
     * export const plugin = new PanelPlugin<ShapePanelOptions>(ShapePanel)
     *     .useFieldConfig({})
     *     ...
     *     ...
     *     .setDataSupport({
     *       annotations: true,
     *       alertStates: true,
     *     });
     * ```
     *
     * @public
     **/
    setDataSupport(support: Partial<PanelPluginDataSupport>): this;
    /**
     * Allows specifying which standard field config options panel should use and defining default values
     *
     * @example
     * ```typescript
     *
     * import { ShapePanel } from './ShapePanel';
     *
     * interface ShapePanelOptions {}
     *
     * // when plugin should use all standard options
     * export const plugin = new PanelPlugin<ShapePanelOptions>(ShapePanel)
     *  .useFieldConfig();
     *
     * // when plugin should only display specific standard options
     * // note, that options will be displayed in the order they are provided
     * export const plugin = new PanelPlugin<ShapePanelOptions>(ShapePanel)
     *  .useFieldConfig({
     *    standardOptions: [FieldConfigProperty.Min, FieldConfigProperty.Max]
     *   });
     *
     * // when standard option's default value needs to be provided
     * export const plugin = new PanelPlugin<ShapePanelOptions>(ShapePanel)
     *  .useFieldConfig({
     *    standardOptions: [FieldConfigProperty.Min, FieldConfigProperty.Max],
     *    standardOptionsDefaults: {
     *      [FieldConfigProperty.Min]: 20,
     *      [FieldConfigProperty.Max]: 100
     *    }
     *  });
     *
     * // when custom field config options needs to be provided
     * export const plugin = new PanelPlugin<ShapePanelOptions>(ShapePanel)
     *  .useFieldConfig({
     *    useCustomConfig: builder => {
     *      builder
     *       .addNumberInput({
     *         id: 'shapeBorderWidth',
     *         name: 'Border width',
     *         description: 'Border width of the shape',
     *         settings: {
     *           min: 1,
     *           max: 5,
     *         },
     *       })
     *       .addSelect({
     *         id: 'displayMode',
     *         name: 'Display mode',
     *         description: 'How the shape shout be rendered'
     *         settings: {
     *         options: [{value: 'fill', label: 'Fill' }, {value: 'transparent', label: 'Transparent }]
     *       },
     *     })
     *   },
     *  });
     *
     * ```
     *
     * @public
     */
    useFieldConfig(config?: SetFieldConfigOptionsArgs<TFieldConfigOptions>): this;
    /**
     * Sets function that can return visualization examples and suggestions.
     * @alpha
     */
    setSuggestionsSupplier(supplier: VisualizationSuggestionsSupplier): this;
    /**
     * Returns the suggestions supplier
     * @alpha
     */
    getSuggestionsSupplier(): VisualizationSuggestionsSupplier | undefined;
    hasPluginId(pluginId: string): boolean;
}

/**
 * Return a copy of the DataFrame with all rules applied
 */
declare function applyFieldOverrides(options: ApplyFieldOverrideOptions): DataFrame[];
/**
 * This checks that all options on FieldConfig make sense.  It mutates any value that needs
 * fixed.  In particular this makes sure that the first threshold value is -Infinity (not valid in JSON)
 */
declare function validateFieldConfig(config: FieldConfig): void;
declare const getLinksSupplier: (frame: DataFrame, field: Field, fieldScopedVars: ScopedVars, replaceVariables: InterpolateFunction, timeZone?: TimeZone) => (config: ValueLinkConfig) => Array<LinkModel<Field>>;
/**
 * Return a copy of the DataFrame with raw data
 */
declare function applyRawFieldOverrides(data: DataFrame[]): DataFrame[];
/**
 * @internal
 */
declare function useFieldOverrides(plugin: PanelPlugin | undefined, fieldConfig: FieldConfigSource | undefined, data: PanelData | undefined, timeZone: string, theme: GrafanaTheme2, replace: InterpolateFunction): PanelData | undefined;

/**
 * Creates a proxy object that allows accessing fields on dataFrame through various means and then returns it's
 * display value. This is mainly useful for example in data links interpolation where you can easily create a scoped
 * variable that will allow you to access dataFrame data with ${__data.fields.fieldName}.
 * Allows accessing fields by name, index, displayName or 'name' label
 *
 * @param options
 * @internal
 */
declare function getFieldDisplayValuesProxy(options: {
    frame: DataFrame;
    rowIndex: number;
    timeZone?: TimeZone;
}): Record<string, DisplayValue>;

/**
 * Get an appropriate display title
 */
declare function getFrameDisplayName(frame: DataFrame, index?: number): string;
declare function getFieldDisplayName(field: Field, frame?: DataFrame, allFrames?: DataFrame[]): string;

/**
 * @internal
 */
declare enum AlertState {
    NoData = "no_data",
    Paused = "paused",
    Alerting = "alerting",
    OK = "ok",
    Pending = "pending",
    Unknown = "unknown"
}
/**
 * @internal
 */
interface AlertStateInfo {
    id: number;
    dashboardId: number;
    panelId: number;
    state: AlertState;
}

declare enum DashboardCursorSync {
    Off = 0,
    Crosshair = 1,
    Tooltip = 2
}
/**
 * @public
 */
interface PanelModel<TOptions = any, TCustomFieldConfig = any> {
    /** ID of the panel within the current dashboard */
    id: number;
    /** The panel type */
    type: string;
    /** Panel title */
    title?: string;
    /** Description */
    description?: string;
    /** Panel options */
    options: TOptions;
    /** Field options configuration */
    fieldConfig: FieldConfigSource<TCustomFieldConfig>;
    /** Version of the panel plugin */
    pluginVersion?: string;
    /** The datasource used in all targets */
    datasource?: DataSourceRef | null;
    /** The queries in a panel */
    targets?: DataQuery[];
    /** alerting v1 object */
    alert?: any;
}

/**
 * This JSON object is stored in the dashboard json model.
 */
interface AnnotationQuery<TQuery extends DataQuery = DataQuery> {
    datasource?: DataSourceRef | null;
    enable: boolean;
    name: string;
    iconColor: string;
    hide?: boolean;
    builtIn?: number;
    type?: string;
    snapshotData?: any;
    target?: TQuery;
    mappings?: AnnotationEventMappings;
    [key: string]: any;
}
interface AnnotationEvent {
    id?: string;
    annotation?: any;
    dashboardId?: number;
    dashboardUID?: string;
    panelId?: number;
    userId?: number;
    login?: string;
    email?: string;
    avatarUrl?: string;
    time?: number;
    timeEnd?: number;
    isRegion?: boolean;
    title?: string;
    text?: string;
    type?: string;
    tags?: string[];
    color?: string;
    alertId?: number;
    newState?: string;
    source?: any;
}
interface AnnotationEventUIModel {
    id?: string;
    from: number;
    to: number;
    tags: string[];
    description: string;
}
/**
 * @alpha -- any value other than `field` is experimental
 */
declare enum AnnotationEventFieldSource {
    Field = "field",
    Text = "text",
    Skip = "skip"
}
interface AnnotationEventFieldMapping {
    source?: AnnotationEventFieldSource;
    value?: string;
    regex?: string;
}
declare type AnnotationEventMappings = Partial<Record<keyof AnnotationEvent, AnnotationEventFieldMapping>>;
declare type AnnotationQueryEditorProps<TQuery extends DataQuery> = QueryEditorProps<any, TQuery> & {
    annotation?: AnnotationQuery<TQuery>;
    onAnnotationChange?: (annotation: AnnotationQuery<TQuery>) => void;
};
/**
 * Since Grafana 7.2
 *
 * This offers a generic approach to annotation processing
 */
interface AnnotationSupport<TQuery extends DataQuery = DataQuery, TAnno = AnnotationQuery<TQuery>> {
    /**
     * This hook lets you manipulate any existing stored values before running them though the processor.
     * This is particularly helpful when dealing with migrating old formats.  ie query as a string vs object.
     */
    prepareAnnotation?(json: any): TAnno;
    /**
     * Convert the stored JSON model to a standard datasource query object.
     * This query will be executed in the datasource and the results converted into events.
     * Returning an undefined result will quietly skip query execution
     */
    prepareQuery?(anno: TAnno): TQuery | undefined;
    /**
     * When the standard frame > event processing is insufficient, this allows explicit control of the mappings
     */
    processEvents?(anno: TAnno, data: DataFrame[]): Observable<AnnotationEvent[] | undefined>;
    /**
     * Specify a custom QueryEditor for the annotation page.  If not specified, the standard one will be used
     */
    QueryEditor?: ComponentType<AnnotationQueryEditorProps<TQuery>>;
    /**
     * Define this method if you want to pre-populate the editor with a default query
     */
    getDefaultQuery?(): Partial<TQuery>;
}

declare const availableIconsIndex: {
    google: boolean;
    microsoft: boolean;
    github: boolean;
    gitlab: boolean;
    okta: boolean;
    discord: boolean;
    hipchat: boolean;
    'google-hangouts-alt': boolean;
    pagerduty: boolean;
    line: boolean;
    anchor: boolean;
    'adjust-circle': boolean;
    'angle-double-down': boolean;
    'angle-double-right': boolean;
    'angle-double-up': boolean;
    'angle-down': boolean;
    'angle-left': boolean;
    'angle-right': boolean;
    'angle-up': boolean;
    apps: boolean;
    arrow: boolean;
    'arrow-down': boolean;
    'arrow-from-right': boolean;
    'arrow-left': boolean;
    'arrow-random': boolean;
    'arrow-right': boolean;
    'arrow-to-right': boolean;
    'arrow-up': boolean;
    'arrows-h': boolean;
    'arrows-v': boolean;
    'expand-arrows': boolean;
    at: boolean;
    backward: boolean;
    bars: boolean;
    bell: boolean;
    'bell-slash': boolean;
    bolt: boolean;
    book: boolean;
    bookmark: boolean;
    'book-open': boolean;
    'brackets-curly': boolean;
    bug: boolean;
    building: boolean;
    'calculator-alt': boolean;
    'calendar-alt': boolean;
    'calendar-slash': boolean;
    camera: boolean;
    capture: boolean;
    'channel-add': boolean;
    'chart-line': boolean;
    check: boolean;
    'check-circle': boolean;
    'check-square': boolean;
    circle: boolean;
    'circle-mono': boolean;
    'clipboard-alt': boolean;
    'clock-nine': boolean;
    cloud: boolean;
    'cloud-download': boolean;
    'cloud-upload': boolean;
    'code-branch': boolean;
    cog: boolean;
    columns: boolean;
    'comment-alt': boolean;
    'comment-alt-message': boolean;
    'comment-alt-share': boolean;
    'comments-alt': boolean;
    compass: boolean;
    copy: boolean;
    'corner-down-right-alt': boolean;
    'create-dashboard': boolean;
    'credit-card': boolean;
    crosshair: boolean;
    cube: boolean;
    dashboard: boolean;
    database: boolean;
    'dice-three': boolean;
    'document-info': boolean;
    'download-alt': boolean;
    draggabledots: boolean;
    edit: boolean;
    'ellipsis-v': boolean;
    envelope: boolean;
    'exchange-alt': boolean;
    'exclamation-triangle': boolean;
    'exclamation-circle': boolean;
    'external-link-alt': boolean;
    eye: boolean;
    'eye-slash': boolean;
    'ellipsis-h': boolean;
    'fa fa-spinner': boolean;
    favorite: boolean;
    'file-alt': boolean;
    'file-blank': boolean;
    'file-copy-alt': boolean;
    'file-download': boolean;
    filter: boolean;
    flip: boolean;
    folder: boolean;
    font: boolean;
    fire: boolean;
    'folder-open': boolean;
    'folder-plus': boolean;
    'folder-upload': boolean;
    forward: boolean;
    'gf-bar-alignment-after': boolean;
    'gf-bar-alignment-before': boolean;
    'gf-bar-alignment-center': boolean;
    'gf-glue': boolean;
    'gf-grid': boolean;
    'gf-interpolation-linear': boolean;
    'gf-interpolation-smooth': boolean;
    'gf-interpolation-step-after': boolean;
    'gf-interpolation-step-before': boolean;
    'gf-landscape': boolean;
    'gf-layout-simple': boolean;
    'gf-logs': boolean;
    'gf-movepane-left': boolean;
    'gf-movepane-right': boolean;
    'gf-portrait': boolean;
    'gf-service-account': boolean;
    'gf-show-context': boolean;
    grafana: boolean;
    'graph-bar': boolean;
    'grafana-ml': boolean;
    heart: boolean;
    'heart-rate': boolean;
    'heart-break': boolean;
    history: boolean;
    'history-alt': boolean;
    home: boolean;
    'home-alt': boolean;
    'horizontal-align-center': boolean;
    'horizontal-align-left': boolean;
    'horizontal-align-right': boolean;
    hourglass: boolean;
    import: boolean;
    info: boolean;
    'info-circle': boolean;
    k6: boolean;
    'key-skeleton-alt': boolean;
    keyboard: boolean;
    'layer-group': boolean;
    'layers-alt': boolean;
    'library-panel': boolean;
    'line-alt': boolean;
    link: boolean;
    'list-ui-alt': boolean;
    'list-ul': boolean;
    'list-ol': boolean;
    lock: boolean;
    'map-marker': boolean;
    message: boolean;
    minus: boolean;
    'minus-circle': boolean;
    'mobile-android': boolean;
    monitor: boolean;
    palette: boolean;
    'panel-add': boolean;
    'pathfinder-unite': boolean;
    pause: boolean;
    pen: boolean;
    percentage: boolean;
    play: boolean;
    plug: boolean;
    plus: boolean;
    'plus-circle': boolean;
    'plus-square': boolean;
    power: boolean;
    'presentation-play': boolean;
    process: boolean;
    'question-circle': boolean;
    'record-audio': boolean;
    repeat: boolean;
    rocket: boolean;
    'ruler-combined': boolean;
    save: boolean;
    search: boolean;
    'search-minus': boolean;
    'search-plus': boolean;
    'share-alt': boolean;
    shield: boolean;
    'shield-exclamation': boolean;
    signal: boolean;
    signin: boolean;
    signout: boolean;
    sitemap: boolean;
    slack: boolean;
    'sliders-v-alt': boolean;
    'sort-amount-down': boolean;
    'sort-amount-up': boolean;
    'square-shape': boolean;
    star: boolean;
    'step-backward': boolean;
    'stopwatch-slash': boolean;
    sync: boolean;
    'sync-slash': boolean;
    table: boolean;
    'tag-alt': boolean;
    'telegram-alt': boolean;
    'text-fields': boolean;
    'thumbs-up': boolean;
    times: boolean;
    'times-circle': boolean;
    'toggle-on': boolean;
    'toggle-off': boolean;
    'trash-alt': boolean;
    unlock: boolean;
    upload: boolean;
    user: boolean;
    'users-alt': boolean;
    'user-arrows': boolean;
    'vertical-align-bottom': boolean;
    'vertical-align-center': boolean;
    'vertical-align-top': boolean;
    'wrap-text': boolean;
    rss: boolean;
    x: boolean;
};
declare type IconName = keyof typeof availableIconsIndex;
declare function isIconName(iconName: unknown): iconName is IconName;
declare function toIconName(iconName: string): IconName | undefined;

interface NavLinkDTO {
    id?: string;
    text: string;
    description?: string;
    section?: NavSection;
    subTitle?: string;
    icon?: IconName;
    img?: string;
    url?: string;
    target?: LinkTarget;
    sortWeight?: number;
    divider?: boolean;
    hideFromMenu?: boolean;
    hideFromTabs?: boolean;
    showIconInNavbar?: boolean;
    roundIcon?: boolean;
    /**
     * This is true for some sections that have no children (but is still a section)
     **/
    isSection?: boolean;
    children?: NavLinkDTO[];
    highlightText?: string;
    emptyMessageId?: string;
    pluginId?: string;
    isCreateAction?: boolean;
}
interface NavModelItem extends NavLinkDTO {
    children?: NavModelItem[];
    active?: boolean;
    breadcrumbs?: NavModelBreadcrumb[];
    parentItem?: NavModelItem;
    showOrgSwitcher?: boolean;
    onClick?: () => void;
    menuItemType?: NavMenuItemType;
    highlightText?: string;
    highlightId?: string;
    tabSuffix?: ComponentType<{
        className?: string;
    }>;
    hideFromBreadcrumbs?: boolean;
    emptyMessage?: string;
}
declare enum NavSection {
    Core = "core",
    Plugin = "plugin",
    Config = "config"
}
declare enum NavMenuItemType {
    Section = "section",
    Item = "item"
}
/**
 *  Interface used to describe  different kinds of page titles and page navigation. Navmodels are usually generated in the backend and stored in Redux.
 */
interface NavModel {
    /**
     *  Main page. that wraps the navigation. Generate the `children` property generate tabs when used with the Page component.
     */
    main: NavModelItem;
    /**
     *   This is the current active tab/navigation.
     */
    node: NavModelItem;
}
interface NavModelBreadcrumb {
    title: string;
    url?: string;
}
declare type NavIndex = {
    [s: string]: NavModelItem;
};
declare enum PageLayoutType {
    Standard = 0,
    Canvas = 1,
    Custom = 2
}

/** Describes plugins life cycle status */
declare enum PluginState {
    alpha = "alpha",
    beta = "beta",
    stable = "stable",
    deprecated = "deprecated"
}
/** Describes {@link https://grafana.com/docs/grafana/latest/plugins | type of plugin} */
declare enum PluginType {
    panel = "panel",
    datasource = "datasource",
    app = "app",
    renderer = "renderer",
    secretsmanager = "secretsmanager"
}
/** Describes status of {@link https://grafana.com/docs/grafana/latest/plugins/plugin-signatures/ | plugin signature} */
declare enum PluginSignatureStatus {
    internal = "internal",
    valid = "valid",
    invalid = "invalid",
    modified = "modified",
    missing = "missing"
}
/** Describes level of {@link https://grafana.com/docs/grafana/latest/plugins/plugin-signatures/#plugin-signature-levels/ | plugin signature level} */
declare enum PluginSignatureType {
    grafana = "grafana",
    commercial = "commercial",
    community = "community",
    private = "private",
    core = "core"
}
/** Describes error code returned from Grafana plugins API call */
declare enum PluginErrorCode {
    missingSignature = "signatureMissing",
    invalidSignature = "signatureInvalid",
    modifiedSignature = "signatureModified"
}
/** Describes error returned from Grafana plugins API call */
interface PluginError {
    errorCode: PluginErrorCode;
    pluginId: string;
}
interface PluginMeta<T extends KeyValue = {}> {
    id: string;
    name: string;
    type: PluginType;
    info: PluginMetaInfo;
    includes?: PluginInclude[];
    state?: PluginState;
    module: string;
    baseUrl: string;
    dependencies?: PluginDependencies;
    jsonData?: T;
    secureJsonData?: KeyValue;
    secureJsonFields?: KeyValue<boolean>;
    enabled?: boolean;
    defaultNavUrl?: string;
    hasUpdate?: boolean;
    enterprise?: boolean;
    latestVersion?: string;
    pinned?: boolean;
    signature?: PluginSignatureStatus;
    signatureType?: PluginSignatureType;
    signatureOrg?: string;
    live?: boolean;
}
interface PluginDependencyInfo {
    id: string;
    name: string;
    version: string;
    type: PluginType;
}
interface PluginDependencies {
    grafanaDependency?: string;
    grafanaVersion: string;
    plugins: PluginDependencyInfo[];
}
declare enum PluginIncludeType {
    dashboard = "dashboard",
    page = "page",
    panel = "panel",
    datasource = "datasource"
}
interface PluginInclude {
    type: PluginIncludeType;
    name: string;
    path?: string;
    icon?: string;
    role?: string;
    addToNav?: boolean;
    component?: string;
}
interface PluginMetaInfoLink {
    name: string;
    url: string;
    target?: '_blank' | '_self' | '_parent' | '_top';
}
interface PluginBuildInfo {
    time?: number;
    repo?: string;
    branch?: string;
    hash?: string;
    number?: number;
    pr?: number;
}
interface ScreenshotInfo {
    name: string;
    path: string;
}
interface PluginMetaInfo {
    author: {
        name: string;
        url?: string;
    };
    description: string;
    links: PluginMetaInfoLink[];
    logos: {
        large: string;
        small: string;
    };
    build?: PluginBuildInfo;
    screenshots: ScreenshotInfo[];
    updated: string;
    version: string;
}
interface PluginConfigPageProps<T extends PluginMeta> {
    plugin: GrafanaPlugin<T>;
    query: KeyValue;
}
interface PluginConfigPage<T extends PluginMeta> {
    title: string;
    icon?: IconName;
    id: string;
    body: ComponentType<PluginConfigPageProps<T>>;
}
declare class GrafanaPlugin<T extends PluginMeta = PluginMeta> {
    meta: T;
    loadError?: boolean;
    angularConfigCtrl?: any;
    configPages?: Array<PluginConfigPage<T>>;
    addConfigPage(tab: PluginConfigPage<T>): this;
    /**
     * @deprecated -- this is no longer necessary and will be removed
     */
    setChannelSupport(support: any): this;
    constructor();
}

declare enum PluginExtensionTypes {
    link = "link"
}
declare type PluginExtension = {
    id: string;
    type: PluginExtensionTypes;
    title: string;
    description: string;
    pluginId: string;
};
declare type PluginExtensionLink = PluginExtension & {
    type: PluginExtensionTypes.link;
    path?: string;
    onClick?: (event?: React.MouseEvent) => void;
};
declare type PluginExtensionConfig<Context extends object = object, ExtraProps extends object = object> = Pick<PluginExtension, 'title' | 'description'> & ExtraProps & {
    extensionPointId: string;
    configure?: (context?: Readonly<Context>) => Partial<{
        title: string;
        description: string;
    } & ExtraProps> | undefined;
};
declare type PluginExtensionLinkConfig<Context extends object = object> = PluginExtensionConfig<Context, Pick<PluginExtensionLink, 'path'> & {
    type: PluginExtensionTypes.link;
    onClick?: (event: React.MouseEvent | undefined, helpers: PluginExtensionEventHelpers<Context>) => void;
}>;
declare type PluginExtensionEventHelpers<Context extends object = object> = {
    context?: Readonly<Context>;
    openModal: (options: {
        title: string;
        body: React.ElementType<{
            onDismiss?: () => void;
        }>;
    }) => void;
};
declare enum PluginExtensionPoints {
    DashboardPanelMenu = "grafana/dashboard/panel/menu"
}
declare type PluginExtensionPanelContext = {
    pluginId: string;
    id: number;
    title: string;
    timeRange: RawTimeRange;
    timeZone: TimeZone;
    dashboard: Dashboard;
    targets: DataQuery$1[];
};
declare type Dashboard = {
    uid: string;
    title: string;
    tags: string[];
};

/**
 * @public
 * The app container that is loading another plugin (panel or query editor)
 * */
declare enum CoreApp {
    CloudAlerting = "cloud-alerting",
    UnifiedAlerting = "unified-alerting",
    Dashboard = "dashboard",
    Explore = "explore",
    Correlations = "correlations",
    Unknown = "unknown",
    PanelEditor = "panel-editor",
    PanelViewer = "panel-viewer"
}
interface AppRootProps<T extends KeyValue = KeyValue> {
    meta: AppPluginMeta<T>;
    /**
     * base URL segment for an app, /app/pluginId
     */
    basename: string;
    /**
     * Pass the nav model to the container... is there a better way?
     * @deprecated Use PluginPage component exported from @grafana/runtime instead
     */
    onNavChanged: (nav: NavModel) => void;
    /**
     * The URL query parameters
     * @deprecated Use react-router instead
     */
    query: KeyValue;
    /**
     * The URL path to this page
     * @deprecated Use react-router instead
     */
    path: string;
}
interface AppPluginMeta<T extends KeyValue = KeyValue> extends PluginMeta<T> {
}
declare class AppPlugin<T extends KeyValue = KeyValue> extends GrafanaPlugin<AppPluginMeta<T>> {
    private _extensionConfigs;
    root?: ComponentType<AppRootProps<T>>;
    /**
     * Called after the module has loaded, and before the app is used.
     * This function may be called multiple times on the same instance.
     * The first time, `this.meta` will be undefined
     */
    init(meta: AppPluginMeta<T>): void;
    /**
     * Set the component displayed under:
     *   /a/${plugin-id}/*
     *
     * If the NavModel is configured, the page will have a managed frame, otheriwse it has full control.
     */
    setRootPage(root: ComponentType<AppRootProps<T>>): this;
    setComponentsFromLegacyExports(pluginExports: any): void;
    get extensionConfigs(): PluginExtensionLinkConfig<object>[];
    configureExtensionLink<Context extends object>(extension: Omit<PluginExtensionLinkConfig<Context>, 'type'>): this;
}
/**
 * Defines life cycle of a feature
 * @internal
 */
declare enum FeatureState {
    alpha = "alpha",
    beta = "beta"
}

/**
 * Enum with the different variable support types
 *
 * @alpha -- experimental
 */
declare enum VariableSupportType {
    Legacy = "legacy",
    Standard = "standard",
    Custom = "custom",
    Datasource = "datasource"
}
/**
 * Base class for VariableSupport classes
 *
 * @alpha -- experimental
 */
declare abstract class VariableSupportBase<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataSourceQueryType<DSType>, TOptions extends DataSourceJsonData = DataSourceOptionsType<DSType>> {
    abstract getType(): VariableSupportType;
    /**
     * Define this method in the config if you want to pre-populate the editor with a default query.
     */
    getDefaultQuery?(): Partial<TQuery>;
}
/**
 * Extend this class in a data source plugin to use the standard query editor for Query variables
 *
 * @alpha -- experimental
 */
declare abstract class StandardVariableSupport<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataSourceQueryType<DSType>, TOptions extends DataSourceJsonData = DataSourceOptionsType<DSType>> extends VariableSupportBase<DSType, TQuery, TOptions> {
    getType(): VariableSupportType;
    abstract toDataQuery(query: StandardVariableQuery): TQuery;
    query?(request: DataQueryRequest<TQuery>): Observable<DataQueryResponse>;
}
/**
 * Extend this class in a data source plugin to use a customized query editor for Query variables
 *
 * @alpha -- experimental
 */
declare abstract class CustomVariableSupport<DSType extends DataSourceApi<TQuery, TOptions>, VariableQuery extends DataQuery = any, TQuery extends DataQuery = DataSourceQueryType<DSType>, TOptions extends DataSourceJsonData = DataSourceOptionsType<DSType>> extends VariableSupportBase<DSType, TQuery, TOptions> {
    getType(): VariableSupportType;
    abstract editor: ComponentType<QueryEditorProps<DSType, TQuery, TOptions, VariableQuery>>;
    abstract query(request: DataQueryRequest<VariableQuery>): Observable<DataQueryResponse>;
}
/**
 * Extend this class in a data source plugin to use the query editor in the data source plugin for Query variables
 *
 * @alpha -- experimental
 */
declare abstract class DataSourceVariableSupport<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataSourceQueryType<DSType>, TOptions extends DataSourceJsonData = DataSourceOptionsType<DSType>> extends VariableSupportBase<DSType, TQuery, TOptions> {
    getType(): VariableSupportType;
}
/**
 * Defines the standard DatQuery used by data source plugins that implement StandardVariableSupport
 *
 * @alpha -- experimental
 */
interface StandardVariableQuery extends DataQuery {
    query: string;
}

interface DataSourcePluginOptionsEditorProps<JSONData extends DataSourceJsonData = DataSourceJsonData, SecureJSONData = {}> {
    options: DataSourceSettings<JSONData, SecureJSONData>;
    onOptionsChange: (options: DataSourceSettings<JSONData, SecureJSONData>) => void;
}
declare type DataSourceQueryType<DSType> = DSType extends DataSourceApi<infer TQuery, any> ? TQuery : never;
declare type DataSourceOptionsType<DSType> = DSType extends DataSourceApi<any, infer TOptions> ? TOptions : never;
declare class DataSourcePlugin<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataSourceQueryType<DSType>, TOptions extends DataSourceJsonData = DataSourceOptionsType<DSType>, TSecureOptions = {}> extends GrafanaPlugin<DataSourcePluginMeta<TOptions>> {
    DataSourceClass: DataSourceConstructor<DSType, TQuery, TOptions>;
    components: DataSourcePluginComponents<DSType, TQuery, TOptions, TSecureOptions>;
    constructor(DataSourceClass: DataSourceConstructor<DSType, TQuery, TOptions>);
    setConfigEditor(editor: ComponentType<DataSourcePluginOptionsEditorProps<TOptions, TSecureOptions>>): this;
    setConfigCtrl(ConfigCtrl: any): this;
    setQueryCtrl(QueryCtrl: any): this;
    setAnnotationQueryCtrl(AnnotationsQueryCtrl: any): this;
    setQueryEditor(QueryEditor: ComponentType<QueryEditorProps<DSType, TQuery, TOptions>>): this;
    /** @deprecated Use `setQueryEditor` instead. When using Explore `props.app` is equal to `CoreApp.Explore` */
    setExploreQueryField(ExploreQueryField: ComponentType<QueryEditorProps<DSType, TQuery, TOptions>>): this;
    /** @deprecated Use `setQueryEditor` instead. */
    setExploreMetricsQueryField(ExploreQueryField: ComponentType<QueryEditorProps<DSType, TQuery, TOptions>>): this;
    /** @deprecated Use `setQueryEditor` instead. */
    setExploreLogsQueryField(ExploreQueryField: ComponentType<QueryEditorProps<DSType, TQuery, TOptions>>): this;
    setQueryEditorHelp(QueryEditorHelp: ComponentType<QueryEditorHelpProps<TQuery>>): this;
    /**
     * @deprecated prefer using `setQueryEditorHelp`
     */
    setExploreStartPage(ExploreStartPage: ComponentType<QueryEditorHelpProps<TQuery>>): this;
    /**
     * @deprecated -- prefer using {@link StandardVariableSupport} or {@link CustomVariableSupport} or {@link DataSourceVariableSupport} in data source instead
     */
    setVariableQueryEditor(VariableQueryEditor: any): this;
    setMetadataInspector(MetadataInspector: ComponentType<MetadataInspectorProps<DSType, TQuery, TOptions>>): this;
    setComponentsFromLegacyExports(pluginExports: any): void;
}
interface DataSourcePluginMeta<T extends KeyValue = {}> extends PluginMeta<T> {
    builtIn?: boolean;
    metrics?: boolean;
    logs?: boolean;
    annotations?: boolean;
    alerting?: boolean;
    tracing?: boolean;
    mixed?: boolean;
    hasQueryHelp?: boolean;
    category?: string;
    queryOptions?: PluginMetaQueryOptions;
    sort?: number;
    streaming?: boolean;
    unlicensed?: boolean;
    backend?: boolean;
    isBackend?: boolean;
}
interface PluginMetaQueryOptions {
    cacheTimeout?: boolean;
    maxDataPoints?: boolean;
    minInterval?: boolean;
}
interface PluginQueryCachingConfig {
    enabled?: boolean;
    TTLMs?: number;
}
interface DataSourcePluginComponents<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData, TSecureOptions = {}> {
    QueryCtrl?: any;
    AnnotationsQueryCtrl?: any;
    VariableQueryEditor?: any;
    QueryEditor?: ComponentType<QueryEditorProps<DSType, TQuery, TOptions>>;
    /** @deprecated it will be removed in a future release and `QueryEditor` will be used instead. */
    ExploreQueryField?: ComponentType<QueryEditorProps<DSType, TQuery, TOptions>>;
    /** @deprecated it will be removed in a future release and `QueryEditor` will be used instead. */
    ExploreMetricsQueryField?: ComponentType<QueryEditorProps<DSType, TQuery, TOptions>>;
    /** @deprecated it will be removed in a future release and `QueryEditor` will be used instead. */
    ExploreLogsQueryField?: ComponentType<QueryEditorProps<DSType, TQuery, TOptions>>;
    QueryEditorHelp?: ComponentType<QueryEditorHelpProps<TQuery>>;
    ConfigEditor?: ComponentType<DataSourcePluginOptionsEditorProps<TOptions, TSecureOptions>>;
    MetadataInspector?: ComponentType<MetadataInspectorProps<DSType, TQuery, TOptions>>;
}
interface DataSourceConstructor<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> {
    new (instanceSettings: DataSourceInstanceSettings<TOptions>, ...args: any[]): DSType;
}
declare type VariableSupport<TQuery extends DataQuery, TOptions extends DataSourceJsonData> = StandardVariableSupport<DataSourceApi<TQuery, TOptions>> | CustomVariableSupport<DataSourceApi<TQuery, TOptions>> | DataSourceVariableSupport<DataSourceApi<TQuery, TOptions>>;
/**
 * The main data source abstraction interface, represents an instance of a data source
 *
 * Although this is a class, datasource implementations do not *yet* need to extend it.
 * As such, we can not yet add functions with default implementations.
 */
declare abstract class DataSourceApi<TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData, TQueryImportConfiguration extends Record<string, object> = {}> {
    /**
     *  Set in constructor
     */
    readonly name: string;
    /**
     *  Set in constructor
     */
    readonly id: number;
    /**
     *  Set in constructor
     */
    readonly type: string;
    /**
     *  Set in constructor
     */
    readonly uid: string;
    /**
     *  min interval range
     */
    interval?: string;
    constructor(instanceSettings: DataSourceInstanceSettings<TOptions>);
    /**
     * @deprecated use DataSourceWithQueryImportSupport and DataSourceWithQueryExportSupport
     */
    importQueries?(queries: DataQuery[], originDataSource: DataSourceApi<DataQuery>): Promise<TQuery[]>;
    /**
     * Returns configuration for importing queries from other data sources
     */
    getImportQueryConfiguration?(): TQueryImportConfiguration;
    /**
     * Initializes a datasource after instantiation
     */
    init?: () => void;
    /**
     * Query for data, and optionally stream results
     */
    abstract query(request: DataQueryRequest<TQuery>): Promise<DataQueryResponse> | Observable<DataQueryResponse>;
    /**
     * Test & verify datasource settings & connection details (returning TestingStatus)
     *
     * When verification fails - errors specific to the data source should be handled here and converted to
     * a TestingStatus object. Unknown errors and HTTP errors can be re-thrown and will be handled here:
     * public/app/features/datasources/state/actions.ts
     */
    abstract testDatasource(): Promise<any>;
    /**
     * Override to skip executing a query
     *
     * @returns false if the query should be skipped
     *
     * @virtual
     */
    filterQuery?(query: TQuery): boolean;
    /**
     *  Get hints for query improvements
     */
    getQueryHints?(query: TQuery, results: any[], ...rest: any): QueryHint[];
    /**
     * Convert a query to a simple text string
     */
    getQueryDisplayText?(query: TQuery): string;
    /**
     * Variable query action.
     */
    metricFindQuery?(query: any, options?: any): Promise<MetricFindValue[]>;
    /**
     * Get tag keys for adhoc filters
     */
    getTagKeys?(options?: any): Promise<MetricFindValue[]>;
    /**
     * Get tag values for adhoc filters
     */
    getTagValues?(options: any): Promise<MetricFindValue[]>;
    /**
     * Set after constructor call, as the data source instance is the most common thing to pass around
     * we attach the components to this instance for easy access
     */
    components?: DataSourcePluginComponents<DataSourceApi<TQuery, TOptions>, TQuery, TOptions>;
    /**
     * static information about the datasource
     */
    meta: DataSourcePluginMeta;
    /**
     * Information about the datasource's query caching configuration
     * When the caching feature is disabled, this config will always be falsy
     */
    cachingConfig?: PluginQueryCachingConfig;
    /**
     * Used by alerting to check if query contains template variables
     */
    targetContainsTemplate?(query: TQuery): boolean;
    /**
     * Used in explore
     */
    modifyQuery?(query: TQuery, action: QueryFixAction): TQuery;
    /**
     * @deprecated since version 8.2.0
     * Not used anymore.
     */
    getHighlighterExpression?(query: TQuery): string[];
    /** Get an identifier object for this datasource instance */
    getRef(): DataSourceRef;
    /**
     * Used in explore
     */
    languageProvider?: any;
    getVersion?(optionalOptions?: any): Promise<string>;
    interpolateVariablesInQueries?(queries: TQuery[], scopedVars: ScopedVars | {}): TQuery[];
    /**
     * An annotation processor allows explicit control for how annotations are managed.
     *
     * It is only necessary to configure an annotation processor if the default behavior is not desirable
     */
    annotations?: AnnotationSupport<TQuery>;
    /**
     * Can be optionally implemented to allow datasource to be a source of annotations for dashboard.
     * This function will only be called if an angular {@link AnnotationsQueryCtrl} is configured and
     * the {@link annotations} is undefined
     *
     * @deprecated -- prefer using {@link AnnotationSupport}
     */
    annotationQuery?(options: AnnotationQueryRequest<TQuery>): Promise<AnnotationEvent[]>;
    /**
     * Defines new variable support
     * @alpha -- experimental
     */
    variables?: VariableSupport<TQuery, TOptions>;
    getDefaultQuery?(app: CoreApp): Partial<TQuery>;
}
interface MetadataInspectorProps<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> {
    datasource: DSType;
    data: DataFrame[];
}
interface QueryEditorProps<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData, TVQuery extends DataQuery = TQuery> {
    datasource: DSType;
    query: TVQuery;
    onRunQuery: () => void;
    onChange: (value: TVQuery) => void;
    onBlur?: () => void;
    onAddQuery?: (query: TQuery) => void;
    /**
     * Contains query response filtered by refId of QueryResultBase and possible query error
     */
    data?: PanelData;
    range?: TimeRange;
    exploreId?: any;
    history?: Array<HistoryItem<TQuery>>;
    queries?: DataQuery[];
    app?: CoreApp;
}
declare enum ExploreMode {
    Logs = "Logs",
    Metrics = "Metrics",
    Tracing = "Tracing"
}
/**
 * @deprecated use QueryEditorProps instead
 */
declare type ExploreQueryFieldProps<DSType extends DataSourceApi<TQuery, TOptions>, TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> = QueryEditorProps<DSType, TQuery, TOptions>;
interface QueryEditorHelpProps<TQuery extends DataQuery = DataQuery> {
    datasource: DataSourceApi<TQuery>;
    query: TQuery;
    onClickExample: (query: TQuery) => void;
    exploreId?: any;
}
/**
 * Starting in v6.2 DataFrame can represent both TimeSeries and TableData
 */
declare type LegacyResponseData = TimeSeries | TableData | any;
declare type DataQueryResponseData = DataFrame | DataFrameDTO | LegacyResponseData;
interface DataQueryResponse {
    /**
     * The response data.  When streaming, this may be empty
     * or a partial result set
     */
    data: DataQueryResponseData[];
    /**
     * When returning multiple partial responses or streams
     * Use this key to inform Grafana how to combine the partial responses
     * Multiple responses with same key are replaced (latest used)
     */
    key?: string;
    /**
     * Optionally include error info along with the response data
     * @deprecated use errors instead -- will be removed in Grafana 10+
     */
    error?: DataQueryError;
    /**
     * Optionally include multiple errors for different targets
     */
    errors?: DataQueryError[];
    /**
     * Use this to control which state the response should have
     * Defaults to LoadingState.Done if state is not defined
     */
    state?: LoadingState;
}
declare enum DataQueryErrorType {
    Cancelled = "cancelled",
    Timeout = "timeout",
    Unknown = "unknown"
}
interface DataQueryError {
    data?: {
        /**
         * Short information about the error
         */
        message?: string;
        /**
         * Detailed information about the error. Only returned when app_mode is development.
         */
        error?: string;
    };
    message?: string;
    status?: number;
    statusText?: string;
    refId?: string;
    type?: DataQueryErrorType;
}
interface DataQueryRequest<TQuery extends DataQuery = DataQuery> {
    requestId: string;
    interval: string;
    intervalMs: number;
    maxDataPoints?: number;
    range: TimeRange;
    scopedVars: ScopedVars;
    targets: TQuery[];
    timezone: string;
    app: CoreApp | string;
    cacheTimeout?: string | null;
    queryCachingTTL?: number | null;
    rangeRaw?: RawTimeRange;
    timeInfo?: string;
    panelId?: number;
    /** @deprecate */
    dashboardId?: number;
    dashboardUID?: string;
    publicDashboardAccessToken?: string;
    startTime: number;
    endTime?: number;
    liveStreaming?: boolean;
    hideFromInspector?: boolean;
    queryGroupId?: string;
}
interface DataQueryTimings {
    dataProcessingTime: number;
}
interface QueryFix {
    title?: string;
    label: string;
    action?: QueryFixAction;
}
interface QueryFixAction {
    type: string;
    query?: string;
    preventSubmit?: boolean;
    options?: KeyValue<string>;
}
interface QueryHint {
    type: string;
    label: string;
    fix?: QueryFix;
}
interface MetricFindValue {
    text: string;
    value?: string | number;
    expandable?: boolean;
}
interface DataSourceJsonData {
    authType?: string;
    defaultRegion?: string;
    profile?: string;
    manageAlerts?: boolean;
    alertmanagerUid?: string;
}
/**
 * Data Source instance edit model.  This is returned from:
 *  /api/datasources
 */
interface DataSourceSettings<T extends DataSourceJsonData = DataSourceJsonData, S = {}> extends WithAccessControlMetadata {
    id: number;
    uid: string;
    orgId: number;
    name: string;
    typeLogoUrl: string;
    type: string;
    typeName: string;
    access: string;
    url: string;
    user: string;
    /**
     *  @deprecated -- use jsonData to store information related to database.
     *  This field should only be used by Elasticsearch and Influxdb.
     */
    database: string;
    basicAuth: boolean;
    basicAuthUser: string;
    isDefault: boolean;
    jsonData: T;
    secureJsonData?: S;
    secureJsonFields: KeyValue<boolean>;
    readOnly: boolean;
    withCredentials: boolean;
    version?: number;
}
/**
 * Frontend settings model that is passed to Datasource constructor. This differs a bit from the model above
 * as this data model is available to every user who has access to a data source (Viewers+).  This is loaded
 * in bootData (on page load), or from: /api/frontend/settings
 */
interface DataSourceInstanceSettings<T extends DataSourceJsonData = DataSourceJsonData> {
    id: number;
    uid: string;
    type: string;
    name: string;
    meta: DataSourcePluginMeta;
    cachingConfig?: PluginQueryCachingConfig;
    readOnly: boolean;
    url?: string;
    jsonData: T;
    username?: string;
    password?: string;
    /**
     *  @deprecated -- use jsonData to store information related to database.
     *  This field should only be used by Elasticsearch and Influxdb.
     */
    database?: string;
    isDefault?: boolean;
    access: 'direct' | 'proxy';
    /**
     * This is the full Authorization header if basic auth is enabled.
     * Only available here when access is Browser (direct), when access is Server (proxy)
     * The basic auth header, username & password is never exposed to browser/Frontend
     * so this will be empty then.
     */
    basicAuth?: string;
    withCredentials?: boolean;
    /** When the name+uid are based on template variables, maintain access to the real values */
    rawRef?: DataSourceRef;
}
/**
 * @deprecated -- use {@link DataSourceInstanceSettings} instead
 */
interface DataSourceSelectItem {
    name: string;
    value: string | null;
    meta: DataSourcePluginMeta;
}
/**
 * Options passed to the datasource.annotationQuery method. See docs/plugins/developing/datasource.md
 *
 * @deprecated -- use {@link AnnotationSupport}
 */
interface AnnotationQueryRequest<MoreOptions = {}> {
    range: TimeRange;
    rangeRaw: RawTimeRange;
    dashboard: any;
    annotation: AnnotationQuery;
}
interface HistoryItem<TQuery extends DataQuery = DataQuery> {
    ts: number;
    query: TQuery;
}
declare abstract class LanguageProvider {
    abstract datasource: DataSourceApi<any, any>;
    abstract request: (url: string, params?: any) => Promise<any>;
    /**
     * Returns startTask that resolves with a task list when main syntax is loaded.
     * Task list consists of secondary promises that load more detailed language features.
     */
    abstract start: () => Promise<Array<Promise<any>>>;
    startTask?: Promise<any[]>;
}

/**
 * Context passed to transformDataFrame and to each transform operator
 */
interface DataTransformContext {
    interpolate: InterpolateFunction;
}
/**
 * Function that transform data frames (AKA transformer)
 *
 * @public
 */
interface DataTransformerInfo<TOptions = any> extends RegistryItemWithOptions {
    /**
     * Function that configures transformation and returns a transformer
     * @param options
     */
    operator: (options: TOptions, context: DataTransformContext) => MonoTypeOperatorFunction<DataFrame[]>;
}
/**
 * Function that returns a cutsom transform operator for transforming data frames
 *
 * @public
 */
declare type CustomTransformOperator = (context: DataTransformContext) => MonoTypeOperatorFunction<DataFrame[]>;
/**
 * Many transformations can be called with a simple synchronous function.
 * When a transformer is defined, it should have identical behavior to using the operator
 *
 * @public
 */
interface SynchronousDataTransformerInfo<TOptions = any> extends DataTransformerInfo<TOptions> {
    transformer: (options: TOptions, context: DataTransformContext) => (frames: DataFrame[]) => DataFrame[];
}

declare type FrameMatcher = (frame: DataFrame) => boolean;
declare type FieldMatcher = (field: Field, frame: DataFrame, allFrames: DataFrame[]) => boolean;
/**
 * Value matcher type to describe the matcher function
 * @public
 */
declare type ValueMatcher = (valueIndex: number, field: Field, frame: DataFrame, allFrames: DataFrame[]) => boolean;
interface FieldMatcherInfo<TOptions = any> extends RegistryItemWithOptions<TOptions> {
    get: (options: TOptions) => FieldMatcher;
}
interface FrameMatcherInfo<TOptions = any> extends RegistryItemWithOptions<TOptions> {
    get: (options: TOptions) => FrameMatcher;
}
/**
 * Registry item to represent all the different valu matchers supported
 * in the Grafana platform.
 * @public
 */
interface ValueMatcherInfo<TOptions = any> extends RegistryItemWithOptions<TOptions> {
    get: (options: TOptions) => ValueMatcher;
    isApplicable: (field: Field) => boolean;
    getDefaultOptions: (field: Field) => TOptions;
}
/**
 * @public
 */
declare enum SpecialValue {
    True = "true",
    False = "false",
    Null = "null",
    Empty = "empty"
}

declare type InterpolateFunction = (value: string, scopedVars?: ScopedVars, format?: string | Function) => string;
interface PanelPluginMeta extends PluginMeta {
    /** Indicates that panel does not issue queries */
    skipDataQuery?: boolean;
    /** Indicates that panel should not be available in visualisation picker */
    hideFromList?: boolean;
    /** Sort order */
    sort: number;
}
interface PanelData {
    /** State of the data (loading, done, error, streaming) */
    state: LoadingState;
    /** Contains data frames with field overrides applied */
    series: DataFrame[];
    /**
     * This is a key that will change when the DataFrame[] structure changes.
     * The revision is a useful way to know if only data has changed or data+structure
     */
    structureRev?: number;
    /** A list of annotation items */
    annotations?: DataFrame[];
    /**
     * @internal
     */
    alertState?: AlertStateInfo;
    /** Request contains the queries and properties sent to the datasource */
    request?: DataQueryRequest;
    /** Timing measurements */
    timings?: DataQueryTimings;
    /** Any query errors */
    errors?: DataQueryError[];
    /**
     * Single error for legacy reasons
     * @deprecated use errors instead -- will be removed in Grafana 10+
     */
    error?: DataQueryError;
    /** Contains the range from the request or a shifted time range if a request uses relative time */
    timeRange: TimeRange;
}
interface PanelProps<T = any> {
    /** ID of the panel within the current dashboard */
    id: number;
    /** Result set of panel queries */
    data: PanelData;
    /** Time range of the current dashboard */
    timeRange: TimeRange;
    /** Time zone of the current dashboard */
    timeZone: TimeZone;
    /** Panel options */
    options: T;
    /** Indicates whether or not panel should be rendered transparent */
    transparent: boolean;
    /** Current width of the panel */
    width: number;
    /** Current height of the panel */
    height: number;
    /** Field options configuration */
    fieldConfig: FieldConfigSource;
    /** @internal */
    renderCounter: number;
    /** Panel title */
    title: string;
    /** EventBus  */
    eventBus: EventBus;
    /** Panel options change handler */
    onOptionsChange: (options: T) => void;
    /** Field config change handler */
    onFieldConfigChange: (config: FieldConfigSource) => void;
    /** Template variables interpolation function */
    replaceVariables: InterpolateFunction;
    /** Time range change handler */
    onChangeTimeRange: (timeRange: AbsoluteTimeRange) => void;
}
interface PanelEditorProps<T = any> {
    /** Panel options */
    options: T;
    /** Panel options change handler */
    onOptionsChange: (options: T, callback?: () => void) => void;
    /** Result set of panel queries */
    data?: PanelData;
}
/**
 * Called when a panel is first loaded with current panel model
 */
declare type PanelMigrationHandler<TOptions = any> = (panel: PanelModel<TOptions>) => Partial<TOptions>;
/**
 * Called before a panel is initialized. Allows panel inspection for any updates before changing the panel type.
 */
declare type PanelTypeChangedHandler<TOptions = any> = (panel: PanelModel<TOptions>, prevPluginId: string, prevOptions: Record<string, any>, prevFieldConfig: FieldConfigSource) => Partial<TOptions>;
declare type PanelOptionEditorsRegistry = Registry<PanelOptionsEditorItem>;
interface PanelOptionsEditorProps<TValue> extends StandardEditorProps<TValue> {
}
interface PanelOptionsEditorItem<TOptions = any, TValue = any, TSettings = any> extends OptionsEditorItem<TOptions, TSettings, PanelOptionsEditorProps<TValue>, TValue> {
}
interface PanelOptionsEditorConfig<TOptions, TSettings = any, TValue = any> extends OptionEditorConfig<TOptions, TSettings, TValue> {
}
/**
 * @internal
 */
interface PanelMenuItem {
    type?: 'submenu' | 'divider';
    text: string;
    iconClassName?: IconName;
    onClick?: (event: React.MouseEvent<any>) => void;
    shortcut?: string;
    href?: string;
    subMenu?: PanelMenuItem[];
}
/**
 * @internal
 */
interface AngularPanelMenuItem {
    click: Function;
    icon: string;
    href: string;
    divider: boolean;
    text: string;
    shortcut: string;
    submenu: any[];
}
declare enum VizOrientation {
    Auto = "auto",
    Vertical = "vertical",
    Horizontal = "horizontal"
}
interface PanelPluginDataSupport {
    annotations: boolean;
    alertStates: boolean;
}
/**
 * @alpha
 */
interface VisualizationSuggestion<TOptions = any, TFieldConfig = any> {
    /** Name of suggestion */
    name: string;
    /** Description */
    description?: string;
    /** Panel plugin id */
    pluginId: string;
    /** Panel plugin options */
    options?: Partial<TOptions>;
    /** Panel plugin field options */
    fieldConfig?: FieldConfigSource<Partial<TFieldConfig>>;
    /** Data transformations */
    transformations?: DataTransformerConfig[];
    /** Options for how to render suggestion card */
    cardOptions?: {
        /** Tweak for small preview */
        previewModifier?: (suggestion: VisualizationSuggestion) => void;
        icon?: string;
        imgSrc?: string;
    };
    /** A value between 0-100 how suitable suggestion is */
    score?: VisualizationSuggestionScore;
}
/**
 * @alpha
 */
declare enum VisualizationSuggestionScore {
    /** We are pretty sure this is the best possible option */
    Best = 100,
    /** Should be a really good option */
    Good = 70,
    /** Can be visualized but there are likely better options. If no score is set this score is assumed */
    OK = 50
}
/**
 * @alpha
 */
interface PanelDataSummary {
    hasData?: boolean;
    rowCountTotal: number;
    rowCountMax: number;
    frameCount: number;
    fieldCount: number;
    numberFieldCount: number;
    timeFieldCount: number;
    stringFieldCount: number;
    hasNumberField?: boolean;
    hasTimeField?: boolean;
    hasStringField?: boolean;
    /** The first frame that set's this value */
    preferredVisualisationType?: PreferredVisualisationType;
}
/**
 * @alpha
 */
declare class VisualizationSuggestionsBuilder {
    /** Current data */
    data?: PanelData;
    /** Current panel & options */
    panel?: PanelModel;
    /** Summary stats for current data */
    dataSummary: PanelDataSummary;
    private list;
    constructor(data?: PanelData, panel?: PanelModel);
    getListAppender<TOptions, TFieldConfig>(defaults: VisualizationSuggestion<TOptions, TFieldConfig>): VisualizationSuggestionsListAppender<TOptions, TFieldConfig>;
    private computeDataSummary;
    getList(): VisualizationSuggestion<any, any>[];
}
/**
 * @alpha
 */
declare type VisualizationSuggestionsSupplier = {
    /**
     * Adds good suitable suggestions for the current data
     */
    getSuggestionsForData: (builder: VisualizationSuggestionsBuilder) => void;
};
/**
 * Helps with typings and defaults
 * @alpha
 */
declare class VisualizationSuggestionsListAppender<TOptions, TFieldConfig> {
    private list;
    private defaults;
    constructor(list: VisualizationSuggestion[], defaults: VisualizationSuggestion<TOptions, TFieldConfig>);
    append(overrides: Partial<VisualizationSuggestion<TOptions, TFieldConfig>>): void;
}

/**
 * Callback info for DataLink click events
 */
interface DataLinkClickEvent<T = any> {
    origin: T;
    replaceVariables: InterpolateFunction | undefined;
    e?: any;
}
/**
 * Data Links can be created by data source plugins or correlations.
 * Origin is set in DataLink object and indicates where the link was created.
 */
declare enum DataLinkConfigOrigin {
    Datasource = "Datasource",
    Correlations = "Correlations"
}
/**
 * Link configuration. The values may contain variables that need to be
 * processed before showing the link to user.
 *
 * TODO: <T extends DataQuery> is not strictly true for internal links as we do not need refId for example but all
 *  data source defined queries extend this so this is more for documentation.
 */
interface DataLink<T extends DataQuery = any> {
    title: string;
    targetBlank?: boolean;
    url: string;
    onBuildUrl?: (event: DataLinkClickEvent) => string;
    onClick?: (event: DataLinkClickEvent) => void;
    internal?: InternalDataLink<T>;
    origin?: DataLinkConfigOrigin;
}
/** @internal */
declare enum SupportedTransformationTypes {
    Regex = "regex",
    Logfmt = "logfmt"
}
/** @internal */
interface DataLinkTransformationConfig {
    type: SupportedTransformationTypes;
    field?: string;
    expression?: string;
    mapValue?: string;
}
/** @internal */
interface InternalDataLink<T extends DataQuery = any> {
    query: T;
    datasourceUid: string;
    datasourceName: string;
    panelsState?: ExplorePanelsState;
    transformations?: DataLinkTransformationConfig[];
    range?: TimeRange;
}
declare type LinkTarget = '_blank' | '_self' | undefined;
/**
 * Processed Link Model. The values are ready to use
 */
interface LinkModel<T = any> {
    href: string;
    title: string;
    target: LinkTarget;
    origin: T;
    onClick?: (e: any, origin?: any) => void;
}
/**
 * Provides a way to produce links on demand
 *
 * TODO: ScopedVars in in GrafanaUI package!
 */
interface LinkModelSupplier<T extends object> {
    getLinks(replaceVariables?: InterpolateFunction): Array<LinkModel<T>>;
}
declare enum VariableOrigin {
    Series = "series",
    Field = "field",
    Fields = "fields",
    Value = "value",
    BuiltIn = "built-in",
    Template = "template"
}
interface VariableSuggestion {
    value: string;
    label: string;
    documentation?: string;
    origin: VariableOrigin;
}
declare enum VariableSuggestionsScope {
    Values = "values"
}

/**
 * @public
 */
declare enum FieldColorModeId {
    Thresholds = "thresholds",
    PaletteClassic = "palette-classic",
    PaletteSaturated = "palette-saturated",
    ContinuousGrYlRd = "continuous-GrYlRd",
    ContinuousRdYlGr = "continuous-RdYlGr",
    ContinuousBlYlRd = "continuous-BlYlRd",
    ContinuousYlRd = "continuous-YlRd",
    ContinuousBlPu = "continuous-BlPu",
    ContinuousYlBl = "continuous-YlBl",
    ContinuousBlues = "continuous-blues",
    ContinuousReds = "continuous-reds",
    ContinuousGreens = "continuous-greens",
    ContinuousPurples = "continuous-purples",
    Fixed = "fixed"
}
/**
 * @public
 */
interface FieldColor {
    /** The main color scheme mode */
    mode: FieldColorModeId | string;
    /** Stores the fixed color value if mode is fixed */
    fixedColor?: string;
    /** Some visualizations need to know how to assign a series color from by value color schemes */
    seriesBy?: FieldColorSeriesByMode;
}
/**
 * @beta
 */
declare type FieldColorSeriesByMode = 'min' | 'max' | 'last';
declare const FALLBACK_COLOR = "#808080";

interface Threshold {
    value: number;
    color: string;
    /**
     *  Warning, Error, LowLow, Low, OK, High, HighHigh etc
     */
    state?: string;
}
/**
 *  Display mode
 */
declare enum ThresholdsMode {
    Absolute = "absolute",
    /**
     *  between 0 and 1 (based on min/max)
     */
    Percentage = "percentage"
}
/**
 *  Config that is passed to the ThresholdsEditor
 */
interface ThresholdsConfig {
    mode: ThresholdsMode;
    /**
     *  Must be sorted by 'value', first value is always -Infinity
     */
    steps: Threshold[];
}

/**
 * @alpha
 */
declare enum MappingType {
    ValueToText = "value",
    RangeToText = "range",
    RegexToText = "regex",
    SpecialValue = "special"
}
/**
 * @alpha
 */
interface ValueMappingResult {
    text?: string;
    color?: string;
    icon?: string;
    index?: number;
}
/**
 * @alpha
 */
interface BaseValueMap<T> {
    type: MappingType;
    options: T;
}
/**
 * @alpha
 */
interface ValueMap extends BaseValueMap<Record<string, ValueMappingResult>> {
    type: MappingType.ValueToText;
}
/**
 * @alpha
 */
interface RangeMapOptions {
    from: number | null;
    to: number | null;
    result: ValueMappingResult;
}
/**
 * @alpha
 */
interface RangeMap extends BaseValueMap<RangeMapOptions> {
    type: MappingType.RangeToText;
}
/**
 * @alpha
 */
interface RegexMapOptions {
    pattern: string;
    result: ValueMappingResult;
}
/**
 * @alpha
 */
interface RegexMap extends BaseValueMap<RegexMapOptions> {
    type: MappingType.RegexToText;
}
/**
 * @alpha
 */
interface SpecialValueOptions {
    match: SpecialValueMatch;
    result: ValueMappingResult;
}
/**
 * @alpha
 */
declare enum SpecialValueMatch {
    True = "true",
    False = "false",
    Null = "null",
    NaN = "nan",
    NullAndNaN = "null+nan",
    Empty = "empty"
}
/**
 * @alpha
 */
interface SpecialValueMap extends BaseValueMap<SpecialValueOptions> {
    type: MappingType.SpecialValue;
}
/**
 * @alpha
 */
declare type ValueMapping = ValueMap | RangeMap | RegexMap | SpecialValueMap;

interface Vector<T = any> {
    length: number;
    /**
     * Access the value by index (Like an array)
     */
    get(index: number): T;
    /**
     * Get the results as an array.
     */
    toArray(): T[];
}
/**
 * Apache arrow vectors are Read/Write
 */
interface ReadWriteVector<T = any> extends Vector<T> {
    set: (index: number, value: T) => void;
}
/**
 * Vector with standard manipulation functions
 */
interface MutableVector<T = any> extends ReadWriteVector<T> {
    /**
     * Adds the value to the vector
     */
    add: (value: T) => void;
    /**
     * modifies the vector so it is now the opposite order
     */
    reverse: () => void;
}

/** @public */
declare enum FieldType {
    time = "time",
    number = "number",
    string = "string",
    boolean = "boolean",
    trace = "trace",
    geo = "geo",
    enum = "enum",
    other = "other",
    frame = "frame"
}
/**
 * @public
 * Every property is optional
 *
 * Plugins may extend this with additional properties. Something like series overrides
 */
interface FieldConfig<TOptions = any> {
    /**
     * The display value for this field.  This supports template variables blank is auto
     */
    displayName?: string;
    /**
     * This can be used by data sources that return and explicit naming structure for values and labels
     * When this property is configured, this value is used rather than the default naming strategy.
     */
    displayNameFromDS?: string;
    /**
     * Human readable field metadata
     */
    description?: string;
    /**
     * An explict path to the field in the datasource.  When the frame meta includes a path,
     * This will default to `${frame.meta.path}/${field.name}
     *
     * When defined, this value can be used as an identifier within the datasource scope, and
     * may be used to update the results
     */
    path?: string;
    /**
     * True if data source can write a value to the path.  Auth/authz are supported separately
     */
    writeable?: boolean;
    /**
     * True if data source field supports ad-hoc filters
     */
    filterable?: boolean;
    unit?: string;
    decimals?: DecimalCount;
    min?: number | null;
    max?: number | null;
    interval?: number | null;
    mappings?: ValueMapping[];
    thresholds?: ThresholdsConfig;
    color?: FieldColor;
    nullValueMode?: NullValueMode;
    links?: DataLink[];
    noValue?: string;
    type?: FieldTypeConfig;
    custom?: TOptions;
}
interface FieldTypeConfig {
    enum?: EnumFieldConfig;
}
interface EnumFieldConfig {
    text?: string[];
    color?: string[];
    icon?: string[];
    description?: string[];
}
/** @public */
interface ValueLinkConfig {
    /**
     * Result of field reduction
     */
    calculatedValue?: DisplayValue;
    /**
     * Index of the value row within Field. Should be provided only when value is not a result of a reduction
     */
    valueRowIndex?: number;
}
interface Field<T = any, V = Vector<T>> {
    /**
     * Name of the field (column)
     */
    name: string;
    /**
     *  Field value type (string, number, etc)
     */
    type: FieldType;
    /**
     *  Meta info about how field and how to display it
     */
    config: FieldConfig;
    values: V;
    labels?: Labels;
    /**
     * Cached values with appropriate display and id values
     */
    state?: FieldState | null;
    /**
     * Convert a value for display
     */
    display?: DisplayProcessor;
    /**
     * Get value data links with variables interpolated
     */
    getLinks?: (config: ValueLinkConfig) => Array<LinkModel<Field>>;
}
/** @alpha */
interface FieldState {
    /**
     * An appropriate name for the field (does not include frame info)
     */
    displayName?: string | null;
    /**
     * Cache of reduced values
     */
    calcs?: FieldCalcs;
    /**
     * The numeric range for values in this field.  This value will respect the min/max
     * set in field config, or when set to `auto` this will have the min/max for all data
     * in the response
     */
    range?: NumericRange;
    /**
     * Appropriate values for templating
     */
    scopedVars?: ScopedVars;
    /**
     * Series index is index for this field in a larger data set that can span multiple DataFrames
     * Useful for assigning color to series by looking up a color in a palette using this index
     */
    seriesIndex?: number;
    /**
     * Location of this field within the context frames results
     *
     * @internal -- we will try to make this unnecessary
     */
    origin?: DataFrameFieldIndex;
    /**
     * Boolean value is true if field is in a larger data set with multiple frames.
     * This is only related to the cached displayName property above.
     */
    multipleFrames?: boolean;
    /**
     * Boolean value is true if a null filling threshold has been applied
     * against the frame of the field. This is used to avoid cases in which
     * this would applied more than one time.
     */
    nullThresholdApplied?: boolean;
    /**
     * Can be used by visualizations to cache max display value lengths to aid alignment.
     * It's up to each visualization to calculate and set this.
     */
    alignmentFactors?: DisplayValueAlignmentFactors;
}
/** @public */
interface NumericRange {
    min?: number | null;
    max?: number | null;
    delta: number;
}
interface DataFrame extends QueryResultBase {
    name?: string;
    fields: Field[];
    length: number;
}
/**
 * @public
 * Like a field, but properties are optional and values may be a simple array
 */
interface FieldDTO<T = any> {
    name: string;
    type?: FieldType;
    config?: FieldConfig;
    values?: Vector<T> | T[];
    labels?: Labels;
}
/**
 * @public
 * Like a DataFrame, but fields may be a FieldDTO
 */
interface DataFrameDTO extends QueryResultBase {
    name?: string;
    fields: Array<FieldDTO | Field>;
}
interface FieldCalcs extends Record<string, any> {
}
declare const TIME_SERIES_VALUE_FIELD_NAME = "Value";
declare const TIME_SERIES_TIME_FIELD_NAME = "Time";
declare const TIME_SERIES_METRIC_FIELD_NAME = "Metric";
/**
 * Describes where a specific data frame field is located within a
 * dataset of type DataFrame[]
 *
 * @internal -- we will try to make this unnecessary
 */
interface DataFrameFieldIndex {
    frameIndex: number;
    fieldIndex: number;
}

/**
 * See also:
 * https://github.com/grafana/grafana-plugin-sdk-go/blob/main/data/frame_type.go
 *
 * @public
 */
declare enum DataFrameType {
    TimeSeriesWide = "timeseries-wide",
    TimeSeriesLong = "timeseries-long",
    /** @deprecated in favor of TimeSeriesMulti */
    TimeSeriesMany = "timeseries-many",
    TimeSeriesMulti = "timeseries-multi",
    /** Directory listing */
    DirectoryListing = "directory-listing",
    /**
     * First field is X, the rest are ordinal values used as rows in the heatmap
     */
    HeatmapRows = "heatmap-rows",
    /**
     * Explicit fields for:
     *  xMin, yMin, count, ...
     *
     * All values in the grid exist and have regular spacing
     *
     * If the y value is actually ordinal, use `meta.custom` to specify the bucket lookup values
     */
    HeatmapCells = "heatmap-cells",
    /**
     * Explicit fields for:
     *  xMin, xMax, count
     */
    Histogram = "histogram"
}

declare type KeyValue<T = any> = Record<string, T>;
/**
 * Represent panel data loading state.
 * @public
 */
declare enum LoadingState {
    NotStarted = "NotStarted",
    Loading = "Loading",
    Streaming = "Streaming",
    Done = "Done",
    Error = "Error"
}
declare const preferredVisualizationTypes: readonly ["graph", "table", "logs", "trace", "nodeGraph", "flamegraph", "rawPrometheus"];
declare type PreferredVisualisationType = (typeof preferredVisualizationTypes)[number];
/**
 * @public
 */
interface QueryResultMeta {
    type?: DataFrameType;
    /**
     * TypeVersion is the version of the Type property. Versions greater than 0.0 correspond to the dataplane
     * contract documentation https://github.com/grafana/grafana-plugin-sdk-go/tree/main/data/contract_docs.
     */
    typeVersion?: [number, number];
    /** DatasSource Specific Values */
    custom?: Record<string, any>;
    /** Stats */
    stats?: QueryResultMetaStat[];
    /** Meta Notices */
    notices?: QueryResultMetaNotice[];
    /** Used to track transformation ids that where part of the processing */
    transformations?: string[];
    /** Currently used to show results in Explore only in preferred visualisation option */
    preferredVisualisationType?: PreferredVisualisationType;
    /** The path for live stream updates for this frame */
    channel?: string;
    /** Did the query response come from the cache */
    isCachedResponse?: boolean;
    /**
     * Optionally identify which topic the frame should be assigned to.
     * A value specified in the response will override what the request asked for.
     */
    dataTopic?: DataTopic;
    /**
     * This is the raw query sent to the underlying system.  All macros and templating
     * as been applied.  When metadata contains this value, it will be shown in the query inspector
     */
    executedQueryString?: string;
    /**
     * A browsable path on the datasource
     */
    path?: string;
    /**
     * defaults to '/'
     */
    pathSeparator?: string;
    /**
     * Legacy data source specific, should be moved to custom
     * */
    searchWords?: string[];
    limit?: number;
    json?: boolean;
    instant?: boolean;
}
interface QueryResultMetaStat extends FieldConfig {
    displayName: string;
    value: number;
}
/**
 * QueryResultMetaNotice is a structure that provides user notices for query result data
 * @public
 */
interface QueryResultMetaNotice {
    /**
     * Specify the notice severity
     */
    severity: 'info' | 'warning' | 'error';
    /**
     * Notice descriptive text
     */
    text: string;
    /**
     * An optional link that may be displayed in the UI.
     * This value may be an absolute URL or relative to grafana root
     */
    link?: string;
    /**
     * Optionally suggest an appropriate tab for the panel inspector
     */
    inspect?: 'meta' | 'error' | 'data' | 'stats';
}
/**
 * @public
 */
interface QueryResultBase {
    /**
     * Matches the query target refId
     */
    refId?: string;
    /**
     * Used by some backend data sources to communicate back info about the execution (generated sql, timing)
     */
    meta?: QueryResultMeta;
}
interface Labels {
    [key: string]: string;
}
interface Column {
    text: string;
    filterable?: boolean;
    unit?: string;
    custom?: Record<string, any>;
}
interface TableData extends QueryResultBase {
    name?: string;
    columns: Column[];
    rows: any[][];
    type?: string;
}
declare type TimeSeriesValue = number | null;
declare type TimeSeriesPoints = TimeSeriesValue[][];
interface TimeSeries extends QueryResultBase {
    target: string;
    /**
     * If name is manually configured via an alias / legend pattern
     */
    title?: string;
    datapoints: TimeSeriesPoints;
    unit?: string;
    tags?: Labels;
}
declare enum NullValueMode {
    Null = "null",
    Ignore = "connected",
    AsZero = "null as zero"
}
/**
 * Describes and API for exposing panel specific data configurations.
 */
interface DataConfigSource {
    configRev?: number;
    getDataSupport: () => PanelPluginDataSupport;
    getTransformations: () => DataTransformerConfig[] | undefined;
    getFieldOverrideOptions: () => ApplyFieldOverrideOptions | undefined;
    snapshotData?: DataFrameDTO[];
}
declare type Truthy<T> = T extends false | '' | 0 | null | undefined ? never : T;
declare const isTruthy: <T>(value: T) => value is Truthy<T>;

/**
 * Mapping of log level abbreviation to canonical log level.
 * Supported levels are reduce to limit color variation.
 */
declare enum LogLevel {
    emerg = "critical",
    fatal = "critical",
    alert = "critical",
    crit = "critical",
    critical = "critical",
    warn = "warning",
    warning = "warning",
    err = "error",
    eror = "error",
    error = "error",
    info = "info",
    information = "info",
    informational = "info",
    notice = "info",
    dbug = "debug",
    debug = "debug",
    trace = "trace",
    unknown = "unknown"
}
declare enum LogsMetaKind {
    Number = 0,
    String = 1,
    LabelsMap = 2,
    Error = 3
}
interface LogsMetaItem {
    label: string;
    value: string | number | Labels;
    kind: LogsMetaKind;
}
interface LogRowModel {
    entryFieldIndex: number;
    rowIndex: number;
    dataFrame: DataFrame;
    duplicates?: number;
    entry: string;
    hasAnsi: boolean;
    hasUnescapedContent: boolean;
    labels: Labels;
    logLevel: LogLevel;
    raw: string;
    searchWords?: string[];
    timeFromNow: string;
    timeEpochMs: number;
    timeEpochNs: string;
    timeLocal: string;
    timeUtc: string;
    uid: string;
    uniqueLabels?: Labels;
    datasourceType?: string;
}
interface LogsModel {
    hasUniqueLabels: boolean;
    meta?: LogsMetaItem[];
    rows: LogRowModel[];
    series?: DataFrame[];
    visibleRange?: AbsoluteTimeRange;
    queries?: DataQuery[];
    bucketSize?: number;
}
interface LogSearchMatch {
    start: number;
    length: number;
    text: string;
}
interface LogLabelStatsModel {
    active?: boolean;
    count: number;
    proportion: number;
    value: string;
}
/** @deprecated will be removed in the next major version */
interface LogsParser {
    /**
     * Value-agnostic matcher for a field label.
     * Used to filter rows, and first capture group contains the value.
     */
    buildMatcher: (label: string) => RegExp;
    /**
     * Returns all parsable substrings from a line, used for highlighting
     */
    getFields: (line: string) => string[];
    /**
     * Gets the label name from a parsable substring of a line
     */
    getLabelFromField: (field: string) => string;
    /**
     * Gets the label value from a parsable substring of a line
     */
    getValueFromField: (field: string) => string;
    /**
     * Function to verify if this is a valid parser for the given line.
     * The parser accepts the line if it returns true.
     */
    test: (line: string) => boolean;
}
declare enum LogsDedupDescription {
    none = "No de-duplication",
    exact = "De-duplication of successive lines that are identical, ignoring ISO datetimes.",
    numbers = "De-duplication of successive lines that are identical when ignoring numbers, e.g., IP addresses, latencies.",
    signature = "De-duplication of successive lines that have identical punctuation and whitespace."
}
/**
 * Data sources that allow showing context rows around the provided LowRowModel should implement this method.
 * This will enable "context" button in Logs Panel.
 */
interface DataSourceWithLogsContextSupport<TQuery extends DataQuery = DataQuery> {
    /**
     * Retrieve context for a given log row
     */
    getLogRowContext: <TContextQueryOptions extends {}>(row: LogRowModel, options?: TContextQueryOptions, query?: TQuery) => Promise<DataQueryResponse>;
    /**
     * This method can be used to show "context" button based on runtime conditions (for example row model data or plugin settings, etc.)
     */
    showContextToggle(row?: LogRowModel): boolean;
    /**
     * This method can be used to display a custom UI in the context view.
     * @alpha
     * @internal
     */
    getLogRowContextUi?(row: LogRowModel, runContextQuery?: () => void): React.ReactNode;
}
declare const hasLogsContextSupport: (datasource: unknown) => datasource is DataSourceWithLogsContextSupport<DataQuery>;
/**
 * Types of supplementary queries that can be run in Explore.
 * @internal
 */
declare enum SupplementaryQueryType {
    LogsVolume = "LogsVolume",
    LogsSample = "LogsSample"
}
/**
 * Types of logs volume responses. A data source may return full range histogram (based on selected range)
 * or limited (based on returned results). This information is attached to DataFrame.meta.custom object.
 * @internal
 */
declare enum LogsVolumeType {
    FullRange = "FullRange",
    Limited = "Limited"
}
/**
 * Custom meta information required by Logs Volume responses
 */
declare type LogsVolumeCustomMetaData = {
    absoluteRange: AbsoluteTimeRange;
    logsVolumeType: LogsVolumeType;
    datasourceName: string;
    sourceQuery: DataQuery;
};
declare const getLogsVolumeAbsoluteRange: (dataFrames: DataFrame[], defaultRange: AbsoluteTimeRange) => AbsoluteTimeRange;
declare const getLogsVolumeDataSourceInfo: (dataFrames: DataFrame[]) => {
    name: string;
} | null;
declare const isLogsVolumeLimited: (dataFrames: DataFrame[]) => boolean;
/**
 * Data sources that support supplementary queries in Explore.
 * This will enable users to see additional data when running original queries.
 * Supported supplementary queries are defined in SupplementaryQueryType enum.
 * @internal
 */
interface DataSourceWithSupplementaryQueriesSupport<TQuery extends DataQuery> {
    /**
     * Returns an observable that will be used to fetch supplementary data based on the provided
     * supplementary query type and original request.
     */
    getDataProvider(type: SupplementaryQueryType, request: DataQueryRequest<TQuery>): Observable<DataQueryResponse> | undefined;
    /**
     * Returns supplementary query types that data source supports.
     */
    getSupportedSupplementaryQueryTypes(): SupplementaryQueryType[];
    /**
     * Returns a supplementary query to be used to fetch supplementary data based on the provided type and original query.
     * If provided query is not suitable for provided supplementary query type, undefined should be returned.
     */
    getSupplementaryQuery(type: SupplementaryQueryType, query: TQuery): TQuery | undefined;
}
declare const hasSupplementaryQuerySupport: <TQuery extends DataQuery>(datasource: unknown, type: SupplementaryQueryType) => datasource is DataSourceWithSupplementaryQueriesSupport<TQuery>;
declare const hasLogsContextUiSupport: (datasource: unknown) => datasource is DataSourceWithLogsContextSupport<DataQuery>;

/**
 * Support for DataSourceWithLogsVolumeSupport is deprecated and will be removed in the next major version.
 * Use DataSourceWithSupplementaryQueriesSupport instead.
 *
 * @deprecated
 */
interface DataSourceWithLogsVolumeSupport<TQuery extends DataQuery> {
    getLogsVolumeDataProvider(request: DataQueryRequest<TQuery>): Observable<DataQueryResponse> | undefined;
}
/**
 * Support for hasLogsVolumeSupport is deprecated and will be removed in the next major version.
 * Use DataSourceWithSupplementaryQueriesSupport and hasSupplementaryQuerySupport instead.
 *
 * @deprecated
 */
declare const hasLogsVolumeSupport: <TQuery extends DataQuery>(datasource: unknown) => datasource is DataSourceWithLogsVolumeSupport<TQuery>;

/**
 * Used in select elements
 */
interface SelectableValue<T = any> {
    label?: string;
    ariaLabel?: string;
    value?: T;
    imgUrl?: string;
    icon?: string;
    description?: string;
    title?: string;
    component?: React.ComponentType<any>;
    [key: string]: any;
}

interface YAxis {
    index: number;
    min?: number;
    tickDecimals?: number;
}
declare type GraphSeriesValue = number | null;
/** View model projection of a series */
interface GraphSeriesXY {
    color?: string;
    data: GraphSeriesValue[][];
    isVisible: boolean;
    label: string;
    yAxis: YAxis;
    timeField: Field;
    valueField: Field;
    seriesIndex: number;
    timeStep: number;
    info?: DisplayValue[];
}
interface CreatePlotOverlay {
    (element: JQuery, event: any, plot: {
        getOptions: () => {
            events: {
                manager: any;
            };
        };
    }): any;
}

declare type VariableType = TypedVariableModel['type'];
/** @deprecated Use TypedVariableModel instead */
interface VariableModel {
    type: VariableType;
    name: string;
    label?: string;
}
declare type TypedVariableModel = QueryVariableModel | AdHocVariableModel | ConstantVariableModel | DataSourceVariableModel | IntervalVariableModel | TextBoxVariableModel | CustomVariableModel | UserVariableModel | OrgVariableModel | DashboardVariableModel;
declare enum VariableRefresh {
    never = 0,
    onDashboardLoad = 1,
    onTimeRangeChanged = 2
}
declare enum VariableSort {
    disabled = 0,
    alphabeticalAsc = 1,
    alphabeticalDesc = 2,
    numericalAsc = 3,
    numericalDesc = 4,
    alphabeticalCaseInsensitiveAsc = 5,
    alphabeticalCaseInsensitiveDesc = 6
}
declare enum VariableHide {
    dontHide = 0,
    hideLabel = 1,
    hideVariable = 2
}
interface AdHocVariableFilter {
    key: string;
    operator: string;
    value: string;
    condition: string;
}
interface AdHocVariableModel extends BaseVariableModel {
    type: 'adhoc';
    datasource: DataSourceRef | null;
    filters: AdHocVariableFilter[];
}
interface VariableOption {
    selected: boolean;
    text: string | string[];
    value: string | string[];
    isNone?: boolean;
}
interface IntervalVariableModel extends VariableWithOptions {
    type: 'interval';
    auto: boolean;
    auto_min: string;
    auto_count: number;
    refresh: VariableRefresh;
}
interface CustomVariableModel extends VariableWithMultiSupport {
    type: 'custom';
}
interface DataSourceVariableModel extends VariableWithMultiSupport {
    type: 'datasource';
    regex: string;
    refresh: VariableRefresh;
}
interface QueryVariableModel extends VariableWithMultiSupport {
    type: 'query';
    datasource: DataSourceRef | null;
    definition: string;
    sort: VariableSort;
    queryValue?: string;
    query: any;
    regex: string;
    refresh: VariableRefresh;
}
interface TextBoxVariableModel extends VariableWithOptions {
    type: 'textbox';
    originalQuery: string | null;
}
interface ConstantVariableModel extends VariableWithOptions {
    type: 'constant';
}
interface VariableWithMultiSupport extends VariableWithOptions {
    multi: boolean;
    includeAll: boolean;
    allValue?: string | null;
}
interface VariableWithOptions extends BaseVariableModel {
    current: VariableOption;
    options: VariableOption[];
    query: string;
}
interface DashboardProps {
    name: string;
    uid: string;
    toString: () => string;
}
interface DashboardVariableModel extends SystemVariable<DashboardProps> {
}
interface OrgProps {
    name: string;
    id: number;
    toString: () => string;
}
interface OrgVariableModel extends SystemVariable<OrgProps> {
}
interface UserProps {
    login: string;
    id: number;
    email?: string;
    toString: () => string;
}
interface UserVariableModel extends SystemVariable<UserProps> {
}
interface SystemVariable<TProps extends {
    toString: () => string;
}> extends BaseVariableModel {
    type: 'system';
    current: {
        value: TProps;
    };
}
interface BaseVariableModel {
    name: string;
    label?: string;
    id: string;
    type: VariableType;
    rootStateKey: string | null;
    global: boolean;
    hide: VariableHide;
    skipUrlSync: boolean;
    index: number;
    state: LoadingState;
    error: any | null;
    description: string | null;
}

interface UserOrgDTO {
    orgId: number;
    name: string;
    role: OrgRole;
}
declare enum OrgRole {
    Admin = "Admin",
    Editor = "Editor",
    Viewer = "Viewer"
}

interface FlotDataPoint {
    dataIndex: number;
    datapoint: number[];
    pageX: number;
    pageY: number;
    series: any;
    seriesIndex: number;
}

/**
 * Type representing a tag in a trace span or fields of a log.
 */
declare type TraceKeyValuePair<T = any> = {
    key: string;
    value: T;
};
/**
 * Type representing a log in a span.
 */
declare type TraceLog = {
    timestamp: number;
    fields: TraceKeyValuePair[];
};
declare type TraceSpanReference = {
    traceID: string;
    spanID: string;
    tags?: TraceKeyValuePair[];
};
/**
 * This describes the structure of the dataframe that should be returned from a tracing data source to show trace
 * in a TraceView component.
 */
interface TraceSpanRow {
    traceID: string;
    spanID: string;
    parentSpanID: string | undefined;
    operationName: string;
    serviceName: string;
    serviceTags: TraceKeyValuePair[];
    startTime: number;
    duration: number;
    logs?: TraceLog[];
    references?: TraceSpanReference[];
    tags?: TraceKeyValuePair[];
    warnings?: string[];
    stackTraces?: string[];
    errorIconColor?: string;
}

declare type AlertPayload = [string, string?, string?];
declare type AlertErrorPayload = [string, (string | Error)?, string?];
declare const AppEvents: {
    alertSuccess: AppEvent<AlertPayload>;
    alertWarning: AppEvent<AlertPayload>;
    alertError: AppEvent<AlertErrorPayload>;
};
declare const PanelEvents: {
    refresh: AppEvent<undefined>;
    componentDidMount: AppEvent<undefined>;
    dataReceived: AppEvent<any[]>;
    dataError: AppEvent<DataQueryError>;
    dataFramesReceived: AppEvent<DataFrame[]>;
    dataSnapshotLoad: AppEvent<any[]>;
    editModeInitialized: AppEvent<undefined>;
    initPanelActions: AppEvent<AngularPanelMenuItem[]>;
    initialized: AppEvent<undefined>;
    panelTeardown: AppEvent<undefined>;
    render: AppEvent<any>;
};
/** @public */
interface LegacyGraphHoverEventPayload extends DataHoverPayload {
    pos: any;
    panel: {
        id: number;
    };
}
/** @alpha */
declare class LegacyGraphHoverEvent extends BusEventWithPayload<LegacyGraphHoverEventPayload> {
    static type: string;
}
/** @alpha */
declare class LegacyGraphHoverClearEvent extends BusEventBase {
    static type: string;
    payload: DataHoverPayload;
}

/**
 * The channel id is defined as:
 *
 *   ${scope}/${namespace}/${path}
 *
 * The scope drives how the namespace is used and controlled
 *
 * @alpha
 */
declare enum LiveChannelScope {
    DataSource = "ds",
    Plugin = "plugin",
    Grafana = "grafana",
    Stream = "stream"
}
/**
 * The type of data to expect in a given channel
 *
 * @alpha
 */
declare enum LiveChannelType {
    DataStream = "stream",
    DataFrame = "frame",
    JSON = "json"
}
declare enum LiveChannelConnectionState {
    /** The connection is not yet established */
    Pending = "pending",
    /** Connected to the channel */
    Connected = "connected",
    /** Connecting to a channel */
    Connecting = "connecting",
    /** Disconnected from the channel.  The channel will reconnect when possible */
    Disconnected = "disconnected",
    /** Was at some point connected, and will not try to reconnect */
    Shutdown = "shutdown",
    /** Channel configuration was invalid and will not connect */
    Invalid = "invalid"
}
declare enum LiveChannelEventType {
    Status = "status",
    Join = "join",
    Leave = "leave",
    Message = "message"
}
/**
 * @alpha -- experimental
 */
interface LiveChannelStatusEvent {
    type: LiveChannelEventType.Status;
    /**
     * {scope}/{namespace}/{path}
     */
    id: string;
    /**
     * unix millies timestamp for the last status change
     */
    timestamp: number;
    /**
     * flag if the channel is actively connected to the channel.
     * This may be false while the connections get established or if the network is lost
     * As long as the `shutdown` flag is not set, the connection will try to reestablish
     */
    state: LiveChannelConnectionState;
    /**
     * When joining a channel, there may be an initial packet in the subscribe method
     */
    message?: any;
    /**
     * The last error.
     *
     * This will remain in the status until a new message is successfully received from the channel
     */
    error?: any;
}
interface LiveChannelJoinEvent {
    type: LiveChannelEventType.Join;
    user: any;
}
interface LiveChannelLeaveEvent {
    type: LiveChannelEventType.Leave;
    user: any;
}
interface LiveChannelMessageEvent<T> {
    type: LiveChannelEventType.Message;
    message: T;
}
declare type LiveChannelEvent<T = any> = LiveChannelStatusEvent | LiveChannelJoinEvent | LiveChannelLeaveEvent | LiveChannelMessageEvent<T>;
declare function isLiveChannelStatusEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelStatusEvent;
declare function isLiveChannelJoinEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelJoinEvent;
declare function isLiveChannelLeaveEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelLeaveEvent;
declare function isLiveChannelMessageEvent<T>(evt: LiveChannelEvent<T>): evt is LiveChannelMessageEvent<T>;
/**
 * @alpha -- experimental
 */
interface LiveChannelPresenceStatus {
    users: any;
}
/**
 * @alpha -- experimental
 */
declare type LiveChannelId = string;
/**
 * @alpha -- experimental
 */
interface LiveChannelAddress {
    scope: LiveChannelScope;
    namespace: string;
    path: string;
    /**
     * Additional metadata passed to a channel.  The backend will propagate this JSON object to
     * each OnSubscribe and RunStream calls.  This value should be constant across multiple requests
     * to the same channel path
     */
    data?: any;
}
/**
 * Return an address from a string
 *
 * @alpha -- experimental
 */
declare function parseLiveChannelAddress(id?: string): LiveChannelAddress | undefined;
/**
 * Check if the address has a scope, namespace, and path
 *
 * @alpha -- experimental
 */
declare function isValidLiveChannelAddress(addr?: LiveChannelAddress): addr is LiveChannelAddress;
/**
 * Convert the address to an explicit channel path
 *
 * @alpha -- experimental
 */
declare function toLiveChannelId(addr: LiveChannelAddress): LiveChannelId;

/**
 * A coordinate on a two dimensional plane.
 */
interface CartesianCoords2D {
    x: number;
    y: number;
}
/**
 * 2d object dimensions.
 */
interface Dimensions2D {
    width: number;
    height: number;
}

/**
 * Utility function to check if a plugin is unsigned.
 *
 * @param signature - the plugin meta signature
 * @internal
 */
declare function isUnsignedPluginSignature(signature?: PluginSignatureStatus): boolean | undefined;

/**
 * Determine if a string contains a relative date time.
 * @param text
 */
declare function isMathString(text: string | DateTime | Date): boolean;
/**
 * Parses different types input to a moment instance. There is a specific formatting language that can be used
 * if text arg is string. See unit tests for examples.
 * @param text
 * @param roundUp See parseDateMath function.
 * @param timezone Only string 'utc' is acceptable here, for anything else, local timezone is used.
 */
declare function parse(text?: string | DateTime | Date | null, roundUp?: boolean, timezone?: TimeZone, fiscalYearStartMonth?: number): DateTime | undefined;
/**
 * Checks if text is a valid date which in this context means that it is either a Moment instance or it can be parsed
 * by parse function. See parse function to see what is considered acceptable.
 * @param text
 */
declare function isValid(text: string | DateTime): boolean;
/**
 * Parses math part of the time string and shifts supplied time according to that math. See unit tests for examples.
 * @param mathString
 * @param time
 * @param roundUp If true it will round the time to endOf time unit, otherwise to startOf time unit.
 */
declare function parseDateMath(mathString: string, time: any, roundUp?: boolean, fiscalYearStartMonth?: number): DateTime | undefined;
declare function roundToFiscal(fyStartMonth: number, dateTime: any, unit: string, roundUp: boolean | undefined): any;

declare const datemath_d_isMathString: typeof isMathString;
declare const datemath_d_parse: typeof parse;
declare const datemath_d_isValid: typeof isValid;
declare const datemath_d_parseDateMath: typeof parseDateMath;
declare const datemath_d_roundToFiscal: typeof roundToFiscal;
declare namespace datemath_d {
  export {
    datemath_d_isMathString as isMathString,
    datemath_d_parse as parse,
    datemath_d_isValid as isValid,
    datemath_d_parseDateMath as parseDateMath,
    datemath_d_roundToFiscal as roundToFiscal,
  };
}

declare function describeTextRange(expr: string): any;
/**
 * Use this function to get a properly formatted string representation of a {@link @grafana/data:RawTimeRange | range}.
 *
 * @example
 * ```
 * // Prints "2":
 * console.log(add(1,1));
 * ```
 * @category TimeUtils
 * @param range - a time range (usually specified by the TimePicker)
 * @alpha
 */
declare function describeTimeRange(range: RawTimeRange, timeZone?: TimeZone): string;
declare const isValidTimeSpan: (value: string) => boolean;
declare const describeTimeRangeAbbreviation: (range: TimeRange, timeZone?: TimeZone) => string;
declare const convertRawToRange: (raw: RawTimeRange, timeZone?: TimeZone, fiscalYearStartMonth?: number) => TimeRange;
declare function isFiscal(timeRange: TimeRange): boolean;
declare function isRelativeTimeRange(raw: RawTimeRange): boolean;
declare function secondsToHms(seconds: number): string;
declare function msRangeToTimeString(rangeMs: number): string;
declare function calculateInterval(range: TimeRange, resolution: number, lowLimitInterval?: string): IntervalValues;
declare function describeInterval(str: string): {
    sec: number;
    type: string;
    count: number;
};
declare function intervalToSeconds(str: string): number;
declare function intervalToMs(str: string): number;
declare function roundInterval(interval: number): 1 | 100 | 10 | 1000 | 20 | 50 | 200 | 500 | 2000 | 5000 | 10000 | 15000 | 20000 | 30000 | 60000 | 120000 | 300000 | 600000 | 900000 | 1200000 | 1800000 | 3600000 | 7200000 | 10800000 | 21600000 | 43200000 | 86400000 | 604800000 | 2592000000 | 31536000000;
/**
 * Converts a TimeRange to a RelativeTimeRange that can be used in
 * e.g. alerting queries/rules.
 *
 * @internal
 */
declare function timeRangeToRelative(timeRange: TimeRange, now?: DateTime): RelativeTimeRange;
/**
 * Converts a RelativeTimeRange to a TimeRange
 *
 * @internal
 */
declare function relativeToTimeRange(relativeTimeRange: RelativeTimeRange, now?: DateTime): TimeRange;

declare const rangeutil_d_describeTextRange: typeof describeTextRange;
declare const rangeutil_d_describeTimeRange: typeof describeTimeRange;
declare const rangeutil_d_isValidTimeSpan: typeof isValidTimeSpan;
declare const rangeutil_d_describeTimeRangeAbbreviation: typeof describeTimeRangeAbbreviation;
declare const rangeutil_d_convertRawToRange: typeof convertRawToRange;
declare const rangeutil_d_isFiscal: typeof isFiscal;
declare const rangeutil_d_isRelativeTimeRange: typeof isRelativeTimeRange;
declare const rangeutil_d_secondsToHms: typeof secondsToHms;
declare const rangeutil_d_msRangeToTimeString: typeof msRangeToTimeString;
declare const rangeutil_d_calculateInterval: typeof calculateInterval;
declare const rangeutil_d_describeInterval: typeof describeInterval;
declare const rangeutil_d_intervalToSeconds: typeof intervalToSeconds;
declare const rangeutil_d_intervalToMs: typeof intervalToMs;
declare const rangeutil_d_roundInterval: typeof roundInterval;
declare const rangeutil_d_timeRangeToRelative: typeof timeRangeToRelative;
declare const rangeutil_d_relativeToTimeRange: typeof relativeToTimeRange;
declare namespace rangeutil_d {
  export {
    rangeutil_d_describeTextRange as describeTextRange,
    rangeutil_d_describeTimeRange as describeTimeRange,
    rangeutil_d_isValidTimeSpan as isValidTimeSpan,
    rangeutil_d_describeTimeRangeAbbreviation as describeTimeRangeAbbreviation,
    rangeutil_d_convertRawToRange as convertRawToRange,
    rangeutil_d_isFiscal as isFiscal,
    rangeutil_d_isRelativeTimeRange as isRelativeTimeRange,
    rangeutil_d_secondsToHms as secondsToHms,
    rangeutil_d_msRangeToTimeString as msRangeToTimeString,
    rangeutil_d_calculateInterval as calculateInterval,
    rangeutil_d_describeInterval as describeInterval,
    rangeutil_d_intervalToSeconds as intervalToSeconds,
    rangeutil_d_intervalToMs as intervalToMs,
    rangeutil_d_roundInterval as roundInterval,
    rangeutil_d_timeRangeToRelative as timeRangeToRelative,
    rangeutil_d_relativeToTimeRange as relativeToTimeRange,
  };
}

declare enum InternalTimeZones {
    default = "",
    localBrowserTime = "browser",
    utc = "utc"
}
declare const timeZoneFormatUserFriendly: (timeZone: TimeZone | undefined) => string | undefined;
interface TimeZoneCountry {
    code: string;
    name: string;
}
interface TimeZoneInfo {
    name: string;
    zone: string;
    countries: TimeZoneCountry[];
    abbreviation: string;
    offsetInMins: number;
    ianaName: string;
}
interface GroupedTimeZones {
    name: string;
    zones: TimeZone[];
}
declare const getTimeZoneInfo: (zone: string, timestamp: number) => TimeZoneInfo | undefined;
declare const getTimeZones: ((includeInternal?: boolean | InternalTimeZones[]) => TimeZone[]) & lodash.MemoizedFunction;
declare const getTimeZoneGroups: ((includeInternal?: boolean | InternalTimeZones[]) => GroupedTimeZones[]) & lodash.MemoizedFunction;

interface SystemDateFormatSettings {
    fullDate: string;
    interval: {
        millisecond: string;
        second: string;
        minute: string;
        hour: string;
        day: string;
        month: string;
        year: string;
    };
    useBrowserLocale: boolean;
}
declare class SystemDateFormatsState {
    fullDate: string;
    fullDateMS: string;
    interval: {
        millisecond: string;
        second: string;
        minute: string;
        hour: string;
        day: string;
        month: string;
        year: string;
    };
    update(settings: SystemDateFormatSettings): void;
    useBrowserLocale(): void;
    getTimeFieldUnit(useMsResolution?: boolean): string;
}
/**
 * localTimeFormat helps to generate date formats for momentjs based on browser's locale
 *
 * @param locale browser locale, or default
 * @param options DateTimeFormatOptions to format date
 * @param fallback default format if Intl API is not present
 */
declare function localTimeFormat(options: Intl.DateTimeFormatOptions, locale?: string | string[] | null, fallback?: string): string;
declare const systemDateFormats: SystemDateFormatsState;

/**
 * Used for helper functions handling time zones.
 *
 * @public
 */
interface TimeZoneOptions {
    /**
     * Specify this if you want to override the timeZone used when parsing or formatting
     * a date and time value. If no timeZone is set, the default timeZone for the current
     * user is used.
     */
    timeZone?: TimeZone;
}
/**
 * The type describing date and time options. Used for all the helper functions
 * available to parse or format date and time values.
 *
 * @public
 */
interface DateTimeOptions extends TimeZoneOptions {
    /**
     * Specify a {@link https://momentjs.com/docs/#/displaying/format | momentjs} format to
     * use a custom formatting pattern or parsing pattern. If no format is set,
     * then system configured default format is used.
     */
    format?: string;
}
/**
 * The type to describe the time zone resolver function that will be used to access
 * the default time zone of a user.
 *
 * @public
 */
declare type TimeZoneResolver = () => TimeZone | undefined;
/**
 * Used by Grafana internals to set the {@link TimeZoneResolver} to access the current
 * user timeZone.
 *
 * @internal
 */
declare const setTimeZoneResolver: (resolver: TimeZoneResolver) => void;
/**
 * Used to get the current selected time zone. If a valid time zone is passed in the
 * options it will be returned. If no valid time zone is passed either the time zone
 * configured for the user account will be returned or the default for Grafana.
 *
 * @public
 */
declare const getTimeZone: <T extends TimeZoneOptions>(options?: T | undefined) => TimeZone;

/**
 * The type describing the options that can be passed to the {@link dateTimeFormat}
 * helper function to control how the date and time value passed to the function is
 * formatted.
 *
 * @public
 */
interface DateTimeOptionsWithFormat extends DateTimeOptions {
    /**
     * Set this value to `true` if you want to include milliseconds when formatting date and time
     */
    defaultWithMS?: boolean;
}
declare type DateTimeFormatter<T extends DateTimeOptions = DateTimeOptions> = (dateInUtc: DateTimeInput, options?: T) => string;
/**
 * Helper function to format date and time according to the specified options. If no options
 * are supplied, then default values are used. For more details, see {@link DateTimeOptionsWithFormat}.
 *
 * @param dateInUtc - date in UTC format, e.g. string formatted with UTC offset, UNIX epoch in seconds etc.
 * @param options
 *
 * @public
 */
declare const dateTimeFormat: DateTimeFormatter<DateTimeOptionsWithFormat>;
/**
 * Helper function to format date and time according to the standard ISO format e.g. 2013-02-04T22:44:30.652Z.
 * If no options are supplied, then default values are used. For more details, see {@link DateTimeOptionsWithFormat}.
 *
 * @param dateInUtc - date in UTC format, e.g. string formatted with UTC offset, UNIX epoch in seconds etc.
 * @param options
 *
 * @public
 */
declare const dateTimeFormatISO: DateTimeFormatter;
/**
 * Helper function to return elapsed time since passed date. The returned value will be formatted
 * in a human readable format e.g. 4 years ago. If no options are supplied, then default values are used.
 * For more details, see {@link DateTimeOptions}.
 *
 * @param dateInUtc - date in UTC format, e.g. string formatted with UTC offset, UNIX epoch in seconds etc.
 * @param options
 *
 * @public
 */
declare const dateTimeFormatTimeAgo: DateTimeFormatter;
/**
 * Helper function to format date and time according to the Grafana default formatting, but it
 * also appends the time zone abbreviation at the end e.g. 2020-05-20 13:37:00 CET. If no options
 * are supplied, then default values are used. For more details please see {@link DateTimeOptions}.
 *
 * @param dateInUtc - date in UTC format, e.g. string formatted with UTC offset, UNIX epoch in seconds etc.
 * @param options
 *
 * @public
 */
declare const dateTimeFormatWithAbbrevation: DateTimeFormatter;
/**
 * Helper function to return only the time zone abbreviation for a given date and time value. If no options
 * are supplied, then default values are used. For more details please see {@link DateTimeOptions}.
 *
 * @param dateInUtc - date in UTC format, e.g. string formatted with UTC offset, UNIX epoch in seconds etc.
 * @param options
 *
 * @public
 */
declare const timeZoneAbbrevation: DateTimeFormatter;

/**
 * The type that describes options that can be passed when parsing a date and time value.
 * @public
 */
interface DateTimeOptionsWhenParsing extends DateTimeOptions {
    /**
     * If the input is a Grafana quick date, e.g. now-6h, then you can specify this to control
     * whether the last part of the date and time value is included or excluded.
     *
     * Example: now-6h and the current time is 12:20:00 if roundUp is set to true
     * the returned DateTime value will be 06:00:00.
     */
    roundUp?: boolean;
    fiscalYearStartMonth?: number;
}
declare type DateTimeParser<T extends DateTimeOptions = DateTimeOptions> = (value: DateTimeInput, options?: T) => DateTime;
/**
 * Helper function to parse a number, text or Date to a DateTime value. If a timeZone is supplied the incoming value
 * is parsed with that timeZone as a base. The only exception to this is if the passed value is in a UTC-based
 * format. Then it will use UTC as the base. If no format is specified the current system format will be assumed.
 *
 * It can also parse the Grafana quick date and time format, e.g. now-6h will be parsed as Date.now() - 6 hours and
 * returned as a valid DateTime value.
 *
 * If no options are supplied, then default values are used. For more details please see {@link DateTimeOptions}.
 *
 * @param value - should be a parsable date and time value
 * @param options
 *
 * @public
 */
declare const dateTimeParse: DateTimeParser<DateTimeOptionsWhenParsing>;

/**
 * intervalToAbbreviatedDurationString converts interval to readable duration string
 *
 * @param interval - interval to convert
 * @param includeSeconds - optional, default true. If false, will not include seconds unless interval is less than 1 minute
 *
 * @public
 */
declare function intervalToAbbreviatedDurationString(interval: Interval, includeSeconds?: boolean): string;
/**
 * parseDuration parses duration string into datefns Duration object
 *
 * @param durationString - string to convert. For example '2m', '5h 20s'
 *
 * @public
 */
declare function parseDuration(durationString: string): Duration;
/**
 * addDurationToDate adds given duration to given date and returns a new Date object
 *
 * @param date - date to add to. Can be either Date object or a number (milliseconds since epoch)
 * @param duration - duration to add. For example '2m', '5h 20s'
 *
 * @public
 */
declare function addDurationToDate(date: Date | number, duration: Duration): Date;
/**
 * durationToMilliseconds convert a duration object to milliseconds
 *
 * @param duration - datefns Duration object
 *
 * @public
 */
declare function durationToMilliseconds(duration: Duration): number;
/**
 * isValidDate returns true if given string can be parsed into valid Date object, false otherwise
 *
 * @param dateString - string representation of a date
 *
 * @public
 */
declare function isValidDate(dateString: string): boolean;
/**
 * isValidDuration returns true if the given string can be parsed into a valid Duration object, false otherwise
 *
 * @param durationString - string representation of a duration
 *
 * @public
 */
declare function isValidDuration(durationString: string): boolean;
/**
 * isValidGoDuration returns true if the given string can be parsed into a valid Duration object based on
 * Go's time.parseDuration, false otherwise.
 *
 * Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
 *
 * Go docs: https://pkg.go.dev/time#ParseDuration
 *
 * @param durationString - string representation of a duration
 *
 * @internal
 */
declare function isValidGoDuration(durationString: string): boolean;

/**
 * @alpha
 */
interface MapLayerHandler<TConfig = any> {
    init: () => BaseLayer;
    /**
     * The update function should only be implemented if the layer type makes use of query data
     */
    update?: (data: PanelData) => void;
    /** Optional callback for cleanup before getting removed */
    dispose?: () => void;
    /** return react node for the legend */
    legend?: ReactNode;
    /**
     * Show custom elements in the panel edit UI
     */
    registerOptionsUI?: (builder: PanelOptionsEditorBuilder<MapLayerOptions<TConfig>>) => void;
}
/**
 * Map layer configuration
 *
 * @alpha
 */
interface MapLayerRegistryItem<TConfig = MapLayerOptions> extends RegistryItemWithOptions {
    /**
     * This layer can be used as a background
     */
    isBaseMap?: boolean;
    /**
     * Show location controls
     */
    showLocation?: boolean;
    /**
     * Hide transparency controls in UI
     */
    hideOpacity?: boolean;
    /**
     * Function that configures transformation and returns a transformer
     * @param options
     */
    create: (map: Map, options: MapLayerOptions<TConfig>, eventBus: EventBus, theme: GrafanaTheme2) => Promise<MapLayerHandler>;
}

/**
 * Describes available feature toggles in Grafana. These can be configured via
 * conf/custom.ini to enable features under development or not yet available in
 * stable version.
 *
 * Only enabled values will be returned in this interface.
 *
 * NOTE: the possible values may change between versions without notice, although
 * this may cause compilation issues when depending on removed feature keys, the
 * runtime state will continue to work.
 *
 * @public
 */
interface FeatureToggles {
    trimDefaults?: boolean;
    disableEnvelopeEncryption?: boolean;
    database_metrics?: boolean;
    dashboardPreviews?: boolean;
    ['live-service-web-worker']?: boolean;
    queryOverLive?: boolean;
    panelTitleSearch?: boolean;
    prometheusAzureOverrideAudience?: boolean;
    publicDashboards?: boolean;
    publicDashboardsEmailSharing?: boolean;
    lokiLive?: boolean;
    lokiDataframeApi?: boolean;
    featureHighlights?: boolean;
    migrationLocking?: boolean;
    storage?: boolean;
    k8s?: boolean;
    exploreMixedDatasource?: boolean;
    newTraceView?: boolean;
    correlations?: boolean;
    cloudWatchDynamicLabels?: boolean;
    datasourceQueryMultiStatus?: boolean;
    traceToMetrics?: boolean;
    newDBLibrary?: boolean;
    validateDashboardsOnSave?: boolean;
    autoMigrateOldPanels?: boolean;
    disableAngular?: boolean;
    prometheusWideSeries?: boolean;
    canvasPanelNesting?: boolean;
    scenes?: boolean;
    disableSecretsCompatibility?: boolean;
    logRequestsInstrumentedAsUnknown?: boolean;
    dataConnectionsConsole?: boolean;
    internationalization?: boolean;
    topnav?: boolean;
    grpcServer?: boolean;
    entityStore?: boolean;
    cloudWatchCrossAccountQuerying?: boolean;
    redshiftAsyncQueryDataSupport?: boolean;
    athenaAsyncQueryDataSupport?: boolean;
    newPanelChromeUI?: boolean;
    showDashboardValidationWarnings?: boolean;
    mysqlAnsiQuotes?: boolean;
    accessControlOnCall?: boolean;
    nestedFolders?: boolean;
    accessTokenExpirationCheck?: boolean;
    elasticsearchBackendMigration?: boolean;
    emptyDashboardPage?: boolean;
    secureSocksDatasourceProxy?: boolean;
    authnService?: boolean;
    disablePrometheusExemplarSampling?: boolean;
    alertingBacktesting?: boolean;
    editPanelCSVDragAndDrop?: boolean;
    alertingNoNormalState?: boolean;
    logsSampleInExplore?: boolean;
    logsContextDatasourceUi?: boolean;
    lokiQuerySplitting?: boolean;
    lokiQuerySplittingConfig?: boolean;
    individualCookiePreferences?: boolean;
    onlyExternalOrgRoleSync?: boolean;
    drawerDataSourcePicker?: boolean;
    traceqlSearch?: boolean;
    prometheusMetricEncyclopedia?: boolean;
    timeSeriesTable?: boolean;
    prometheusResourceBrowserCache?: boolean;
    influxdbBackendMigration?: boolean;
    clientTokenRotation?: boolean;
    disableElasticsearchBackendExploreQuery?: boolean;
    prometheusDataplane?: boolean;
    alertStateHistoryLokiSecondary?: boolean;
    alertStateHistoryLokiPrimary?: boolean;
    alertStateHistoryLokiOnly?: boolean;
    unifiedRequestLog?: boolean;
    renderAuthJWT?: boolean;
}

/**
 * Describes the build information that will be available via the Grafana configuration.
 *
 * @public
 */
interface BuildInfo {
    version: string;
    commit: string;
    env: string;
    edition: GrafanaEdition;
    latestVersion: string;
    hasUpdate: boolean;
    hideVersion: boolean;
}
/**
 * @internal
 */
declare enum GrafanaEdition {
    OpenSource = "Open Source",
    Pro = "Pro",
    Enterprise = "Enterprise"
}
/**
 * Describes the license information about the current running instance of Grafana.
 *
 * @public
 */
interface LicenseInfo {
    expiry: number;
    licenseUrl: string;
    stateInfo: string;
    edition: GrafanaEdition;
    enabledFeatures: {
        [key: string]: boolean;
    };
    trialExpiry?: number;
}
/**
 * Describes Sentry integration config
 *
 * @public
 */
interface SentryConfig {
    enabled: boolean;
    dsn: string;
    customEndpoint: string;
    sampleRate: number;
}
/**
 * Describes GrafanaJavascriptAgentConfig integration config
 *
 * @public
 */
interface GrafanaJavascriptAgentConfig {
    enabled: boolean;
    customEndpoint: string;
    errorInstrumentalizationEnabled: boolean;
    consoleInstrumentalizationEnabled: boolean;
    webVitalsInstrumentalizationEnabled: boolean;
    apiKey: string;
}
interface UnifiedAlertingConfig {
    minInterval: string;
}
/** Supported OAuth services
 *
 * @public
 */
declare type OAuth = 'github' | 'gitlab' | 'google' | 'generic_oauth' | 'grafana_com' | 'azuread' | 'okta';
/** Map of enabled OAuth services and their respective names
 *
 * @public
 */
declare type OAuthSettings = Partial<Record<OAuth, {
    name: string;
    icon?: IconName;
}>>;
/**
 * Information needed for analytics providers
 *
 * @internal
 */
interface AnalyticsSettings {
    identifier: string;
    intercomIdentifier?: string;
}
/** Current user info included in bootData
 *
 * @internal
 */
interface CurrentUserDTO {
    isSignedIn: boolean;
    id: number;
    externalUserId: string;
    login: string;
    email: string;
    name: string;
    theme: string;
    orgCount: number;
    orgId: number;
    orgName: string;
    orgRole: OrgRole | '';
    isGrafanaAdmin: boolean;
    gravatarUrl: string;
    timezone: string;
    weekStart: string;
    locale: string;
    language: string;
    permissions?: Record<string, boolean>;
    analytics: AnalyticsSettings;
    /** @deprecated Use theme instead */
    lightTheme: boolean;
}
/** Contains essential user and config info
 *
 * @internal
 */
interface BootData {
    user: CurrentUserDTO;
    settings: GrafanaConfig;
    navTree: NavLinkDTO[];
    themePaths: {
        light: string;
        dark: string;
    };
}
/**
 * Describes all the different Grafana configuration values available for an instance.
 *
 * @internal
 */
interface GrafanaConfig {
    isPublicDashboardView: boolean;
    snapshotEnabled: boolean;
    datasources: {
        [str: string]: DataSourceInstanceSettings;
    };
    panels: {
        [key: string]: PanelPluginMeta;
    };
    auth: AuthSettings;
    minRefreshInterval: string;
    appSubUrl: string;
    windowTitlePrefix: string;
    buildInfo: BuildInfo;
    newPanelTitle: string;
    bootData: BootData;
    externalUserMngLinkUrl: string;
    externalUserMngLinkName: string;
    externalUserMngInfo: string;
    allowOrgCreate: boolean;
    disableLoginForm: boolean;
    defaultDatasource: string;
    alertingEnabled: boolean;
    alertingErrorOrTimeout: string;
    alertingNoDataOrNullValues: string;
    alertingMinInterval: number;
    authProxyEnabled: boolean;
    exploreEnabled: boolean;
    queryHistoryEnabled: boolean;
    helpEnabled: boolean;
    profileEnabled: boolean;
    ldapEnabled: boolean;
    sigV4AuthEnabled: boolean;
    azureAuthEnabled: boolean;
    samlEnabled: boolean;
    autoAssignOrg: boolean;
    verifyEmailEnabled: boolean;
    oauth: OAuthSettings;
    rbacEnabled: boolean;
    disableUserSignUp: boolean;
    loginHint: string;
    passwordHint: string;
    loginError?: string;
    viewersCanEdit: boolean;
    editorsCanAdmin: boolean;
    disableSanitizeHtml: boolean;
    liveEnabled: boolean;
    /** @deprecated Use `theme2` instead. */
    theme: GrafanaTheme;
    theme2: GrafanaTheme2;
    anonymousEnabled: boolean;
    featureToggles: FeatureToggles;
    licenseInfo: LicenseInfo;
    http2Enabled: boolean;
    dateFormats?: SystemDateFormatSettings;
    sentry: SentryConfig;
    grafanaJavascriptAgent: GrafanaJavascriptAgentConfig;
    customTheme?: any;
    geomapDefaultBaseLayer?: MapLayerOptions;
    geomapDisableCustomBaseLayer?: boolean;
    unifiedAlertingEnabled: boolean;
    unifiedAlerting: UnifiedAlertingConfig;
    angularSupportEnabled: boolean;
    feedbackLinksEnabled: boolean;
    secretsManagerPluginEnabled: boolean;
    supportBundlesEnabled: boolean;
    googleAnalyticsId: string | undefined;
    googleAnalytics4Id: string | undefined;
    googleAnalytics4SendManualPageViews: boolean;
    rudderstackWriteKey: string | undefined;
    rudderstackDataPlaneUrl: string | undefined;
    rudderstackSdkUrl: string | undefined;
    rudderstackConfigUrl: string | undefined;
    sqlConnectionLimits: SqlConnectionLimits;
}
interface SqlConnectionLimits {
    maxOpenConns: number;
    maxIdleConns: number;
    connMaxLifetime: number;
}
interface AuthSettings {
    OAuthSkipOrgRoleUpdateSync?: boolean;
    SAMLSkipOrgRoleSync?: boolean;
    LDAPSkipOrgRoleSync?: boolean;
    JWTAuthSkipOrgRoleSync?: boolean;
    GrafanaComSkipOrgRoleSync?: boolean;
    GithubSkipOrgRoleSync?: boolean;
    GitLabSkipOrgRoleSync?: boolean;
    OktaSkipOrgRoleSync?: boolean;
    AzureADSkipOrgRoleSync?: boolean;
    GoogleSkipOrgRoleSync?: boolean;
    GenericOAuthSkipOrgRoleSync?: boolean;
    DisableSyncLock?: boolean;
}

declare type SliderMarks = Record<number, React.ReactNode | {
    style?: React.CSSProperties;
    label?: string;
}>;

/**
 * With RBAC, the backend will return additional access control metadata to objects.
 * These metadata will contain user permissions associated to a given resource.
 *
 * For example:
 * {
 *   accessControl: { "datasources:read": true, "datasources:write": true }
 * }
 */
interface WithAccessControlMetadata {
    accessControl?: Record<string, boolean>;
}

interface RegistryItem {
    id: string;
    name: string;
    description?: string;
    aliasIds?: string[];
    /**
     * Some extensions should not be user selectable
     *  like: 'all' and 'any' matchers;
     */
    excludeFromPicker?: boolean;
    /**
     * Optional feature state
     */
    state?: PluginState;
}
interface RegistryItemWithOptions<TOptions = any> extends RegistryItem {
    /**
     * Convert the options to a string
     */
    getOptionsDisplayText?: (options: TOptions) => string;
    /**
     * Default options used if nothing else is specified
     */
    defaultOptions?: TOptions;
}
interface RegistrySelectInfo {
    options: Array<SelectableValue<string>>;
    current: Array<SelectableValue<string>>;
}
declare class Registry<T extends RegistryItem> {
    private init?;
    private ordered;
    private byId;
    private initialized;
    constructor(init?: (() => T[]) | undefined);
    setInit: (init: () => T[]) => void;
    getIfExists(id: string | undefined): T | undefined;
    private initialize;
    get(id: string): T;
    selectOptions(current?: string[], filter?: (ext: T) => boolean): RegistrySelectInfo;
    /**
     * Return a list of values by ID, or all values if not specified
     */
    list(ids?: string[]): T[];
    isEmpty(): boolean;
    register(ext: T): void;
    private sort;
}

/**
 * Convert instance settings to a reference
 *
 * @public
 */
declare function getDataSourceRef(ds: DataSourceInstanceSettings): DataSourceRef;
/**
 * Returns true if the argument is a DataSourceRef
 *
 * @public
 */
declare function isDataSourceRef(ref: DataSourceRef | string | null | undefined): ref is DataSourceRef;
/**
 * Get the UID from a string of reference
 *
 * @public
 */
declare function getDataSourceUID(ref: DataSourceRef | string | null): string | undefined;
declare const onUpdateDatasourceOption: (props: DataSourcePluginOptionsEditorProps, key: keyof DataSourceSettings) => (event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>) => void;
declare const onUpdateDatasourceJsonDataOption: <J extends DataSourceJsonData, S, K extends keyof J>(props: DataSourcePluginOptionsEditorProps<J, S>, key: K) => (event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement>) => void;
declare const onUpdateDatasourceSecureJsonDataOption: <J extends DataSourceJsonData, S extends {} = KeyValue<any>>(props: DataSourcePluginOptionsEditorProps<J, S>, key: string) => (event: React.SyntheticEvent<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>) => void;
declare const onUpdateDatasourceJsonDataOptionSelect: <J extends DataSourceJsonData, S, K extends keyof J>(props: DataSourcePluginOptionsEditorProps<J, S>, key: K) => (selected: SelectableValue) => void;
declare const onUpdateDatasourceJsonDataOptionChecked: <J extends DataSourceJsonData, S, K extends keyof J>(props: DataSourcePluginOptionsEditorProps<J, S>, key: K) => (event: React.SyntheticEvent<HTMLInputElement>) => void;
declare const onUpdateDatasourceSecureJsonDataOptionSelect: <J extends DataSourceJsonData, S extends {} = KeyValue<any>>(props: DataSourcePluginOptionsEditorProps<J, S>, key: string) => (selected: SelectableValue) => void;
declare const onUpdateDatasourceResetOption: (props: DataSourcePluginOptionsEditorProps, key: string) => (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void;
declare function updateDatasourcePluginOption<J extends DataSourceJsonData, S extends {} = KeyValue>(props: DataSourcePluginOptionsEditorProps<J, S>, key: keyof DataSourceSettings, val: any): void;
declare const updateDatasourcePluginJsonDataOption: <J extends DataSourceJsonData, S, K extends keyof J>(props: DataSourcePluginOptionsEditorProps<J, S>, key: K, val: any) => void;
declare const updateDatasourcePluginSecureJsonDataOption: <J extends DataSourceJsonData, S extends {} = KeyValue<any>>(props: DataSourcePluginOptionsEditorProps<J, S>, key: string, val: any) => void;
declare const updateDatasourcePluginResetOption: <J extends DataSourceJsonData, S extends {} = KeyValue<any>>(props: DataSourcePluginOptionsEditorProps<J, S>, key: string) => void;

declare const deprecationWarning: (file: string, oldName: string, newName?: string) => void;

declare type MutableField<T = any> = Field<T, MutableVector<T>>;
declare type MutableVectorCreator = (buffer?: any[]) => MutableVector;
declare const MISSING_VALUE: undefined;
declare class MutableDataFrame<T = any> extends FunctionalVector<T> implements DataFrame, MutableVector<T> {
    name?: string;
    refId?: string;
    meta?: QueryResultMeta;
    fields: MutableField[];
    private first;
    private creator;
    constructor(source?: DataFrame | DataFrameDTO, creator?: MutableVectorCreator);
    get length(): number;
    addFieldFor(value: unknown, name?: string): MutableField;
    addField(f: Field | FieldDTO, startLength?: number): MutableField;
    validate(): void;
    /**
     * Reverse all values
     */
    reverse(): void;
    private parsers;
    /**
     * @deprecated unclear if this is actually used
     */
    setParser(field: Field, parser: (v: string) => any): (v: string) => any;
    private parseValue;
    /**
     * This will add each value to the corresponding column
     */
    appendRow(row: unknown[]): void;
    /**
     * Add values from an object to corresponding fields. Similar to appendRow but does not create new fields.
     */
    add(value: T): void;
    set(index: number, value: T): void;
    /**
     * Get an object with a property for each field in the DataFrame
     */
    get(idx: number): T;
    /**
     * The simplified JSON values used in JSON.stringify()
     */
    toJSON(): DataFrameDTO;
}

declare enum CSVHeaderStyle {
    full = 0,
    name = 1,
    none = 2
}
interface CSVConfig {
    delimiter?: string;
    newline?: string;
    quoteChar?: string;
    encoding?: string;
    useExcelHeader?: boolean;
    headerStyle?: CSVHeaderStyle;
}
interface CSVParseCallbacks {
    /**
     * Get a callback before any rows are processed
     * This can return a modified table to force any
     * Column configurations
     */
    onHeader: (fields: Field[]) => void;
    onRow: (row: string[]) => void;
}
interface CSVOptions {
    config?: CSVConfig;
    callback?: CSVParseCallbacks;
}
declare function readCSV(csv: string, options?: CSVOptions): DataFrame[];
declare enum ParseState {
    Starting = 0,
    InHeader = 1,
    ReadingRows = 2
}
declare class CSVReader {
    config: CSVConfig;
    callback?: CSVParseCallbacks;
    state: ParseState;
    data: MutableDataFrame[];
    current: MutableDataFrame;
    constructor(options?: CSVOptions);
    private chunk;
    readCSV(text: string): MutableDataFrame[];
}
declare function toCSV(data: DataFrame[], config?: CSVConfig): string;

/**
 * Returns the log level of a log line.
 * Parse the line for level words. If no level is found, it returns `LogLevel.unknown`.
 *
 * Example: `getLogLevel('WARN 1999-12-31 this is great') // LogLevel.warn`
 */
/** @deprecated will be removed in the next major version */
declare function getLogLevel(line: string): LogLevel;
/** @deprecated will be removed in the next major version */
declare function getLogLevelFromKey(key: string | number): LogLevel;
/** @deprecated will be removed in the next major version */
declare function addLogLevelToSeries(series: DataFrame, lineIndex: number): DataFrame;
/** @deprecated will be removed in the next major version */
declare const LogsParsers: {
    [name: string]: LogsParser;
};
/** @deprecated will be removed in the next major version */
declare function calculateFieldStats(rows: LogRowModel[], extractor: RegExp): LogLabelStatsModel[];
/** @deprecated will be removed in the next major version */
declare function calculateLogsLabelStats(rows: LogRowModel[], label: string): LogLabelStatsModel[];
/** @deprecated will be removed in the next major version */
declare function calculateStats(values: unknown[]): LogLabelStatsModel[];
/** @deprecated will be removed in the next major version */
declare function getParser(line: string): LogsParser | undefined;
/** @deprecated will be removed in the next major version */
declare const sortInAscendingOrder: (a: LogRowModel, b: LogRowModel) => 0 | 1 | -1;
/** @deprecated will be removed in the next major version */
declare const sortInDescendingOrder: (a: LogRowModel, b: LogRowModel) => 0 | 1 | -1;
/** @deprecated will be removed in the next major version */
declare const sortLogsResult: (logsResult: LogsModel | null, sortOrder: LogsSortOrder) => LogsModel;
/** @deprecated will be removed in the next major version */
declare const sortLogRows: (logRows: LogRowModel[], sortOrder: LogsSortOrder) => LogRowModel[];
/** @deprecated will be removed in the next major version */
declare const checkLogsError: (logRow: LogRowModel) => {
    hasError: boolean;
    errorMessage?: string;
};
/** @deprecated will be removed in the next major version */
declare const escapeUnescapedString: (string: string) => string;

/**
 * Returns a map of label keys to value from an input selector string.
 *
 * Example: `parseLabels('{job="foo", instance="bar"}) // {job: "foo", instance: "bar"}`
 */
declare function parseLabels(labels: string): Labels;
/**
 * Returns a map labels that are common to the given label sets.
 */
declare function findCommonLabels(labelsSets: Labels[]): Labels;
/**
 * Returns a map of labels that are in `labels`, but not in `commonLabels`.
 */
declare function findUniqueLabels(labels: Labels | undefined, commonLabels: Labels): Labels;
/**
 * Check that all labels exist in another set of labels
 */
declare function matchAllLabels(expect: Labels, against?: Labels): boolean;
/**
 * Serializes the given labels to a string.
 */
declare function formatLabels(labels: Labels, defaultValue?: string, withoutBraces?: boolean): string;

/**
 * Round half away from zero ('commercial' rounding)
 * Uses correction to offset floating-point inaccuracies.
 * Works symmetrically for positive and negative numbers.
 *
 * ref: https://stackoverflow.com/a/48764436
 */
declare function roundDecimals(val: number, dec?: number): number;
/**
 * Tries to guess number of decimals needed to format a number
 *
 * used for determining minimum decimals required to uniformly
 * format a numric sequence, e.g. 10, 10.125, 10.25, 10.5
 *
 * good for precisce increments:  0.125            -> 3
 * bad  for arbitrary floats:     371.499999999999 -> 12
 */
declare function guessDecimals(num: number): number;

declare const objRemoveUndefined: (obj: {
    [key: string]: unknown;
}) => {
    [key: string]: unknown;
};

declare const classicColors: string[];

/**
 * Returns minimal time step from series time field
 * @param timeField
 */
declare const getSeriesTimeStep: (timeField: Field) => number;
/**
 * Checks if series time field has ms resolution
 * @param timeField
 */
declare const hasMsResolution: (timeField: Field) => boolean;

declare enum BinaryOperationID {
    Add = "+",
    Subtract = "-",
    Divide = "/",
    Multiply = "*"
}
declare type BinaryOperation = (left: number, right: number) => number;
interface BinaryOperatorInfo extends RegistryItem {
    operation: BinaryOperation;
}
declare const binaryOperators: Registry<BinaryOperatorInfo>;

declare enum NodeGraphDataFrameFieldNames {
    id = "id",
    title = "title",
    subTitle = "subtitle",
    mainStat = "mainstat",
    secondaryStat = "secondarystat",
    arc = "arc__",
    icon = "icon",
    color = "color",
    source = "source",
    target = "target",
    detail = "detail__"
}

declare const toOption: (value: string) => SelectableValue<string>;

interface FlotPairsOptions {
    xField: Field;
    yField: Field;
    nullValueMode?: NullValueMode;
}
declare function getFlotPairs({ xField, yField, nullValueMode }: FlotPairsOptions): GraphSeriesValue[][];
/**
 * Returns a constant series based on the first value from the provide series.
 * @param seriesData Series
 * @param range Start and end time for the constant series
 */
declare function getFlotPairsConstant(seriesData: GraphSeriesValue[][], range: TimeRange): GraphSeriesValue[][];

/**
 * @preserve jquery-param (c) 2015 KNOWLEDGECODE | MIT
 */

/**
 * Type to represent the value of a single query variable.
 *
 * @public
 */
declare type UrlQueryValue = string | number | boolean | string[] | number[] | boolean[] | undefined | null;
/**
 * Type to represent the values parsed from the query string.
 *
 * @public
 */
declare type UrlQueryMap = Record<string, UrlQueryValue>;
declare function renderUrl(path: string, query: UrlQueryMap | undefined): string;
declare function toUrlParams(a: any): string;
declare function appendQueryToUrl(url: string, stringToAppend: string): string;
/**
 * Return search part (as object) of current url
 */
declare function getUrlSearchParams(): UrlQueryMap;
/**
 * Parses an escaped url query string into key-value pairs.
 * Attribution: Code dervived from https://github.com/angular/angular.js/master/src/Angular.js#L1396
 * @returns {Object.<string,boolean|Array>}
 */
declare function parseKeyValue(keyValue: string): any;
declare const urlUtil: {
    renderUrl: typeof renderUrl;
    toUrlParams: typeof toUrlParams;
    appendQueryToUrl: typeof appendQueryToUrl;
    getUrlSearchParams: typeof getUrlSearchParams;
    parseKeyValue: typeof parseKeyValue;
};
/**
 * Create an string that is used in URL to represent the Explore state. This is basically just a stringified json
 * that is that used as a state of a single Explore pane so it does not represent full Explore URL.
 *
 * @param urlState
 * @param compact this parameter is deprecated and will be removed in a future release.
 */
declare function serializeStateToUrlParam(urlState: ExploreUrlState, compact?: boolean): string;

interface LocationUtilDependencies {
    config: GrafanaConfig;
    getTimeRangeForUrl: () => RawTimeRange;
    getVariablesUrlParams: (scopedVars?: ScopedVars) => UrlQueryMap;
}
declare const locationUtil: {
    /**
     *
     * @param getConfig
     * @param getAllVariableValuesForUrl
     * @param getTimeRangeForUrl
     * @internal
     */
    initialize: (dependencies: LocationUtilDependencies) => void;
    stripBaseFromUrl: (urlOrPath: string) => string;
    assureBaseUrl: (url: string) => string;
    updateSearchParams: (init: string, partial: string) => string;
    getTimeRangeUrlParams: () => string | null;
    getVariablesUrlParams: (scopedVars?: ScopedVars) => string | null;
    getUrlForPartial: (location: Location<any>, searchParamsToUpdate: Record<string, any>) => string;
    processUrl: (url: string) => string;
};

declare const DataLinkBuiltInVars: {
    keepTime: string;
    timeRangeFrom: string;
    timeRangeTo: string;
    includeVars: string;
    seriesName: string;
    fieldName: string;
    valueTime: string;
    valueNumeric: string;
    valueText: string;
    valueRaw: string;
    valueCalc: string;
};
declare type LinkToExploreOptions = {
    link: DataLink;
    scopedVars: ScopedVars;
    range: TimeRange;
    field: Field;
    internalLink: InternalDataLink;
    onClickFn?: SplitOpen;
    replaceVariables: InterpolateFunction;
};
declare function mapInternalLinkToExplore(options: LinkToExploreOptions): LinkModel<Field>;

/**
 * Enumeration of documentation topics
 * @internal
 */
declare enum DocsId {
    Transformations = 0,
    FieldConfig = 1,
    FieldConfigOverrides = 2
}

/**
 * @beta
 * Proxies a ES6 class so that it can be used as a base class for an ES5 class
 */
declare function makeClassES5Compatible<T extends abstract new (...args: ConstructorParameters<T>) => InstanceType<T>>(ES6Class: T): T;

/**
 * Will return any value as a number or NaN
 *
 * @internal
 * */
declare function anyToNumber(value: unknown): number;

/**
 * @internal
 */
declare type WithLoadingIndicatorOptions<T> = {
    whileLoading: T;
    source: Observable<T>;
};
/**
 * @internal
 */
declare function withLoadingIndicator<T>({ whileLoading, source }: WithLoadingIndicatorOptions<T>): Observable<T>;

/**
 * @deprecated use MappingType instead
 * @internal
 */
declare enum LegacyMappingType {
    ValueToText = 1,
    RangeToText = 2
}
/**
 * @alpha
 * Converts the old Angular value mappings to new react style
 */
declare function convertOldAngularValueMappings(panel: any, migratedThresholds?: ThresholdsConfig): ValueMapping[];

interface AppendedVectorInfo<T> {
    start: number;
    end: number;
    values: Vector<T>;
}
/**
 * This may be more trouble than it is worth.  This trades some computation time for
 * RAM -- rather than allocate a new array the size of all previous arrays, this just
 * points the correct index to their original array values
 */
declare class AppendedVectors<T = any> implements Vector<T> {
    length: number;
    source: Array<AppendedVectorInfo<T>>;
    constructor(startAt?: number);
    /**
     * Make the vector look like it is this long
     */
    setLength(length: number): void;
    append(v: Vector<T>): AppendedVectorInfo<T>;
    get(index: number): T;
    toArray(): T[];
    toJSON(): T[];
}

/**
 * @public
 */
declare class ArrayVector<T = any> extends FunctionalVector<T> implements MutableVector<T> {
    buffer: T[];
    constructor(buffer?: T[]);
    get length(): number;
    add(value: T): void;
    get(index: number): T;
    set(index: number, value: T): void;
    reverse(): void;
    toArray(): T[];
    toJSON(): T[];
}

interface CircularOptions$1<T> {
    buffer?: T[];
    append?: 'head' | 'tail';
    capacity?: number;
}
/**
 * Circular vector uses a single buffer to capture a stream of values
 * overwriting the oldest value on add.
 *
 * This supports adding to the 'head' or 'tail' and will grow the buffer
 * to match a configured capacity.
 *
 * @public
 */
declare class CircularVector<T = any> extends FunctionalVector<T> implements MutableVector<T> {
    private buffer;
    private index;
    private capacity;
    private tail;
    constructor(options: CircularOptions$1<T>);
    /**
     * This gets the appropriate add function depending on the buffer state:
     *  * head vs tail
     *  * growing buffer vs overwriting values
     */
    private getAddFunction;
    setCapacity(v: number): void;
    setAppendMode(mode: 'head' | 'tail'): void;
    reverse(): void;
    /**
     * Add the value to the buffer
     */
    add: (value: T) => void;
    get(index: number): T;
    set(index: number, value: T): void;
    get length(): number;
    toArray(): T[];
    toJSON(): T[];
}

/**
 * @public
 */
declare class ConstantVector<T = any> implements Vector<T> {
    private value;
    private len;
    constructor(value: T, len: number);
    get length(): number;
    get(index: number): T;
    toArray(): T[];
    toJSON(): T[];
}

/**
 * @public
 */
declare class BinaryOperationVector implements Vector<number> {
    private left;
    private right;
    private operation;
    constructor(left: Vector<number>, right: Vector<number>, operation: BinaryOperation);
    get length(): number;
    get(index: number): number;
    toArray(): number[];
    toJSON(): number[];
}

/**
 * Values are returned in the order defined by the input parameter
 */
declare class SortedVector<T = any> implements Vector<T> {
    private source;
    private order;
    constructor(source: Vector<T>, order: number[]);
    get length(): number;
    get(index: number): T;
    toArray(): T[];
    toJSON(): T[];
    getOrderArray(): number[];
}

/**
 * @public
 */
declare class FormattedVector<T = any> extends FunctionalVector<string> {
    private source;
    private formatter;
    constructor(source: Vector<T>, formatter: DisplayProcessor);
    get length(): number;
    get(index: number): string;
}

/**
 * IndexVector is a simple vector implementation that returns the index value
 * for each element in the vector.  It is functionally equivolant a vector backed
 * by an array with values: `[0,1,2,...,length-1]`
 */
declare class IndexVector extends FunctionalVector<number> {
    private len;
    constructor(len: number);
    get length(): number;
    get(index: number): number;
    /**
     * Returns a field representing the range [0 ... length-1]
     */
    static newField(len: number): Field<number>;
}

/**
 * This will force all values to be numbers
 *
 * @public
 */
declare class AsNumberVector extends FunctionalVector<number> {
    private field;
    constructor(field: Vector);
    get length(): number;
    get(index: number): number;
}

interface FieldWithIndex extends Field {
    index: number;
}
declare class FieldCache {
    fields: FieldWithIndex[];
    private fieldByName;
    private fieldByType;
    constructor(data: DataFrame);
    getFields(type?: FieldType): FieldWithIndex[];
    hasFieldOfType(type: FieldType): boolean;
    getFirstFieldOfType(type: FieldType, includeHidden?: boolean): FieldWithIndex | undefined;
    hasFieldNamed(name: string): boolean;
    hasFieldWithNameAndType(name: string, type: FieldType): boolean;
    /**
     * Returns the first field with the given name.
     */
    getFieldByName(name: string): FieldWithIndex | undefined;
    /**
     * Returns the fields with the given label.
     */
    getFieldsByLabel(label: string, value: string): FieldWithIndex[];
}

interface CircularOptions {
    append?: 'head' | 'tail';
    capacity?: number;
}
/**
 * This dataframe can have values constantly added, and will never
 * exceed the given capacity
 */
declare class CircularDataFrame<T = any> extends MutableDataFrame<T> {
    constructor(options: CircularOptions);
}

/**
 * Given a name and value, this will pick a reasonable field type
 */
declare function guessFieldTypeFromNameAndValue(name: string, v: unknown): FieldType;
/**
 * Check the field type to see what the contents are
 */
declare function getFieldTypeFromValue(v: unknown): FieldType;
/**
 * Given a value this will guess the best column type
 *
 * NOTE: this is will try to see if string values can be mapped to other types (like number)
 */
declare function guessFieldTypeFromValue(v: unknown): FieldType;
/**
 * Looks at the data to guess the column type.  This ignores any existing setting
 */
declare function guessFieldTypeForField(field: Field): FieldType | undefined;
/**
 * @returns A copy of the series with the best guess for each field type.
 * If the series already has field types defined, they will be used, unless `guessDefined` is true.
 * @param series The DataFrame whose field's types should be guessed
 * @param guessDefined Whether to guess types of fields with already defined types
 */
declare const guessFieldTypes: (series: DataFrame, guessDefined?: boolean) => DataFrame;
declare const isTableData: (data: unknown) => data is DataFrame;
declare const isDataFrame: (data: unknown) => data is DataFrame;
/**
 * Inspect any object and return the results as a DataFrame
 */
declare function toDataFrame(data: any): DataFrame;
declare const toLegacyResponseData: (frame: DataFrame) => TimeSeries | TableData;
declare function sortDataFrame(data: DataFrame, sortIndex?: number, reverse?: boolean): DataFrame;
/**
 * Returns a copy with all values reversed
 */
declare function reverseDataFrame(data: DataFrame): DataFrame;
/**
 * Wrapper to get an array from each field value
 */
declare function getDataFrameRow(data: DataFrame, row: number): any[];
/**
 * Returns a copy that does not include functions
 */
declare function toDataFrameDTO(data: DataFrame): DataFrameDTO;
declare function toFilteredDataFrameDTO(data: DataFrame, fieldPredicate?: (f: Field) => boolean): DataFrameDTO;
declare const getTimeField: (series: DataFrame) => {
    timeField?: Field;
    timeIndex?: number;
};
/**
 * Given data request results, will return data frames with field types set
 *
 * This is also used by PanelChrome for snapshot support
 */
declare function getProcessedDataFrames(results?: DataQueryResponseData[]): DataFrame[];
/**
 * Will process the panel data frames and in case of loading state with no data, will return the last result data but with loading state
 * This is to have panels not flicker temporarily with "no data" while loading
 */
declare function preProcessPanelData(data: PanelData, lastResult?: PanelData): PanelData;

interface Dimension<T = any> {
    name: string;
    columns: Array<Field<T>>;
}
declare type Dimensions = KeyValue<Dimension>;
declare const createDimension: (name: string, columns: Field[]) => Dimension;
declare const getColumnsFromDimension: (dimension: Dimension) => Field<any, Vector<any>>[];
declare const getColumnFromDimension: (dimension: Dimension, column: number) => Field<any, Vector<any>>;
declare const getValueFromDimension: (dimension: Dimension, column: number, row: number) => any;
declare const getAllValuesFromDimension: (dimension: Dimension, column: number, row: number) => any[];
declare const getDimensionByName: (dimensions: Dimensions, name: string) => Dimension<any>;

/** @public */
declare type ValueConverter<T = any> = (val: unknown) => T;
/**
 * The ArrayDataFrame takes an array of objects and presents it as a DataFrame
 *
 * @alpha
 */
declare class ArrayDataFrame<T = any> extends FunctionalVector<T> implements DataFrame {
    private source;
    name?: string;
    refId?: string;
    meta?: QueryResultMeta;
    fields: Field[];
    length: number;
    constructor(source: T[], names?: string[]);
    /**
     * Add a field for each property in the object.  This will guess the type
     */
    setFieldsFromObject(obj: Record<string, unknown>): void;
    /**
     * Configure how the object property is passed to the data frame
     */
    setFieldType(name: string, type: FieldType, converter?: ValueConverter): Field;
    /**
     * Get an object with a property for each field in the DataFrame
     */
    get(idx: number): T;
    /**
     * The simplified JSON values used in JSON.stringify()
     */
    toJSON(): DataFrameDTO;
}

/**
 * The JSON transfer object for DataFrames.  Values are stored in simple JSON
 *
 * @alpha
 */
interface DataFrameJSON {
    /**
     * The schema defines the field type and configuration.
     */
    schema?: DataFrameSchema;
    /**
     * The field data
     */
    data?: DataFrameData;
}
declare type FieldValues = unknown[];
/**
 * @alpha
 */
interface DataFrameData {
    /**
     * A columnar store that matches fields defined by schema.
     */
    values: FieldValues[];
    /**
     * Since JSON cannot encode NaN, Inf, -Inf, and undefined, these entities
     * are decoded after JSON.parse() using this struct
     */
    entities?: Array<FieldValueEntityLookup | null>;
    /**
     * Holds value bases per field so we can encode numbers from fixed points
     * e.g. [1612900958, 1612900959, 1612900960] -> 1612900958 + [0, 1, 2]
     */
    bases?: number[];
    /**
     * Holds value multipliers per field so we can encode large numbers concisely
     * e.g. [4900000000, 35000000000] -> 1e9 + [4.9, 35]
     */
    factors?: number[];
    /**
     * Holds enums per field so we can encode recurring string values as ints
     * e.g. ["foo", "foo", "baz", "foo"] -> ["foo", "baz"] + [0,0,1,0]
     *
     * NOTE: currently only decoding is implemented
     */
    enums?: Array<string[] | null>;
}
/**
 * The JSON transfer object for DataFrames.  Values are stored in simple JSON
 *
 * @alpha
 */
interface DataFrameSchema {
    /**
     * Matches the query target refId
     */
    refId?: string;
    /**
     * Initial response global metadata
     */
    meta?: QueryResultMeta;
    /**
     * Frame name
     */
    name?: string;
    /**
     * Field definition without any metadata
     */
    fields: FieldSchema[];
}
/**
 * Field object passed over JSON
 *
 * @alpha
 */
interface FieldSchema {
    name: string;
    type?: FieldType;
    config?: FieldConfig;
    labels?: Labels;
}
/**
 * Since JSON cannot encode NaN, Inf, -Inf, and undefined, the locations
 * of these entities in field value arrays are stored here for restoration
 * after JSON.parse()
 *
 * @alpha
 */
interface FieldValueEntityLookup {
    NaN?: number[];
    Undef?: number[];
    Inf?: number[];
    NegInf?: number[];
}
/**
 * @internal use locally
 */
declare function decodeFieldValueEntities(lookup: FieldValueEntityLookup, values: FieldValues): void;
/**
 * @internal use locally
 */
declare function decodeFieldValueEnums(lookup: string[], values: FieldValues): void;
/**
 * NOTE: dto.data.values will be mutated and decoded/inflated using entities,bases,factors,enums
 *
 * @alpha
 */
declare function dataFrameFromJSON(dto: DataFrameJSON): DataFrame;
/**
 * This converts DataFrame to a json representation with distinct schema+data
 *
 * @alpha
 */
declare function dataFrameToJSON(frame: DataFrame): DataFrameJSON;

/**
 * Returns true if both frames have the same name, fields, labels and configs.
 *
 * @example
 * To compare multiple frames use:
 * ```
 * compareArrayValues(a, b, framesHaveSameStructure);
 * ```
 * @beta
 */
declare function compareDataFrameStructures(a: DataFrame, b: DataFrame, skipConfig?: boolean): boolean;
/**
 * Check if all values in two arrays match the compare function
 *
 * @beta
 */
declare function compareArrayValues<T>(a: T[], b: T[], cmp: (a: T, b: T) => boolean): boolean;
declare type Cmp = (valA: unknown, valB: unknown) => boolean;
/**
 * Checks if two objects are equal shallowly
 *
 * @beta
 */
declare function shallowCompare<T extends {}>(a: T, b: T, cmp?: Cmp): boolean;

declare function isTimeSeriesFrame(frame: DataFrame): boolean;
declare function isTimeSeriesFrames(data: DataFrame[]): boolean;
/**
 * Indicates if there is any time field in the array of data frames
 * @param data
 */
declare function anySeriesWithTimeField(data: DataFrame[]): boolean;

declare enum MatcherID {
    anyMatch = "anyMatch",
    allMatch = "allMatch",
    invertMatch = "invertMatch",
    alwaysMatch = "alwaysMatch",
    neverMatch = "neverMatch"
}
declare enum FieldMatcherID {
    numeric = "numeric",
    time = "time",
    first = "first",
    firstTimeField = "firstTimeField",
    byType = "byType",
    byName = "byName",
    byNames = "byNames",
    byRegexp = "byRegexp",
    byRegexpOrNames = "byRegexpOrNames",
    byFrameRefID = "byFrameRefID",
    byValue = "byValue"
}
/**
 * Field name matchers
 */
declare enum FrameMatcherID {
    byName = "byName",
    byRefId = "byRefId",
    byIndex = "byIndex"
}
/**
 * @public
 */
declare enum ValueMatcherID {
    regex = "regex",
    isNull = "isNull",
    isNotNull = "isNotNull",
    greater = "greater",
    greaterOrEqual = "greaterOrEqual",
    lower = "lower",
    lowerOrEqual = "lowerOrEqual",
    equal = "equal",
    notEqual = "notEqual",
    between = "between"
}

declare enum DataTransformerID {
    append = "append",
    reduce = "reduce",
    order = "order",
    organize = "organize",
    rename = "rename",
    calculateField = "calculateField",
    /** @deprecated use joinByField */
    seriesToColumns = "seriesToColumns",
    seriesToRows = "seriesToRows",
    merge = "merge",
    concatenate = "concatenate",
    labelsToFields = "labelsToFields",
    filterFields = "filterFields",
    filterFieldsByName = "filterFieldsByName",
    filterFrames = "filterFrames",
    filterByRefId = "filterByRefId",
    renameByRegex = "renameByRegex",
    filterByValue = "filterByValue",
    noop = "noop",
    ensureColumns = "ensureColumns",
    groupBy = "groupBy",
    sortBy = "sortBy",
    histogram = "histogram",
    configFromData = "configFromData",
    rowsToFields = "rowsToFields",
    prepareTimeSeries = "prepareTimeSeries",
    convertFieldType = "convertFieldType",
    fieldLookup = "fieldLookup",
    heatmap = "heatmap",
    spatial = "spatial",
    joinByField = "joinByField",
    joinByLabels = "joinByLabels",
    extractFields = "extractFields",
    groupingToMatrix = "groupingToMatrix",
    limit = "limit",
    partitionByValues = "partitionByValues",
    timeSeriesTable = "timeSeriesTable"
}

declare enum ReducerID {
    sum = "sum",
    max = "max",
    min = "min",
    logmin = "logmin",
    mean = "mean",
    variance = "variance",
    stdDev = "stdDev",
    last = "last",
    first = "first",
    count = "count",
    range = "range",
    diff = "diff",
    diffperc = "diffperc",
    delta = "delta",
    step = "step",
    firstNotNull = "firstNotNull",
    lastNotNull = "lastNotNull",
    changeCount = "changeCount",
    distinctCount = "distinctCount",
    allIsZero = "allIsZero",
    allIsNull = "allIsNull",
    allValues = "allValues",
    uniqueValues = "uniqueValues"
}
declare type FieldReducer = (field: Field, ignoreNulls: boolean, nullAsZero: boolean) => FieldCalcs;
interface FieldReducerInfo extends RegistryItem {
    emptyInputResult?: any;
    standard: boolean;
    reduce?: FieldReducer;
}
interface ReduceFieldOptions {
    field: Field;
    reducers: string[];
}
/**
 * @returns an object with a key for each selected stat
 * NOTE: This will also modify the 'field.state' object,
 * leaving values in a cache until cleared.
 */
declare function reduceField(options: ReduceFieldOptions): FieldCalcs;
declare const fieldReducers: Registry<FieldReducerInfo>;
declare function doStandardCalcs(field: Field, ignoreNulls: boolean, nullAsZero: boolean): FieldCalcs;

interface FieldValueMatcherConfig {
    reducer: ReducerID;
    op?: ComparisonOperation;
    value?: number;
}

/**
 * Registry that contains all of the built in field matchers.
 * @public
 */
declare const fieldMatchers: Registry<FieldMatcherInfo<any>>;
/**
 * Registry that contains all of the built in frame matchers.
 * @public
 */
declare const frameMatchers: Registry<FrameMatcherInfo<any>>;
/**
 * Registry that contains all of the built in value matchers.
 * @public
 */
declare const valueMatchers: Registry<ValueMatcherInfo<any>>;
/**
 * Resolves a field matcher from the registry for given config.
 * Will throw an error if matcher can not be resolved.
 * @public
 */
declare function getFieldMatcher(config: MatcherConfig): FieldMatcher;
/**
 * Resolves a frame matcher from the registry for given config.
 * Will throw an error if matcher can not be resolved.
 * @public
 */
declare function getFrameMatchers(config: MatcherConfig): FrameMatcher;
/**
 * Resolves a value matcher from the registry for given config.
 * Will throw an error if matcher can not be resolved.
 * @public
 */
declare function getValueMatcher(config: MatcherConfig): ValueMatcher;

interface LimitTransformerOptions {
    limitField?: number;
}

interface GroupingToMatrixTransformerOptions {
    columnField?: string;
    rowField?: string;
    valueField?: string;
    emptyValue?: SpecialValue;
}

interface ConvertFieldTypeTransformerOptions {
    conversions: ConvertFieldTypeOptions[];
}
interface ConvertFieldTypeOptions {
    /**
     * The field to convert field type
     */
    targetField?: string;
    /**
     * The field type to convert to
     */
    destinationType?: FieldType;
    /**
     * Date format to parse a string datetime
     */
    dateFormat?: string;
    /** When converting to an enumeration, this is the target config */
    enumConfig?: EnumFieldConfig;
}
/**
 * Checks the first value. Assumes any number should be time fieldtype. Otherwise attempts to make the fieldtype time.
 * @param field - field to ensure is a time fieldtype
 * @param dateFormat - date format used to parse a string datetime
 * @returns field as time
 *
 * @public
 */
declare function ensureTimeField(field: Field, dateFormat?: string): Field;

/**
 * @internal
 */
declare const histogramBucketSizes: number[];
/**
 * @alpha
 */
interface HistogramTransformerOptions {
    bucketSize?: number;
    bucketOffset?: number;
    combine?: boolean;
}
/**
 * This is a helper class to use the same text in both a panel and transformer UI
 *
 * @internal
 */
declare const histogramFieldInfo: {
    bucketSize: {
        name: string;
        description: undefined;
    };
    bucketOffset: {
        name: string;
        description: string;
    };
    combine: {
        name: string;
        description: string;
    };
};
/**
 * @alpha
 */
declare const histogramTransformer: SynchronousDataTransformerInfo<HistogramTransformerOptions>;
/**
 * @internal
 */
declare const histogramFrameBucketMinFieldName = "xMin";
/**
 * @internal
 */
declare function isHistogramFrameBucketMinFieldName(v: string): boolean;
/**
 * @internal
 */
declare const histogramFrameBucketMaxFieldName = "xMax";
/**
 * @internal
 */
declare function isHistogramFrameBucketMaxFieldName(v: string): boolean;
/**
 * @alpha
 */
interface HistogramFields {
    xMin: Field;
    xMax: Field;
    counts: Field[];
}
/**
 * Given a frame, find the explicit histogram fields
 *
 * @alpha
 */
declare function getHistogramFields(frame: DataFrame): HistogramFields | undefined;
/**
 * @alpha
 */
declare function buildHistogram(frames: DataFrame[], options?: HistogramTransformerOptions): HistogramFields | null;
/**
 * @internal
 */
declare function incrRound(num: number, incr: number): number;
/**
 * @internal
 */
declare function incrRoundUp(num: number, incr: number): number;
/**
 * @internal
 */
declare function incrRoundDn(num: number, incr: number): number;
/**
 * @internal
 */
declare function histogramFieldsToFrame(info: HistogramFields, theme?: GrafanaTheme2): DataFrame;

/**
 * Options for renameByRegexTransformer
 *
 * @public
 */
interface RenameByRegexTransformerOptions {
    regex: string;
    renamePattern: string;
}

interface MergeTransformerOptions {
}

interface SortByField {
    field: string;
    desc?: boolean;
    index?: number;
}
interface SortByTransformerOptions {
    sort: SortByField[];
}

declare enum GroupByOperationID {
    aggregate = "aggregate",
    groupBy = "groupby"
}
interface GroupByFieldOptions {
    aggregations: ReducerID[];
    operation: GroupByOperationID | null;
}
interface GroupByTransformerOptions {
    fields: Record<string, GroupByFieldOptions>;
}

declare enum LabelsToFieldsMode {
    Columns = "columns",
    Rows = "rows"
}
interface LabelsToFieldsOptions {
    mode?: LabelsToFieldsMode;
    /** When empty, this will keep all labels, otherise it will keep only labels matching the value */
    keepLabels?: string[];
    /**
     * When in column mode and if set this will use this label's value as the value field name.
     */
    valueLabel?: string;
}

interface RenameFieldsTransformerOptions {
    renameByName: Record<string, string>;
}

interface SeriesToRowsTransformerOptions {
}

declare enum JoinMode {
    outer = "outer",
    inner = "inner"
}
interface JoinByFieldOptions {
    byField?: string;
    mode?: JoinMode;
}

declare enum CalculateFieldMode {
    ReduceRow = "reduceRow",
    BinaryOperation = "binary",
    Index = "index"
}
interface ReduceOptions {
    include?: string[];
    reducer: ReducerID;
    nullValueMode?: NullValueMode;
}
interface BinaryOptions {
    left: string;
    operator: BinaryOperationID;
    right: string;
}
interface CalculateFieldTransformerOptions {
    timeSeries?: boolean;
    mode: CalculateFieldMode;
    reduce?: ReduceOptions;
    binary?: BinaryOptions;
    replaceFields?: boolean;
    alias?: string;
}

declare enum ConcatenateFrameNameMode {
    /**
     * Ignore the source frame name when moving to the destination
     */
    Drop = "drop",
    /**
     * Copy the source frame name to the destination field.  The final field will contain
     * both the frame and field name
     */
    FieldName = "field",
    /**
     * Copy the source frame name to a label on the field.  The label key is controlled
     * by frameNameLabel
     */
    Label = "label"
}
interface ConcatenateTransformerOptions {
    frameNameMode?: ConcatenateFrameNameMode;
    frameNameLabel?: string;
}

declare enum ReduceTransformerMode {
    SeriesToRows = "seriesToRows",
    ReduceFields = "reduceFields"
}
interface ReduceTransformerOptions {
    reducers: ReducerID[];
    fields?: MatcherConfig;
    mode?: ReduceTransformerMode;
    includeTimeField?: boolean;
    labelsToFields?: boolean;
}

interface OrderFieldsTransformerOptions {
    indexByName: Record<string, number>;
}

interface OrganizeFieldsTransformerOptions extends OrderFieldsTransformerOptions, RenameFieldsTransformerOptions {
    excludeByName: Record<string, boolean>;
}

declare enum FilterByValueType {
    exclude = "exclude",
    include = "include"
}
declare enum FilterByValueMatch {
    all = "all",
    any = "any"
}
interface FilterByValueFilter {
    fieldName: string;
    config: MatcherConfig;
}
interface FilterByValueTransformerOptions {
    filters: FilterByValueFilter[];
    type: FilterByValueType;
    match: FilterByValueMatch;
}

interface FilterFramesByRefIdTransformerOptions {
    include?: string;
    exclude?: string;
}

interface RegexpOrNamesMatcherOptions {
    pattern?: string;
    names?: string[];
}
/**
 * Mode to be able to toggle if the names matcher should match fields in provided
 * list or all except provided names.
 * @public
 */
declare enum ByNamesMatcherMode {
    exclude = "exclude",
    include = "include"
}
/**
 * Options to instruct the by names matcher to either match all fields in given list
 * or all except the fields in the list.
 * @public
 */
interface ByNamesMatcherOptions {
    mode?: ByNamesMatcherMode;
    names?: string[];
    readOnly?: boolean;
    prefix?: string;
}

interface FilterFieldsByNameTransformerOptions {
    include?: RegexpOrNamesMatcherOptions;
    exclude?: RegexpOrNamesMatcherOptions;
}

interface FilterOptions {
    include?: MatcherConfig;
    exclude?: MatcherConfig;
}

interface NoopTransformerOptions {
}

declare const standardTransformers: {
    noopTransformer: SynchronousDataTransformerInfo<NoopTransformerOptions>;
    filterFieldsTransformer: DataTransformerInfo<FilterOptions>;
    filterFieldsByNameTransformer: DataTransformerInfo<FilterFieldsByNameTransformerOptions>;
    filterFramesTransformer: DataTransformerInfo<FilterOptions>;
    filterFramesByRefIdTransformer: DataTransformerInfo<FilterFramesByRefIdTransformerOptions>;
    filterByValueTransformer: DataTransformerInfo<FilterByValueTransformerOptions>;
    orderFieldsTransformer: DataTransformerInfo<OrderFieldsTransformerOptions>;
    organizeFieldsTransformer: DataTransformerInfo<OrganizeFieldsTransformerOptions>;
    reduceTransformer: DataTransformerInfo<ReduceTransformerOptions>;
    concatenateTransformer: DataTransformerInfo<ConcatenateTransformerOptions>;
    calculateFieldTransformer: DataTransformerInfo<CalculateFieldTransformerOptions>;
    joinByFieldTransformer: SynchronousDataTransformerInfo<JoinByFieldOptions>;
    /** @deprecated */
    seriesToColumnsTransformer: SynchronousDataTransformerInfo<JoinByFieldOptions>;
    seriesToRowsTransformer: DataTransformerInfo<SeriesToRowsTransformerOptions>;
    renameFieldsTransformer: DataTransformerInfo<RenameFieldsTransformerOptions>;
    labelsToFieldsTransformer: SynchronousDataTransformerInfo<LabelsToFieldsOptions>;
    ensureColumnsTransformer: SynchronousDataTransformerInfo<any>;
    groupByTransformer: DataTransformerInfo<GroupByTransformerOptions>;
    sortByTransformer: DataTransformerInfo<SortByTransformerOptions>;
    mergeTransformer: DataTransformerInfo<MergeTransformerOptions>;
    renameByRegexTransformer: DataTransformerInfo<RenameByRegexTransformerOptions>;
    histogramTransformer: SynchronousDataTransformerInfo<HistogramTransformerOptions>;
    convertFieldTypeTransformer: SynchronousDataTransformerInfo<ConvertFieldTypeTransformerOptions>;
    groupingToMatrixTransformer: DataTransformerInfo<GroupingToMatrixTransformerOptions>;
    limitTransformer: DataTransformerInfo<LimitTransformerOptions>;
};

/**
 * Apply configured transformations to the input data
 */
declare function transformDataFrame(options: Array<DataTransformerConfig | CustomTransformOperator>, data: DataFrame[], ctx?: DataTransformContext): Observable<DataFrame[]>;

interface TransformerUIProps<T> {
    /**
     * Transformer configuration, persisted on panel's model
     */
    options: T;
    /**
     * Pre-transform data frames
     */
    input: DataFrame[];
    onChange: (options: T) => void;
}
interface TransformerRegistryItem<TOptions> extends RegistryItem {
    /**
     * Object describing transformer configuration
     */
    transformation: DataTransformerInfo<TOptions>;
    /** Markdown with more detailed description and help */
    help?: string;
    /**
     * React component used as UI for the transformer
     */
    editor: React$1.ComponentType<TransformerUIProps<TOptions>>;
}
/**
 * Registry of transformation options that can be driven by
 * stored configuration files.
 */
declare const standardTransformersRegistry: Registry<TransformerRegistryItem<any>>;

/**
 * @internal
 */
interface JoinOptions {
    /**
     * The input fields
     */
    frames: DataFrame[];
    /**
     * The field to join -- frames that do not have this field will be droppped
     */
    joinBy?: FieldMatcher;
    /**
     * Optionally filter the non-join fields
     */
    keep?: FieldMatcher;
    /**
     * @internal -- used when we need to keep a reference to the original frame/field index
     */
    keepOriginIndices?: boolean;
    /**
     * @internal -- Optionally specify a join mode (outer or inner)
     */
    mode?: JoinMode;
}
/**
 * This will return a single frame joined by the first matching field.  When a join field is not specified,
 * the default will use the first time field
 */
declare function joinDataFrames(options: JoinOptions): DataFrame | undefined;

declare function escapeStringForRegex(value: string): string;
declare function unEscapeStringFromRegex(value: string): string;
declare function stringStartsAsRegEx(str: string): boolean;
declare function stringToJsRegex(str: string): RegExp;
declare function stringToMs(str: string): number;
declare function toNumberString(value: number | undefined | null): string;
declare function toIntegerOrUndefined(value: string): number | undefined;
declare function toFloatOrUndefined(value: string): number | undefined;
declare function toPascalCase(string: string): string;
declare function escapeRegex(value: string): string;

interface RenderMarkdownOptions {
    noSanitize?: boolean;
    breaks?: boolean;
}
declare function renderMarkdown(str?: string, options?: RenderMarkdownOptions): string;
declare function renderTextPanelMarkdown(str?: string, options?: RenderMarkdownOptions): string;

interface TextMatch {
    text: string;
    start: number;
    length: number;
    end: number;
}
/**
 * Adapt findMatchesInText for react-highlight-words findChunks handler.
 * See https://github.com/bvaughn/react-highlight-words#props
 */
declare function findHighlightChunksInText({ searchWords, textToHighlight, }: {
    searchWords: Array<string | RegExp>;
    textToHighlight: string;
}): TextMatch[];
/**
 * Returns a list of substring regexp matches.
 */
declare function findMatchesInText(haystack: string, needle: string): TextMatch[];
/**
 * Converts any mode modifiers in the text to the Javascript equivalent flag
 */
declare function parseFlags(text: string): {
    cleaned: string;
    flags: string;
};

/**
 * Return a sanitized string that is going to be rendered in the browser to prevent XSS attacks.
 * Note that sanitized tags will be removed, such as "<script>".
 * We don't allow form or input elements.
 */
declare function sanitize(unsanitizedString: string): string;
/**
 * Returns string safe from XSS attacks to be used in the Text panel plugin.
 *
 * Even though we allow the style-attribute, there's still default filtering applied to it
 * Info: https://github.com/leizongmin/js-xss#customize-css-filter
 * Whitelist: https://github.com/leizongmin/js-css-filter/blob/master/lib/default.js
 */
declare function sanitizeTextPanelContent(unsanitizedString: string): string;
declare function sanitizeSVGContent(unsanitizedString: string): string;
declare function sanitizeUrl(url: string): string;
declare function hasAnsiCodes(input: string): boolean;
declare function escapeHtml(str: string): string;

declare const textUtil: {
    escapeHtml: typeof escapeHtml;
    hasAnsiCodes: typeof hasAnsiCodes;
    sanitize: typeof sanitize;
    sanitizeTextPanelContent: typeof sanitizeTextPanelContent;
    sanitizeUrl: typeof sanitizeUrl;
    sanitizeSVGContent: typeof sanitizeSVGContent;
};

/**
 * @alpha
 */
interface MonacoLanguageRegistryItem extends RegistryItem {
    init: () => Promise<void>;
}
/**
 * @alpha
 */
declare const monacoLanguageRegistry: Registry<MonacoLanguageRegistryItem>;

/**
 * Describes a empty value matcher option.
 * @public
 */
interface ValueMatcherOptions {
}
/**
 * Describes a basic value matcher option that has a single value.
 * @public
 */
interface BasicValueMatcherOptions<T = any> extends ValueMatcherOptions {
    value: T;
}
/**
 * Describes a range value matcher option that has a to and a from value to
 * be able to match a range.
 * @public
 */
interface RangeValueMatcherOptions<T = any> extends ValueMatcherOptions {
    from: T;
    to: T;
}

declare type LayoutMode = LayoutModes.Grid | LayoutModes.List;
declare enum LayoutModes {
    Grid = "grid",
    List = "list"
}

interface Props {
    plugin: PanelPlugin;
    currentFieldConfig: FieldConfigSource;
    currentOptions: Record<string, any>;
    isAfterPluginChange: boolean;
}
interface OptionDefaults {
    options: any;
    fieldConfig: FieldConfigSource;
}
/**
 * This will return the panel options with defaults applied.
 * Used internally, not intended for external use.
 * @internal
 */
declare function getPanelOptionsWithDefaults({ plugin, currentOptions, currentFieldConfig, isAfterPluginChange, }: Props): OptionDefaults;
/**
 * Used internally, not intended for external use.
 * @internal
 */
declare function filterFieldConfigOverrides(overrides: ConfigOverrideRule[], condition: (value: DynamicConfigValue) => boolean): ConfigOverrideRule[];
/**
 * Used internally, not intended for external use.
 * @internal
 */
declare function restoreCustomOverrideRules(current: FieldConfigSource, old: FieldConfigSource): FieldConfigSource;
/**
 * Used internally, not intended for external use.
 * @internal
 */
declare function isCustomFieldProp(prop: DynamicConfigValue): boolean;
/**
 * Used internally, not intended for external use.
 * @internal
 */
declare function isStandardFieldProp(prop: DynamicConfigValue): boolean;

/**
 * Helper functionality to create a field config registry.
 *
 * @param config - configuration to base the registry on.
 * @param pluginName - name of the plugin that will use the registry.
 * @internal
 */
declare function createFieldConfigRegistry<TFieldConfigOptions>(config: SetFieldConfigOptionsArgs<TFieldConfigOptions> | undefined, pluginName: string): FieldConfigOptionsRegistry;

/**
 * Describes the options used when triggering a query via the {@link QueryRunner}.
 *
 * @internal
 */
interface QueryRunnerOptions {
    datasource: DataSourceRef | DataSourceApi | null;
    queries: DataQuery[];
    panelId?: number;
    dashboardId?: number;
    timezone: TimeZone;
    timeRange: TimeRange;
    timeInfo?: string;
    maxDataPoints: number;
    minInterval: string | undefined | null;
    scopedVars?: ScopedVars;
    cacheTimeout?: string;
    queryCachingTTL?: number;
    app?: string;
}
/**
 * Describes the QueryRunner that can used to exectue queries in e.g. app plugins.
 * QueryRunner instances can be created via the {@link @grafana/runtime#createQueryRunner | createQueryRunner}.
 *
 * @internal
 */
interface QueryRunner {
    get(): Observable<PanelData>;
    run(options: QueryRunnerOptions): void;
    cancel(): void;
    destroy(): void;
}

interface PluginContextType {
    meta: PluginMeta;
}
interface DataSourcePluginContextType extends PluginContextType {
    instanceSettings: DataSourceInstanceSettings;
}

declare type PluginContextProviderProps = {
    meta: PluginMeta;
};
declare function PluginContextProvider(props: PropsWithChildren<PluginContextProviderProps>): ReactElement;

declare type DataSourcePluginContextProviderProps = {
    instanceSettings: DataSourceInstanceSettings;
};
declare function DataSourcePluginContextProvider(props: PropsWithChildren<DataSourcePluginContextProviderProps>): ReactElement;

declare function usePluginContext(): PluginContextType;

declare function isDataSourcePluginContext(context: PluginContextType): context is DataSourcePluginContextType;

export { AbsoluteTimeRange, AbstractLabelMatcher, AbstractLabelOperator, AbstractQuery, AdHocVariableFilter, AdHocVariableModel, AlertErrorPayload, AlertPayload, AlertState, AlertStateInfo, AnalyticsSettings, AngularPanelMenuItem, AnnotationChangeEvent, AnnotationEvent, AnnotationEventFieldMapping, AnnotationEventFieldSource, AnnotationEventMappings, AnnotationEventUIModel, AnnotationQuery, AnnotationQueryRequest, AnnotationSupport, AppEvent, AppEvents, AppPlugin, AppPluginMeta, AppRootProps, AppendedVectors, ApplyFieldOverrideOptions, ArrayDataFrame, ArrayVector, AsNumberVector, AuthSettings, BaseVariableModel, BasicValueMatcherOptions, BinaryOperation, BinaryOperationID, BinaryOperationVector, BootData, BuildInfo, BusEvent, BusEventBase, BusEventHandler, BusEventType, BusEventWithPayload, ByNamesMatcherMode, ByNamesMatcherOptions, CSVConfig, CSVHeaderStyle, CSVOptions, CSVParseCallbacks, CSVReader, CartesianCoords2D, CircularDataFrame, CircularVector, Column, ConfigOverrideRule, ConstantVariableModel, ConstantVector, CoreApp, CreatePlotOverlay, CurrentUserDTO, CustomTransformOperator, CustomVariableModel, CustomVariableSupport, DEFAULT_FIELD_DISPLAY_VALUES_LIMIT, DEFAULT_SAML_NAME, DashboardCursorSync, DashboardLoadedEvent, DashboardLoadedEventPayload, DashboardProps, DashboardVariableModel, DataConfigSource, DataContextScopedVar, DataFrame, DataFrameDTO, DataFrameData, DataFrameFieldIndex, DataFrameJSON, DataFrameSchema, DataFrameType, DataFrameView, DataHoverClearEvent, DataHoverEvent, DataHoverPayload, DataLink, DataLinkBuiltInVars, DataLinkClickEvent, DataLinkConfigOrigin, DataLinkTransformationConfig, DataLinksFieldConfigSettings, DataQuery, DataQueryError, DataQueryErrorType, DataQueryRequest, DataQueryResponse, DataQueryResponseData, DataQueryTimings, DataSelectEvent, DataSourceApi, DataSourceConstructor, DataSourceInstanceSettings, DataSourceJsonData, DataSourceOptionsType, DataSourcePlugin, DataSourcePluginComponents, DataSourcePluginContextProvider, DataSourcePluginContextProviderProps, DataSourcePluginContextType, DataSourcePluginMeta, DataSourcePluginOptionsEditorProps, DataSourceQueryType, DataSourceRef, DataSourceSelectItem, DataSourceSettings, DataSourceVariableModel, DataSourceVariableSupport, DataSourceWithLogsContextSupport, DataSourceWithLogsVolumeSupport, DataSourceWithQueryExportSupport, DataSourceWithQueryImportSupport, DataSourceWithSupplementaryQueriesSupport, DataTopic, DataTransformContext, DataTransformerID, DataTransformerInfo, DateTime, DateTimeBuiltinFormat, DateTimeDuration, DateTimeInput, DateTimeLocale, DateTimeOptions, DateTimeOptionsWhenParsing, DateTimeOptionsWithFormat, DecimalCount, DecimalInfo, DefaultTimeZone, Dimension, Dimensions, Dimensions2D, DisplayProcessor, DisplayValue, DisplayValueAlignmentFactors, DocsId, DurationInput, DurationUnit, DynamicConfigValue, EnumFieldConfig, EventBus, EventBusExtended, EventBusSrv, EventFilterOptions, ExploreMode, ExplorePanelsState, ExploreQueryFieldProps, ExploreTracePanelState, ExploreUrlState, FALLBACK_COLOR, FeatureState, FeatureToggles, Field, FieldCache, FieldCalcs, FieldColor, FieldColorConfigSettings, FieldColorMode, FieldColorModeId, FieldColorSeriesByMode, FieldConfig, FieldConfigEditorBuilder, FieldConfigEditorConfig, FieldConfigEditorProps, FieldConfigOptionsRegistry, FieldConfigProperty, FieldConfigPropertyItem, FieldConfigSource, FieldDTO, FieldDisplay, FieldMatcher, FieldMatcherID, FieldMatcherInfo, FieldNamePickerConfigSettings, FieldOverrideContext, FieldOverrideEditorProps, FieldReducerInfo, FieldSchema, FieldSparkline, FieldState, FieldType, FieldTypeConfig, FieldValueEntityLookup, FieldValueMatcherConfig, FieldWithIndex, FlotDataPoint, FormatInput, FormattedValue, FormattedVector, FrameMatcher, FrameMatcherID, FrameMatcherInfo, GAUGE_DEFAULT_MAXIMUM, GAUGE_DEFAULT_MINIMUM, GetFieldDisplayValuesOptions, GrafanaConfig, GrafanaPlugin, GrafanaTheme, GrafanaTheme2, GrafanaThemeCommons, GrafanaThemeType, GraphSeriesValue, GraphSeriesXY, GroupedTimeZones, GroupingToMatrixTransformerOptions, HistogramFields, HistogramTransformerOptions, HistoryItem, ISO_8601, IconName, IndexVector, InternalDataLink, InternalTimeZones, InterpolateFunction, IntervalValues, IntervalVariableModel, KeyValue, Labels, LanguageProvider, LayoutMode, LayoutModes, LegacyEmitter, LegacyEventHandler, LegacyGraphHoverClearEvent, LegacyGraphHoverEvent, LegacyGraphHoverEventPayload, LegacyMappingType, LegacyResponseData, LicenseInfo, LinkModel, LinkModelSupplier, LinkTarget, LiveChannelAddress, LiveChannelConnectionState, LiveChannelEvent, LiveChannelEventType, LiveChannelId, LiveChannelJoinEvent, LiveChannelLeaveEvent, LiveChannelMessageEvent, LiveChannelPresenceStatus, LiveChannelScope, LiveChannelStatusEvent, LiveChannelType, LoadingState, LogLabelStatsModel, LogLevel, LogRowModel, LogSearchMatch, LogsDedupDescription, LogsMetaItem, LogsMetaKind, LogsModel, LogsParser, LogsParsers, LogsVolumeCustomMetaData, LogsVolumeType, MISSING_VALUE, MapLayerHandler, MapLayerRegistryItem, MappingType, MatcherID, MetadataInspectorProps, MetricFindValue, MonacoLanguageRegistryItem, MutableDataFrame, MutableField, MutableVector, NavIndex, NavLinkDTO, NavMenuItemType, NavModel, NavModelBreadcrumb, NavModelItem, NavSection, NewThemeOptions, NodeGraphDataFrameFieldNames, NullValueMode, NumberFieldConfigSettings, NumericRange, OAuth, OAuthSettings, OptionDefaults, OrgProps, OrgRole, OrgVariableModel, PageLayoutType, PanelData, PanelDataSummary, PanelEditorProps, PanelEvents, PanelMenuItem, PanelMigrationHandler, PanelModel, PanelOptionEditorsRegistry, PanelOptionsEditorBuilder, PanelOptionsEditorConfig, PanelOptionsEditorItem, PanelOptionsEditorProps, PanelPlugin, PanelPluginDataSupport, PanelPluginMeta, PanelProps, PanelTypeChangedHandler, PluginBuildInfo, PluginConfigPage, PluginConfigPageProps, PluginContextProvider, PluginContextProviderProps, PluginContextType, PluginDependencies, PluginError, PluginErrorCode, PluginExtension, PluginExtensionConfig, PluginExtensionEventHelpers, PluginExtensionLink, PluginExtensionLinkConfig, PluginExtensionPanelContext, PluginExtensionPoints, PluginExtensionTypes, PluginInclude, PluginIncludeType, PluginMeta, PluginMetaInfo, PluginSignatureStatus, PluginSignatureType, PluginState, PluginType, PreferredVisualisationType, QueryEditorHelpProps, QueryEditorProps, QueryFix, QueryFixAction, QueryHint, QueryResultBase, QueryResultMeta, QueryResultMetaNotice, QueryResultMetaStat, QueryRunner, QueryRunnerOptions, QueryVariableModel, RangeMap, RangeMapOptions, RangeValueMatcherOptions, RawTimeRange, ReadWriteVector, ReduceDataOptions, ReducerID, RegexMap, RegexMapOptions, RegexpOrNamesMatcherOptions, Registry, RegistryItem, RegistryItemWithOptions, RelativeTimeRange, RenameByRegexTransformerOptions, RenderMarkdownOptions, ScopedVar, ScopedVars, ScreenshotInfo, SelectFieldConfigSettings, SelectableValue, SetFieldConfigOptionsArgs, SliderFieldConfigSettings, SliderMarks, SortedVector, SpecialValue, SpecialValueMap, SpecialValueMatch, SpecialValueOptions, SplitOpen, SplitOpenOptions, StandardEditorContext, StandardEditorProps, StandardEditorsRegistryItem, StandardOptionConfig, StandardVariableQuery, StandardVariableSupport, StatsPickerConfigSettings, StringFieldConfigSettings, SupplementaryQueryType, SupportedTransformationTypes, SynchronousDataTransformerInfo, SystemConfigOverrideRule, SystemDateFormatSettings, SystemDateFormatsState, SystemVariable, TIME_FORMAT, TIME_SERIES_METRIC_FIELD_NAME, TIME_SERIES_TIME_FIELD_NAME, TIME_SERIES_VALUE_FIELD_NAME, TableData, TextBoxVariableModel, TextMatch, ThemeBreakpoints, ThemeBreakpointsKey, ThemeColors, ThemeRichColor, ThemeShadows, ThemeShape, ThemeSpacing, ThemeTransitions, ThemeTypography, ThemeTypographyVariant, ThemeVisualizationColors, ThemeVizColor, ThemeVizHue, ThemeZIndices, Threshold, ThresholdsConfig, ThresholdsFieldConfigSettings, ThresholdsMode, TimeFragment, TimeOption, TimeOptions, TimeRange, TimeSeries, TimeSeriesPoints, TimeSeriesValue, TimeZone, TimeZoneBrowser, TimeZoneCountry, TimeZoneInfo, TimeZoneResolver, TimeZoneUtc, TraceKeyValuePair, TraceLog, TraceSpanReference, TraceSpanRow, TransformerRegistryItem, TransformerUIProps, TypedVariableModel, UnitFieldConfigSettings, UrlQueryMap, UrlQueryValue, UserOrgDTO, UserProps, UserVariableModel, VAR_CALC, VAR_CELL_PREFIX, VAR_FIELD_LABELS, VAR_FIELD_NAME, VAR_SERIES_NAME, ValueConverter, ValueFormat, ValueFormatCategory, ValueFormatter, ValueFormatterIndex, ValueLinkConfig, ValueMap, ValueMapping, ValueMappingFieldConfigSettings, ValueMappingResult, ValueMatcher, ValueMatcherID, ValueMatcherInfo, ValueMatcherOptions, VariableHide, VariableModel, VariableOption, VariableOrigin, VariableRefresh, VariableSort, VariableSuggestion, VariableSuggestionsScope, VariableSupportBase, VariableSupportType, VariableType, VariableWithMultiSupport, VariableWithOptions, Vector, VisualizationSuggestion, VisualizationSuggestionScore, VisualizationSuggestionsBuilder, VisualizationSuggestionsListAppender, VisualizationSuggestionsSupplier, VizOrientation, WithAccessControlMetadata, WithLoadingIndicatorOptions, YAxis, addDurationToDate, addLogLevelToSeries, anySeriesWithTimeField, anyToNumber, applyFieldOverrides, applyRawFieldOverrides, arrayUtils_d as arrayUtils, availableIconsIndex, binaryOperators, booleanOverrideProcessor, booleanValueFormatter, buildHistogram, calculateFieldStats, calculateLogsLabelStats, calculateStats, checkLogsError, classicColors, colorManipulator_d as colorManipulator, compareArrayValues, compareDataFrameStructures, convertOldAngularValueMappings, createDimension, createFieldConfigRegistry, createTheme, dataFrameFromJSON, dataFrameToJSON, dataLinksOverrideProcessor, datemath_d as dateMath, dateTime, dateTimeAsMoment, dateTimeForTimeZone, dateTimeFormat, dateTimeFormatISO, dateTimeFormatTimeAgo, dateTimeFormatWithAbbrevation, dateTimeParse, decodeFieldValueEntities, decodeFieldValueEnums, deprecationWarning, displayNameOverrideProcessor, doStandardCalcs, durationToMilliseconds, ensureTimeField, escapeRegex, escapeStringForRegex, escapeUnescapedString, eventFactory, fieldColorModeRegistry, fieldMatchers, fieldReducers, filterFieldConfigOverrides, findCommonLabels, findHighlightChunksInText, findMatchesInText, findUniqueLabels, formatLabels, formattedValueToString, frameMatchers, getActiveThreshold, getAllValuesFromDimension, getColumnFromDimension, getColumnsFromDimension, getDataFrameRow, getDataSourceRef, getDataSourceUID, getDefaultRelativeTimeRange, getDefaultTimeRange, getDimensionByName, getDisplayProcessor, getDisplayValueAlignmentFactors, getEnumDisplayProcessor, getFieldColorMode, getFieldColorModeForField, getFieldConfigWithMinMax, getFieldDisplayName, getFieldDisplayValues, getFieldDisplayValuesProxy, getFieldMatcher, getFieldSeriesColor, getFieldTypeFromValue, getFlotPairs, getFlotPairsConstant, getFrameDisplayName, getFrameMatchers, getHistogramFields, getLinksSupplier, getLocale, getLocaleData, getLogLevel, getLogLevelFromKey, getLogsVolumeAbsoluteRange, getLogsVolumeDataSourceInfo, getMinMaxAndDelta, getPanelOptionsWithDefaults, getParser, getProcessedDataFrames, getRawDisplayProcessor, getScaleCalculator, getSeriesTimeStep, getTimeField, getTimeZone, getTimeZoneGroups, getTimeZoneInfo, getTimeZones, getValueFormat, getValueFormats, getValueFormatterIndex, getValueFromDimension, getValueMatcher, getWeekdayIndex, getWeekdayIndexByEnglishName, guessDecimals, guessFieldTypeForField, guessFieldTypeFromNameAndValue, guessFieldTypeFromValue, guessFieldTypes, hasLinks, hasLogsContextSupport, hasLogsContextUiSupport, hasLogsVolumeSupport, hasMsResolution, hasQueryExportSupport, hasQueryImportSupport, hasSupplementaryQuerySupport, histogramBucketSizes, histogramFieldInfo, histogramFieldsToFrame, histogramFrameBucketMaxFieldName, histogramFrameBucketMinFieldName, histogramTransformer, identityOverrideProcessor, incrRound, incrRoundDn, incrRoundUp, intervalToAbbreviatedDurationString, isBooleanUnit, isCustomFieldProp, isDataFrame, isDataSourcePluginContext, isDataSourceRef, isDateTime, isDateTimeInput, isHistogramFrameBucketMaxFieldName, isHistogramFrameBucketMinFieldName, isIconName, isLiveChannelJoinEvent, isLiveChannelLeaveEvent, isLiveChannelMessageEvent, isLiveChannelStatusEvent, isLogsVolumeLimited, isStandardFieldProp, isSystemOverride, isSystemOverrideWithRef, isTableData, isTimeSeriesFrame, isTimeSeriesFrames, isTruthy, isUnsignedPluginSignature, isValidDate, isValidDuration, isValidGoDuration, isValidLiveChannelAddress, localTimeFormat, locale, locationUtil, makeClassES5Compatible, mapInternalLinkToExplore, matchAllLabels, monacoLanguageRegistry, numberOverrideProcessor, objRemoveUndefined, onUpdateDatasourceJsonDataOption, onUpdateDatasourceJsonDataOptionChecked, onUpdateDatasourceJsonDataOptionSelect, onUpdateDatasourceOption, onUpdateDatasourceResetOption, onUpdateDatasourceSecureJsonDataOption, onUpdateDatasourceSecureJsonDataOptionSelect, joinDataFrames as outerJoinDataFrames, parseDuration, parseFlags, parseLabels, parseLiveChannelAddress, preProcessPanelData, preferredVisualizationTypes, rangeutil_d as rangeUtil, readCSV, reduceField, renderMarkdown, renderTextPanelMarkdown, restoreCustomOverrideRules, reverseDataFrame, roundDecimals, scaledUnits, selectOverrideProcessor, serializeStateToUrlParam, setLocale, setTimeZoneResolver, setWeekStart, shallowCompare, simpleCountUnit, sortDataFrame, sortInAscendingOrder, sortInDescendingOrder, sortLogRows, sortLogsResult, sortThresholds, standardEditorsRegistry, standardFieldConfigEditorRegistry, standardTransformers, standardTransformersRegistry, stringFormater, stringOverrideProcessor, stringStartsAsRegEx, stringToJsRegex, stringToMs, systemDateFormats, textUtil, thresholdsOverrideProcessor, timeZoneAbbrevation, timeZoneFormatUserFriendly, toCSV, toDataFrame, toDataFrameDTO, toDuration, toFilteredDataFrameDTO, toFixed, toFixedScaled, toFixedUnit, toFloatOrUndefined, toIconName, toIntegerOrUndefined, toLegacyResponseData, toLiveChannelId, toNumberString, toOption, toPascalCase, toUtc, transformDataFrame, unEscapeStringFromRegex, unitOverrideProcessor, updateDatasourcePluginJsonDataOption, updateDatasourcePluginOption, updateDatasourcePluginResetOption, updateDatasourcePluginSecureJsonDataOption, urlUtil, useFieldOverrides, usePluginContext, validateFieldConfig, valueMappingsOverrideProcessor, valueMatchers, vectorator, withLoadingIndicator };
