{"version":3,"file":"logs.js","sources":["../../../src/utils/logs.ts"],"sourcesContent":["import { countBy, chain, escapeRegExp } from 'lodash';\n\nimport { DataFrame, FieldType } from '../types/index';\nimport { LogLevel, LogRowModel, LogLabelStatsModel, LogsParser, LogsModel, LogsSortOrder } from '../types/logs';\nimport { ArrayVector } from '../vector/ArrayVector';\n\n// This matches:\n// first a label from start of the string or first white space, then any word chars until \"=\"\n// second either an empty quotes, or anything that starts with quote and ends with unescaped quote,\n// or any non whitespace chars that do not start with quote\nconst LOGFMT_REGEXP = /(?:^|\\s)([\\w\\(\\)\\[\\]\\{\\}]+)=(\"\"|(?:\".*?[^\\\\]\"|[^\"\\s]\\S*))/;\n\n/**\n * Returns the log level of a log line.\n * Parse the line for level words. If no level is found, it returns `LogLevel.unknown`.\n *\n * Example: `getLogLevel('WARN 1999-12-31 this is great') // LogLevel.warn`\n */\n/** @deprecated will be removed in the next major version */\nexport function getLogLevel(line: string): LogLevel {\n  if (!line) {\n    return LogLevel.unknown;\n  }\n  let level = LogLevel.unknown;\n  let currentIndex: number | undefined = undefined;\n\n  for (const key of Object.keys(LogLevel)) {\n    const regexp = new RegExp(`\\\\b${key}\\\\b`, 'i');\n    const result = regexp.exec(line);\n\n    if (result) {\n      if (currentIndex === undefined || result.index < currentIndex) {\n        level = LogLevel[key as keyof typeof LogLevel];\n        currentIndex = result.index;\n      }\n    }\n  }\n  return level;\n}\n\n/** @deprecated will be removed in the next major version */\nexport function getLogLevelFromKey(key: string | number): LogLevel {\n  const level = LogLevel[key.toString().toLowerCase() as keyof typeof LogLevel];\n  if (level) {\n    return level;\n  }\n\n  return LogLevel.unknown;\n}\n\n/** @deprecated will be removed in the next major version */\nexport function addLogLevelToSeries(series: DataFrame, lineIndex: number): DataFrame {\n  const levels = new ArrayVector<LogLevel>();\n  const lines = series.fields[lineIndex];\n  for (let i = 0; i < lines.values.length; i++) {\n    const line = lines.values.get(lineIndex);\n    levels.buffer.push(getLogLevel(line));\n  }\n\n  return {\n    ...series, // Keeps Tags, RefID etc\n    fields: [\n      ...series.fields,\n      {\n        name: 'LogLevel',\n        type: FieldType.string,\n        values: levels,\n        config: {},\n      },\n    ],\n  };\n}\n\n/** @deprecated will be removed in the next major version */\nexport const LogsParsers: { [name: string]: LogsParser } = {\n  JSON: {\n    buildMatcher: (label) => new RegExp(`(?:{|,)\\\\s*\"${label}\"\\\\s*:\\\\s*\"?([\\\\d\\\\.]+|[^\"]*)\"?`),\n    getFields: (line) => {\n      try {\n        const parsed = JSON.parse(line);\n        return Object.keys(parsed).map((key) => {\n          return `\"${key}\":${JSON.stringify(parsed[key])}`;\n        });\n      } catch {}\n      return [];\n    },\n    getLabelFromField: (field) => (field.match(/^\"([^\"]+)\"\\s*:/) || [])[1],\n    getValueFromField: (field) => (field.match(/:\\s*(.*)$/) || [])[1],\n    test: (line) => {\n      let parsed;\n      try {\n        parsed = JSON.parse(line);\n      } catch (error) {}\n      // The JSON parser should only be used for log lines that are valid serialized JSON objects.\n      // If it would be used for a string, detected fields would include each letter as a separate field.\n      return typeof parsed === 'object';\n    },\n  },\n\n  logfmt: {\n    buildMatcher: (label) => new RegExp(`(?:^|\\\\s)${escapeRegExp(label)}=(\"[^\"]*\"|\\\\S+)`),\n    getFields: (line) => {\n      const fields: string[] = [];\n      line.replace(new RegExp(LOGFMT_REGEXP, 'g'), (substring) => {\n        fields.push(substring.trim());\n        return '';\n      });\n      return fields;\n    },\n    getLabelFromField: (field) => (field.match(LOGFMT_REGEXP) || [])[1],\n    getValueFromField: (field) => (field.match(LOGFMT_REGEXP) || [])[2],\n    test: (line) => LOGFMT_REGEXP.test(line),\n  },\n};\n\n/** @deprecated will be removed in the next major version */\nexport function calculateFieldStats(rows: LogRowModel[], extractor: RegExp): LogLabelStatsModel[] {\n  // Consider only rows that satisfy the matcher\n  const rowsWithField = rows.filter((row) => extractor.test(row.entry));\n  const rowCount = rowsWithField.length;\n\n  // Get field value counts for eligible rows\n  const countsByValue = countBy(rowsWithField, (r) => {\n    const row: LogRowModel = r;\n    const match = row.entry.match(extractor);\n\n    return match ? match[1] : null;\n  });\n  return getSortedCounts(countsByValue, rowCount);\n}\n\n/** @deprecated will be removed in the next major version */\nexport function calculateLogsLabelStats(rows: LogRowModel[], label: string): LogLabelStatsModel[] {\n  // Consider only rows that have the given label\n  const rowsWithLabel = rows.filter((row) => row.labels[label] !== undefined);\n  const rowCount = rowsWithLabel.length;\n\n  // Get label value counts for eligible rows\n  const countsByValue = countBy(rowsWithLabel, (row) => row.labels[label]);\n  return getSortedCounts(countsByValue, rowCount);\n}\n\n/** @deprecated will be removed in the next major version */\nexport function calculateStats(values: unknown[]): LogLabelStatsModel[] {\n  const nonEmptyValues = values.filter((value) => value !== undefined && value !== null);\n  const countsByValue = countBy(nonEmptyValues);\n  return getSortedCounts(countsByValue, nonEmptyValues.length);\n}\n\nconst getSortedCounts = (countsByValue: { [value: string]: number }, rowCount: number) => {\n  return chain(countsByValue)\n    .map((count, value) => ({ count, value, proportion: count / rowCount }))\n    .sortBy('count')\n    .reverse()\n    .value();\n};\n\n/** @deprecated will be removed in the next major version */\nexport function getParser(line: string): LogsParser | undefined {\n  let parser;\n  try {\n    if (LogsParsers.JSON.test(line)) {\n      parser = LogsParsers.JSON;\n    }\n  } catch (error) {}\n\n  if (!parser && LogsParsers.logfmt.test(line)) {\n    parser = LogsParsers.logfmt;\n  }\n\n  return parser;\n}\n\n/** @deprecated will be removed in the next major version */\nexport const sortInAscendingOrder = (a: LogRowModel, b: LogRowModel) => {\n  // compare milliseconds\n  if (a.timeEpochMs < b.timeEpochMs) {\n    return -1;\n  }\n\n  if (a.timeEpochMs > b.timeEpochMs) {\n    return 1;\n  }\n\n  // if milliseconds are equal, compare nanoseconds\n  if (a.timeEpochNs < b.timeEpochNs) {\n    return -1;\n  }\n\n  if (a.timeEpochNs > b.timeEpochNs) {\n    return 1;\n  }\n\n  return 0;\n};\n\n/** @deprecated will be removed in the next major version */\nexport const sortInDescendingOrder = (a: LogRowModel, b: LogRowModel) => {\n  // compare milliseconds\n  if (a.timeEpochMs > b.timeEpochMs) {\n    return -1;\n  }\n\n  if (a.timeEpochMs < b.timeEpochMs) {\n    return 1;\n  }\n\n  // if milliseconds are equal, compare nanoseconds\n  if (a.timeEpochNs > b.timeEpochNs) {\n    return -1;\n  }\n\n  if (a.timeEpochNs < b.timeEpochNs) {\n    return 1;\n  }\n\n  return 0;\n};\n\n/** @deprecated will be removed in the next major version */\nexport const sortLogsResult = (logsResult: LogsModel | null, sortOrder: LogsSortOrder): LogsModel => {\n  const rows = logsResult ? sortLogRows(logsResult.rows, sortOrder) : [];\n  return logsResult ? { ...logsResult, rows } : { hasUniqueLabels: false, rows };\n};\n\n/** @deprecated will be removed in the next major version */\nexport const sortLogRows = (logRows: LogRowModel[], sortOrder: LogsSortOrder) =>\n  sortOrder === LogsSortOrder.Ascending ? logRows.sort(sortInAscendingOrder) : logRows.sort(sortInDescendingOrder);\n\n// Currently supports only error condition in Loki logs\n/** @deprecated will be removed in the next major version */\nexport const checkLogsError = (logRow: LogRowModel): { hasError: boolean; errorMessage?: string } => {\n  if (logRow.labels.__error__) {\n    return {\n      hasError: true,\n      errorMessage: logRow.labels.__error__,\n    };\n  }\n  return {\n    hasError: false,\n  };\n};\n\n/** @deprecated will be removed in the next major version */\nexport const escapeUnescapedString = (string: string) =>\n  string.replace(/\\\\r\\\\n|\\\\n|\\\\t|\\\\r/g, (match: string) => (match.slice(1) === 't' ? '\\t' : '\\n'));\n"],"names":[],"mappings":"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"}