{"version":3,"file":"processDataFrame.js","sources":["../../../src/dataframe/processDataFrame.ts"],"sourcesContent":["// Libraries\nimport { isArray, isBoolean, isNumber, isString } from 'lodash';\n\n// Types\nimport { isDateTime } from '../datetime/moment_wrapper';\nimport { fieldIndexComparer } from '../field/fieldComparers';\nimport { getFieldDisplayName } from '../field/fieldState';\nimport {\n  DataFrame,\n  Field,\n  FieldConfig,\n  TimeSeries,\n  FieldType,\n  TableData,\n  Column,\n  GraphSeriesXY,\n  TimeSeriesValue,\n  FieldDTO,\n  DataFrameDTO,\n  TIME_SERIES_VALUE_FIELD_NAME,\n  TIME_SERIES_TIME_FIELD_NAME,\n  DataQueryResponseData,\n  PanelData,\n  LoadingState,\n} from '../types/index';\nimport { ArrayVector } from '../vector/ArrayVector';\nimport { SortedVector } from '../vector/SortedVector';\nimport { vectorToArray } from '../vector/vectorToArray';\n\nimport { ArrayDataFrame } from './ArrayDataFrame';\nimport { dataFrameFromJSON } from './DataFrameJSON';\nimport { MutableDataFrame } from './MutableDataFrame';\n\nfunction convertTableToDataFrame(table: TableData): DataFrame {\n  const fields = table.columns.map((c) => {\n    // TODO: should be Column but type does not exists there so not sure whats up here.\n    const { text, type, ...disp } = c as any;\n    return {\n      name: text?.length ? text : c, // rename 'text' to the 'name' field\n      config: (disp || {}) as FieldConfig,\n      values: new ArrayVector(),\n      type: type && Object.values(FieldType).includes(type as FieldType) ? (type as FieldType) : FieldType.other,\n    };\n  });\n\n  if (!isArray(table.rows)) {\n    throw new Error(`Expected table rows to be array, got ${typeof table.rows}.`);\n  }\n\n  for (const row of table.rows) {\n    for (let i = 0; i < fields.length; i++) {\n      fields[i].values.buffer.push(row[i]);\n    }\n  }\n\n  for (const f of fields) {\n    if (f.type === FieldType.other) {\n      const t = guessFieldTypeForField(f);\n      if (t) {\n        f.type = t;\n      }\n    }\n  }\n\n  return {\n    fields,\n    refId: table.refId,\n    meta: table.meta,\n    name: table.name,\n    length: table.rows.length,\n  };\n}\n\nfunction convertTimeSeriesToDataFrame(timeSeries: TimeSeries): DataFrame {\n  const times: number[] = [];\n  const values: TimeSeriesValue[] = [];\n\n  // Sometimes the points are sent as datapoints\n  const points = timeSeries.datapoints || (timeSeries as any).points;\n  for (const point of points) {\n    values.push(point[0]);\n    times.push(point[1] as number);\n  }\n\n  const fields = [\n    {\n      name: TIME_SERIES_TIME_FIELD_NAME,\n      type: FieldType.time,\n      config: {},\n      values: new ArrayVector<number>(times),\n    },\n    {\n      name: TIME_SERIES_VALUE_FIELD_NAME,\n      type: FieldType.number,\n      config: {\n        unit: timeSeries.unit,\n      },\n      values: new ArrayVector<TimeSeriesValue>(values),\n      labels: timeSeries.tags,\n    },\n  ];\n\n  if (timeSeries.title) {\n    (fields[1].config as FieldConfig).displayNameFromDS = timeSeries.title;\n  }\n\n  return {\n    name: timeSeries.target || (timeSeries as any).name,\n    refId: timeSeries.refId,\n    meta: timeSeries.meta,\n    fields,\n    length: values.length,\n  };\n}\n\n/**\n * This is added temporarily while we convert the LogsModel\n * to DataFrame.  See: https://github.com/grafana/grafana/issues/18528\n */\nfunction convertGraphSeriesToDataFrame(graphSeries: GraphSeriesXY): DataFrame {\n  const x = new ArrayVector();\n  const y = new ArrayVector();\n\n  for (let i = 0; i < graphSeries.data.length; i++) {\n    const row = graphSeries.data[i];\n    x.buffer.push(row[1]);\n    y.buffer.push(row[0]);\n  }\n\n  return {\n    name: graphSeries.label,\n    fields: [\n      {\n        name: graphSeries.label || TIME_SERIES_VALUE_FIELD_NAME,\n        type: FieldType.number,\n        config: {},\n        values: x,\n      },\n      {\n        name: TIME_SERIES_TIME_FIELD_NAME,\n        type: FieldType.time,\n        config: {\n          unit: 'dateTimeAsIso',\n        },\n        values: y,\n      },\n    ],\n    length: x.buffer.length,\n  };\n}\n\nfunction convertJSONDocumentDataToDataFrame(timeSeries: TimeSeries): DataFrame {\n  const fields = [\n    {\n      name: timeSeries.target,\n      type: FieldType.other,\n      labels: timeSeries.tags,\n      config: {\n        unit: timeSeries.unit,\n        filterable: (timeSeries as any).filterable,\n      },\n      values: new ArrayVector(),\n    },\n  ];\n\n  for (const point of timeSeries.datapoints) {\n    fields[0].values.buffer.push(point);\n  }\n\n  return {\n    name: timeSeries.target,\n    refId: timeSeries.target,\n    meta: { json: true },\n    fields,\n    length: timeSeries.datapoints.length,\n  };\n}\n\n// PapaParse Dynamic Typing regex:\n// https://github.com/mholt/PapaParse/blob/master/papaparse.js#L998\nconst NUMBER = /^\\s*(-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?|NAN)\\s*$/i;\n\n/**\n * Given a name and value, this will pick a reasonable field type\n */\nexport function guessFieldTypeFromNameAndValue(name: string, v: unknown): FieldType {\n  if (name) {\n    name = name.toLowerCase();\n    if (name === 'date' || name === 'time') {\n      return FieldType.time;\n    }\n  }\n  return guessFieldTypeFromValue(v);\n}\n\n/**\n * Check the field type to see what the contents are\n */\nexport function getFieldTypeFromValue(v: unknown): FieldType {\n  if (v instanceof Date || isDateTime(v)) {\n    return FieldType.time;\n  }\n\n  if (isNumber(v)) {\n    return FieldType.number;\n  }\n\n  if (isString(v)) {\n    return FieldType.string;\n  }\n\n  if (isBoolean(v)) {\n    return FieldType.boolean;\n  }\n\n  return FieldType.other;\n}\n\n/**\n * Given a value this will guess the best column type\n *\n * NOTE: this is will try to see if string values can be mapped to other types (like number)\n */\nexport function guessFieldTypeFromValue(v: unknown): FieldType {\n  if (v instanceof Date || isDateTime(v)) {\n    return FieldType.time;\n  }\n\n  if (isNumber(v)) {\n    return FieldType.number;\n  }\n\n  if (isString(v)) {\n    if (NUMBER.test(v)) {\n      return FieldType.number;\n    }\n\n    if (v === 'true' || v === 'TRUE' || v === 'True' || v === 'false' || v === 'FALSE' || v === 'False') {\n      return FieldType.boolean;\n    }\n\n    return FieldType.string;\n  }\n\n  if (isBoolean(v)) {\n    return FieldType.boolean;\n  }\n\n  return FieldType.other;\n}\n\n/**\n * Looks at the data to guess the column type.  This ignores any existing setting\n */\nexport function guessFieldTypeForField(field: Field): FieldType | undefined {\n  // 1. Use the column name to guess\n  if (field.name) {\n    const name = field.name.toLowerCase();\n    if (name === 'date' || name === 'time') {\n      return FieldType.time;\n    }\n  }\n\n  // 2. Check the first non-null value\n  for (let i = 0; i < field.values.length; i++) {\n    const v = field.values.get(i);\n    if (v != null) {\n      return guessFieldTypeFromValue(v);\n    }\n  }\n\n  // Could not find anything\n  return undefined;\n}\n\n/**\n * @returns A copy of the series with the best guess for each field type.\n * If the series already has field types defined, they will be used, unless `guessDefined` is true.\n * @param series The DataFrame whose field's types should be guessed\n * @param guessDefined Whether to guess types of fields with already defined types\n */\nexport const guessFieldTypes = (series: DataFrame, guessDefined = false): DataFrame => {\n  for (const field of series.fields) {\n    if (!field.type || field.type === FieldType.other || guessDefined) {\n      // Something is missing a type, return a modified copy\n      return {\n        ...series,\n        fields: series.fields.map((field) => {\n          if (field.type && field.type !== FieldType.other && !guessDefined) {\n            return field;\n          }\n          // Calculate a reasonable schema value\n          return {\n            ...field,\n            type: guessFieldTypeForField(field) || FieldType.other,\n          };\n        }),\n      };\n    }\n  }\n  // No changes necessary\n  return series;\n};\n\nexport const isTableData = (data: unknown): data is DataFrame => Boolean(data && data.hasOwnProperty('columns'));\n\nexport const isDataFrame = (data: unknown): data is DataFrame => Boolean(data && data.hasOwnProperty('fields'));\n\n/**\n * Inspect any object and return the results as a DataFrame\n */\nexport function toDataFrame(data: any): DataFrame {\n  if ('fields' in data) {\n    // DataFrameDTO does not have length\n    if ('length' in data && data.fields[0]?.values?.get) {\n      return data as DataFrame;\n    }\n\n    // This will convert the array values into Vectors\n    return new MutableDataFrame(data as DataFrameDTO);\n  }\n\n  // Handle legacy docs/json type\n  if (data.hasOwnProperty('type') && data.type === 'docs') {\n    return convertJSONDocumentDataToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('datapoints') || data.hasOwnProperty('points')) {\n    return convertTimeSeriesToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('data')) {\n    if (data.hasOwnProperty('schema')) {\n      return dataFrameFromJSON(data);\n    }\n    return convertGraphSeriesToDataFrame(data);\n  }\n\n  if (data.hasOwnProperty('columns')) {\n    return convertTableToDataFrame(data);\n  }\n\n  if (Array.isArray(data)) {\n    return new ArrayDataFrame(data);\n  }\n\n  console.warn('Can not convert', data);\n  throw new Error('Unsupported data format');\n}\n\nexport const toLegacyResponseData = (frame: DataFrame): TimeSeries | TableData => {\n  const { fields } = frame;\n\n  const rowCount = frame.length;\n  const rows: any[][] = [];\n\n  if (fields.length === 2) {\n    const { timeField, timeIndex } = getTimeField(frame);\n    if (timeField) {\n      const valueIndex = timeIndex === 0 ? 1 : 0;\n      const valueField = fields[valueIndex];\n      const timeField = fields[timeIndex!];\n\n      // Make sure it is [value,time]\n      for (let i = 0; i < rowCount; i++) {\n        rows.push([\n          valueField.values.get(i), // value\n          timeField.values.get(i), // time\n        ]);\n      }\n\n      return {\n        alias: frame.name,\n        target: getFieldDisplayName(valueField, frame),\n        datapoints: rows,\n        unit: fields[0].config ? fields[0].config.unit : undefined,\n        refId: frame.refId,\n        meta: frame.meta,\n      } as TimeSeries;\n    }\n  }\n\n  for (let i = 0; i < rowCount; i++) {\n    const row: any[] = [];\n    for (let j = 0; j < fields.length; j++) {\n      row.push(fields[j].values.get(i));\n    }\n    rows.push(row);\n  }\n\n  if (frame.meta && frame.meta.json) {\n    return {\n      alias: fields[0].name || frame.name,\n      target: fields[0].name || frame.name,\n      datapoints: fields[0].values.toArray(),\n      filterable: fields[0].config ? fields[0].config.filterable : undefined,\n      type: 'docs',\n    } as TimeSeries;\n  }\n\n  return {\n    columns: fields.map((f) => {\n      const { name, config } = f;\n      if (config) {\n        // keep unit etc\n        const { ...column } = config;\n        (column as Column).text = name;\n        return column as Column;\n      }\n      return { text: name };\n    }),\n    type: 'table',\n    refId: frame.refId,\n    meta: frame.meta,\n    rows,\n  };\n};\n\nexport function sortDataFrame(data: DataFrame, sortIndex?: number, reverse = false): DataFrame {\n  const field = data.fields[sortIndex!];\n  if (!field) {\n    return data;\n  }\n\n  // Natural order\n  const index: number[] = [];\n  for (let i = 0; i < data.length; i++) {\n    index.push(i);\n  }\n\n  const fieldComparer = fieldIndexComparer(field, reverse);\n  index.sort(fieldComparer);\n\n  return {\n    ...data,\n    fields: data.fields.map((f) => {\n      return {\n        ...f,\n        values: new SortedVector(f.values, index),\n      };\n    }),\n  };\n}\n\n/**\n * Returns a copy with all values reversed\n */\nexport function reverseDataFrame(data: DataFrame): DataFrame {\n  return {\n    ...data,\n    fields: data.fields.map((f) => {\n      const copy = [...f.values.toArray()];\n      copy.reverse();\n      return {\n        ...f,\n        values: new ArrayVector(copy),\n      };\n    }),\n  };\n}\n\n/**\n * Wrapper to get an array from each field value\n */\nexport function getDataFrameRow(data: DataFrame, row: number): any[] {\n  const values: any[] = [];\n  for (const field of data.fields) {\n    values.push(field.values.get(row));\n  }\n  return values;\n}\n\n/**\n * Returns a copy that does not include functions\n */\nexport function toDataFrameDTO(data: DataFrame): DataFrameDTO {\n  return toFilteredDataFrameDTO(data);\n}\n\nexport function toFilteredDataFrameDTO(data: DataFrame, fieldPredicate?: (f: Field) => boolean): DataFrameDTO {\n  const filteredFields = fieldPredicate ? data.fields.filter(fieldPredicate) : data.fields;\n  const fields: FieldDTO[] = filteredFields.map((f) => {\n    let values = f.values.toArray();\n    // The byte buffers serialize like objects\n    if (values instanceof Float64Array) {\n      values = vectorToArray(f.values);\n    }\n    return {\n      name: f.name,\n      type: f.type,\n      config: f.config,\n      values,\n      labels: f.labels,\n    };\n  });\n\n  return {\n    fields,\n    refId: data.refId,\n    meta: data.meta,\n    name: data.name,\n  };\n}\n\nexport const getTimeField = (series: DataFrame): { timeField?: Field; timeIndex?: number } => {\n  for (let i = 0; i < series.fields.length; i++) {\n    if (series.fields[i].type === FieldType.time) {\n      return {\n        timeField: series.fields[i],\n        timeIndex: i,\n      };\n    }\n  }\n  return {};\n};\n\nfunction getProcessedDataFrame(data: DataQueryResponseData): DataFrame {\n  const dataFrame = guessFieldTypes(toDataFrame(data));\n\n  if (dataFrame.fields && dataFrame.fields.length) {\n    // clear out the cached info\n    for (const field of dataFrame.fields) {\n      field.state = null;\n    }\n  }\n\n  return dataFrame;\n}\n\n/**\n * Given data request results, will return data frames with field types set\n *\n * This is also used by PanelChrome for snapshot support\n */\nexport function getProcessedDataFrames(results?: DataQueryResponseData[]): DataFrame[] {\n  if (!results || !isArray(results)) {\n    return [];\n  }\n\n  return results.map((data) => getProcessedDataFrame(data));\n}\n\n/**\n * Will process the panel data frames and in case of loading state with no data, will return the last result data but with loading state\n * This is to have panels not flicker temporarily with \"no data\" while loading\n */\nexport function preProcessPanelData(data: PanelData, lastResult?: PanelData): PanelData {\n  const { series, annotations } = data;\n\n  //  for loading states with no data, use last result\n  if (data.state === LoadingState.Loading && series.length === 0) {\n    if (!lastResult) {\n      lastResult = data;\n    }\n\n    return {\n      ...lastResult,\n      state: LoadingState.Loading,\n      request: data.request,\n    };\n  }\n\n  // Make sure the data frames are properly formatted\n  const STARTTIME = performance.now();\n  const processedDataFrames = series.map((data) => getProcessedDataFrame(data));\n  const annotationsProcessed = getProcessedDataFrames(annotations);\n  const STOPTIME = performance.now();\n\n  return {\n    ...data,\n    series: processedDataFrames,\n    annotations: annotationsProcessed,\n    timings: { dataProcessingTime: STOPTIME - STARTTIME },\n  };\n}\n"],"names":["field","timeField","data"],"mappings":"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"}