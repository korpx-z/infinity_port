{"version":3,"file":"DataFrameJSON.js","sources":["../../../src/dataframe/DataFrameJSON.ts"],"sourcesContent":["import { DataFrame, FieldType, FieldConfig, Labels, QueryResultMeta } from '../types';\nimport { ArrayVector } from '../vector';\n\nimport { guessFieldTypeFromNameAndValue } from './processDataFrame';\n\n/**\n * The JSON transfer object for DataFrames.  Values are stored in simple JSON\n *\n * @alpha\n */\nexport interface DataFrameJSON {\n  /**\n   * The schema defines the field type and configuration.\n   */\n  schema?: DataFrameSchema;\n\n  /**\n   * The field data\n   */\n  data?: DataFrameData;\n}\n\ntype FieldValues = unknown[];\n\n/**\n * @alpha\n */\nexport interface DataFrameData {\n  /**\n   * A columnar store that matches fields defined by schema.\n   */\n  values: FieldValues[];\n\n  /**\n   * Since JSON cannot encode NaN, Inf, -Inf, and undefined, these entities\n   * are decoded after JSON.parse() using this struct\n   */\n  entities?: Array<FieldValueEntityLookup | null>;\n\n  /**\n   * Holds value bases per field so we can encode numbers from fixed points\n   * e.g. [1612900958, 1612900959, 1612900960] -> 1612900958 + [0, 1, 2]\n   */\n  bases?: number[];\n\n  /**\n   * Holds value multipliers per field so we can encode large numbers concisely\n   * e.g. [4900000000, 35000000000] -> 1e9 + [4.9, 35]\n   */\n  factors?: number[];\n\n  /**\n   * Holds enums per field so we can encode recurring string values as ints\n   * e.g. [\"foo\", \"foo\", \"baz\", \"foo\"] -> [\"foo\", \"baz\"] + [0,0,1,0]\n   *\n   * NOTE: currently only decoding is implemented\n   */\n  enums?: Array<string[] | null>;\n}\n\n/**\n * The JSON transfer object for DataFrames.  Values are stored in simple JSON\n *\n * @alpha\n */\nexport interface DataFrameSchema {\n  /**\n   * Matches the query target refId\n   */\n  refId?: string;\n\n  /**\n   * Initial response global metadata\n   */\n  meta?: QueryResultMeta;\n\n  /**\n   * Frame name\n   */\n  name?: string;\n\n  /**\n   * Field definition without any metadata\n   */\n  fields: FieldSchema[];\n}\n\n/**\n * Field object passed over JSON\n *\n * @alpha\n */\nexport interface FieldSchema {\n  name: string; // The column name\n  type?: FieldType;\n  config?: FieldConfig;\n  labels?: Labels;\n}\n\n/**\n * Since JSON cannot encode NaN, Inf, -Inf, and undefined, the locations\n * of these entities in field value arrays are stored here for restoration\n * after JSON.parse()\n *\n * @alpha\n */\nexport interface FieldValueEntityLookup {\n  NaN?: number[];\n  Undef?: number[]; // Missing because of absence or join\n  Inf?: number[];\n  NegInf?: number[];\n}\n\nconst ENTITY_MAP: Record<keyof FieldValueEntityLookup, number | undefined> = {\n  Inf: Infinity,\n  NegInf: -Infinity,\n  Undef: undefined,\n  NaN: NaN,\n};\n\n/**\n * @internal use locally\n */\nexport function decodeFieldValueEntities(lookup: FieldValueEntityLookup, values: FieldValues) {\n  for (const key in lookup) {\n    const repl = ENTITY_MAP[key as keyof FieldValueEntityLookup];\n    for (const idx of lookup[key as keyof FieldValueEntityLookup]!) {\n      if (idx < values.length) {\n        values[idx] = repl;\n      }\n    }\n  }\n}\n\n/**\n * @internal use locally\n */\nexport function decodeFieldValueEnums(lookup: string[], values: FieldValues) {\n  for (let i = 0; i < values.length; i++) {\n    values[i] = lookup[values[i] as number];\n  }\n}\n\nfunction guessFieldType(name: string, values: FieldValues): FieldType {\n  for (const v of values) {\n    if (v != null) {\n      return guessFieldTypeFromNameAndValue(name, v);\n    }\n  }\n  return FieldType.other;\n}\n\n/**\n * NOTE: dto.data.values will be mutated and decoded/inflated using entities,bases,factors,enums\n *\n * @alpha\n */\nexport function dataFrameFromJSON(dto: DataFrameJSON): DataFrame {\n  const { schema, data } = dto;\n\n  if (!schema || !schema.fields) {\n    throw new Error('JSON needs a fields definition');\n  }\n\n  // Find the longest field length\n  const length = data ? data.values.reduce((max, vals) => Math.max(max, vals.length), 0) : 0;\n  const fields = schema.fields.map((f, index) => {\n    let buffer = data ? data.values[index] : [];\n    let origLen = buffer.length;\n    let type = f.type;\n\n    if (origLen !== length) {\n      buffer.length = length;\n      // avoid sparse arrays\n      buffer.fill(undefined, origLen);\n    }\n\n    let entities = data?.entities?.[index];\n\n    if (entities) {\n      decodeFieldValueEntities(entities, buffer);\n    }\n\n    let enums = data?.enums?.[index];\n\n    if (enums) {\n      decodeFieldValueEnums(enums, buffer);\n      type = FieldType.string;\n    }\n\n    // TODO: expand arrays further using bases,factors\n\n    return {\n      ...f,\n      type: type ?? guessFieldType(f.name, buffer),\n      config: f.config ?? {},\n      values: new ArrayVector(buffer),\n      // the presence of this prop is an optimization signal & lookup for consumers\n      entities: entities ?? {},\n    };\n  });\n\n  return {\n    ...schema,\n    fields,\n    length,\n  };\n}\n\n/**\n * This converts DataFrame to a json representation with distinct schema+data\n *\n * @alpha\n */\nexport function dataFrameToJSON(frame: DataFrame): DataFrameJSON {\n  const data: DataFrameData = {\n    values: [],\n  };\n  const schema: DataFrameSchema = {\n    refId: frame.refId,\n    meta: frame.meta,\n    name: frame.name,\n    fields: frame.fields.map((f) => {\n      const { values, state, display, ...sfield } = f;\n      delete (sfield as any).entities;\n      data.values.push(values.toArray());\n      return sfield;\n    }),\n  };\n\n  return {\n    schema,\n    data,\n  };\n}\n"],"names":[],"mappings":"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"}