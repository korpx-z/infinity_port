{"version":3,"file":"fieldOverrides.js","sources":["../../../src/types/fieldOverrides.ts"],"sourcesContent":["import { ComponentType } from 'react';\n\nimport { StandardEditorProps, FieldConfigOptionsRegistry, StandardEditorContext } from '../field';\nimport { GrafanaTheme2 } from '../themes';\nimport { MatcherConfig, FieldConfig, Field, DataFrame, TimeZone } from '../types';\n\nimport { OptionsEditorItem } from './OptionsUIRegistryBuilder';\nimport { OptionEditorConfig } from './options';\nimport { InterpolateFunction } from './panel';\n\nexport interface DynamicConfigValue {\n  id: string;\n  value?: any;\n}\n\nexport interface ConfigOverrideRule {\n  matcher: MatcherConfig;\n  properties: DynamicConfigValue[];\n}\n\n/**\n * Describes config override rules created when interacting with Grafana.\n *\n * @internal\n */\nexport interface SystemConfigOverrideRule extends ConfigOverrideRule {\n  __systemRef: string;\n}\n\n/**\n * Guard functionality to check if an override rule is of type {@link SystemConfigOverrideRule}.\n * It will only return true if the {@link SystemConfigOverrideRule} has the passed systemRef.\n *\n * @param ref system override reference\n * @internal\n */\nexport function isSystemOverrideWithRef<T extends SystemConfigOverrideRule>(ref: string) {\n  return (override: ConfigOverrideRule): override is T => {\n    const overrideAs = override as T;\n    return overrideAs.__systemRef === ref;\n  };\n}\n\n/**\n * Guard functionality to check if an override rule is of type {@link SystemConfigOverrideRule}.\n * It will return true if the {@link SystemConfigOverrideRule} has any systemRef set.\n *\n * @internal\n */\nexport const isSystemOverride = (override: ConfigOverrideRule): override is SystemConfigOverrideRule => {\n  return typeof (override as SystemConfigOverrideRule)?.__systemRef === 'string';\n};\n\nexport interface FieldConfigSource<TOptions = any> {\n  // Defaults applied to all numeric fields\n  defaults: FieldConfig<TOptions>;\n\n  // Rules to override individual values\n  overrides: ConfigOverrideRule[];\n}\n\nexport interface FieldOverrideContext extends StandardEditorContext<any, any> {\n  field?: Field;\n  dataFrameIndex?: number; // The index for the selected field frame\n}\nexport interface FieldConfigEditorProps<TValue, TSettings extends {}>\n  extends Omit<StandardEditorProps<TValue, TSettings>, 'item'> {\n  item: FieldConfigPropertyItem<any, TValue, TSettings>; // The property info\n  value: TValue;\n  context: FieldOverrideContext;\n  onChange: (value?: TValue) => void;\n}\n\nexport interface FieldOverrideEditorProps<TValue, TSettings> extends Omit<StandardEditorProps<TValue>, 'item'> {\n  item: FieldConfigPropertyItem<TValue, TSettings>;\n  context: FieldOverrideContext;\n}\n\nexport interface FieldConfigEditorConfig<TOptions, TSettings = any, TValue = any>\n  extends OptionEditorConfig<TOptions, TSettings, TValue> {\n  /**\n   * Function that allows specifying whether or not this field config should apply to a given field.\n   * @param field\n   */\n  shouldApply?: (field: Field) => boolean;\n\n  /** Indicates that option shoukd not be available in the Field config tab */\n  hideFromDefaults?: boolean;\n\n  /** Indicates that option should not be available for the overrides */\n  hideFromOverrides?: boolean;\n}\n\nexport interface FieldConfigPropertyItem<TOptions = any, TValue = any, TSettings extends {} = any>\n  extends OptionsEditorItem<TOptions, TSettings, FieldConfigEditorProps<TValue, TSettings>, TValue> {\n  // An editor that can be filled in with context info (template variables etc)\n  override: ComponentType<FieldOverrideEditorProps<TValue, TSettings>>;\n\n  /** true for plugin field config properties */\n  isCustom?: boolean;\n\n  /** Hides option from the Field config tab */\n  hideFromDefaults?: boolean;\n\n  /** Indicates that option should not be available for the overrides */\n  hideFromOverrides?: boolean;\n\n  /** Convert the override value to a well typed value */\n  process: (value: any, context: FieldOverrideContext, settings?: TSettings) => TValue | undefined | null;\n\n  /** Checks if field should be processed */\n  shouldApply: (field: Field) => boolean;\n}\n\nexport interface ApplyFieldOverrideOptions {\n  data?: DataFrame[];\n  fieldConfig: FieldConfigSource;\n  fieldConfigRegistry?: FieldConfigOptionsRegistry;\n  replaceVariables: InterpolateFunction;\n  theme: GrafanaTheme2;\n  timeZone?: TimeZone;\n}\n\nexport enum FieldConfigProperty {\n  Unit = 'unit',\n  Min = 'min',\n  Max = 'max',\n  Decimals = 'decimals',\n  DisplayName = 'displayName',\n  NoValue = 'noValue',\n  Thresholds = 'thresholds',\n  Mappings = 'mappings',\n  Links = 'links',\n  Color = 'color',\n  Filterable = 'filterable',\n}\n"],"names":["FieldConfigProperty"],"mappings":"AAoCO,SAAS,wBAA4D,GAAa,EAAA;AACvF,EAAA,OAAO,CAAC,QAAgD,KAAA;AACtD,IAAA,MAAM,UAAa,GAAA,QAAA,CAAA;AACnB,IAAA,OAAO,WAAW,WAAgB,KAAA,GAAA,CAAA;AAAA,GACpC,CAAA;AACF,CAAA;AAQa,MAAA,gBAAA,GAAmB,CAAC,QAAuE,KAAA;AACtG,EAAO,OAAA,QAAQ,qCAAuC,WAAgB,CAAA,KAAA,QAAA,CAAA;AACxE,EAAA;AAwEY,IAAA,mBAAA,qBAAAA,oBAAL,KAAA;AACL,EAAAA,qBAAA,MAAO,CAAA,GAAA,MAAA,CAAA;AACP,EAAAA,qBAAA,KAAM,CAAA,GAAA,KAAA,CAAA;AACN,EAAAA,qBAAA,KAAM,CAAA,GAAA,KAAA,CAAA;AACN,EAAAA,qBAAA,UAAW,CAAA,GAAA,UAAA,CAAA;AACX,EAAAA,qBAAA,aAAc,CAAA,GAAA,aAAA,CAAA;AACd,EAAAA,qBAAA,SAAU,CAAA,GAAA,SAAA,CAAA;AACV,EAAAA,qBAAA,YAAa,CAAA,GAAA,YAAA,CAAA;AACb,EAAAA,qBAAA,UAAW,CAAA,GAAA,UAAA,CAAA;AACX,EAAAA,qBAAA,OAAQ,CAAA,GAAA,OAAA,CAAA;AACR,EAAAA,qBAAA,OAAQ,CAAA,GAAA,OAAA,CAAA;AACR,EAAAA,qBAAA,YAAa,CAAA,GAAA,YAAA,CAAA;AAXH,EAAAA,OAAAA,oBAAAA,CAAAA;AAAA,CAAA,EAAA,mBAAA,IAAA,EAAA;;;;"}