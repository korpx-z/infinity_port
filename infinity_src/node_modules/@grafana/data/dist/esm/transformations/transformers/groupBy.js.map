{"version":3,"file":"groupBy.js","sources":["../../../../src/transformations/transformers/groupBy.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { MutableField } from '../../dataframe/MutableDataFrame';\nimport { guessFieldTypeForField } from '../../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../../field/fieldState';\nimport { DataFrame, Field, FieldType } from '../../types/dataFrame';\nimport { DataTransformerInfo } from '../../types/transformations';\nimport { ArrayVector } from '../../vector/ArrayVector';\nimport { reduceField, ReducerID } from '../fieldReducer';\n\nimport { DataTransformerID } from './ids';\n\nexport enum GroupByOperationID {\n  aggregate = 'aggregate',\n  groupBy = 'groupby',\n}\n\nexport interface GroupByFieldOptions {\n  aggregations: ReducerID[];\n  operation: GroupByOperationID | null;\n}\n\nexport interface GroupByTransformerOptions {\n  fields: Record<string, GroupByFieldOptions>;\n}\n\nexport const groupByTransformer: DataTransformerInfo<GroupByTransformerOptions> = {\n  id: DataTransformerID.groupBy,\n  name: 'Group by',\n  description: 'Group the data by a field values then process calculations for each group',\n  defaultOptions: {\n    fields: {},\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        const hasValidConfig = Object.keys(options.fields).find(\n          (name) => options.fields[name].operation === GroupByOperationID.groupBy\n        );\n\n        if (!hasValidConfig) {\n          return data;\n        }\n\n        const processed: DataFrame[] = [];\n\n        for (const frame of data) {\n          const groupByFields: Field[] = [];\n\n          for (const field of frame.fields) {\n            if (shouldGroupOnField(field, options)) {\n              groupByFields.push(field);\n            }\n          }\n\n          if (groupByFields.length === 0) {\n            continue; // No group by field in this frame, ignore the frame\n          }\n\n          // Group the values by fields and groups so we can get all values for a\n          // group for a given field.\n          const valuesByGroupKey = new Map<string, Record<string, MutableField>>();\n          for (let rowIndex = 0; rowIndex < frame.length; rowIndex++) {\n            const groupKey = String(groupByFields.map((field) => field.values.get(rowIndex)));\n            const valuesByField = valuesByGroupKey.get(groupKey) ?? {};\n\n            if (!valuesByGroupKey.has(groupKey)) {\n              valuesByGroupKey.set(groupKey, valuesByField);\n            }\n\n            for (let field of frame.fields) {\n              const fieldName = getFieldDisplayName(field);\n\n              if (!valuesByField[fieldName]) {\n                valuesByField[fieldName] = {\n                  name: fieldName,\n                  type: field.type,\n                  config: { ...field.config },\n                  values: new ArrayVector(),\n                };\n              }\n\n              valuesByField[fieldName].values.add(field.values.get(rowIndex));\n            }\n          }\n\n          const fields: Field[] = [];\n\n          for (const field of groupByFields) {\n            const values = new ArrayVector();\n            const fieldName = getFieldDisplayName(field);\n\n            valuesByGroupKey.forEach((value) => {\n              values.add(value[fieldName].values.get(0));\n            });\n\n            fields.push({\n              name: field.name,\n              type: field.type,\n              config: {\n                ...field.config,\n              },\n              values: values,\n            });\n          }\n\n          // Then for each calculations configured, compute and add a new field (column)\n          for (const field of frame.fields) {\n            if (!shouldCalculateField(field, options)) {\n              continue;\n            }\n\n            const fieldName = getFieldDisplayName(field);\n            const aggregations = options.fields[fieldName].aggregations;\n            const valuesByAggregation: Record<string, any[]> = {};\n\n            valuesByGroupKey.forEach((value) => {\n              const fieldWithValuesForGroup = value[fieldName];\n              const results = reduceField({\n                field: fieldWithValuesForGroup,\n                reducers: aggregations,\n              });\n\n              for (const aggregation of aggregations) {\n                if (!Array.isArray(valuesByAggregation[aggregation])) {\n                  valuesByAggregation[aggregation] = [];\n                }\n                valuesByAggregation[aggregation].push(results[aggregation]);\n              }\n            });\n\n            for (const aggregation of aggregations) {\n              const aggregationField: Field = {\n                name: `${fieldName} (${aggregation})`,\n                values: new ArrayVector(valuesByAggregation[aggregation]),\n                type: FieldType.other,\n                config: {},\n              };\n\n              aggregationField.type = detectFieldType(aggregation, field, aggregationField);\n              fields.push(aggregationField);\n            }\n          }\n\n          processed.push({\n            fields,\n            length: valuesByGroupKey.size,\n          });\n        }\n\n        return processed;\n      })\n    ),\n};\n\nconst shouldGroupOnField = (field: Field, options: GroupByTransformerOptions): boolean => {\n  const fieldName = getFieldDisplayName(field);\n  return options?.fields[fieldName]?.operation === GroupByOperationID.groupBy;\n};\n\nconst shouldCalculateField = (field: Field, options: GroupByTransformerOptions): boolean => {\n  const fieldName = getFieldDisplayName(field);\n  return (\n    options?.fields[fieldName]?.operation === GroupByOperationID.aggregate &&\n    Array.isArray(options?.fields[fieldName].aggregations) &&\n    options?.fields[fieldName].aggregations.length > 0\n  );\n};\n\nconst detectFieldType = (aggregation: string, sourceField: Field, targetField: Field): FieldType => {\n  switch (aggregation) {\n    case ReducerID.allIsNull:\n      return FieldType.boolean;\n    case ReducerID.last:\n    case ReducerID.lastNotNull:\n    case ReducerID.first:\n    case ReducerID.firstNotNull:\n      return sourceField.type;\n    default:\n      return guessFieldTypeForField(targetField) ?? FieldType.string;\n  }\n};\n"],"names":[],"mappings":"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"}