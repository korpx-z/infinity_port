{"version":3,"file":"joinDataFrames.js","sources":["../../../../src/transformations/transformers/joinDataFrames.ts"],"sourcesContent":["import intersect from 'fast_array_intersect';\n\nimport { getTimeField, sortDataFrame } from '../../dataframe';\nimport { DataFrame, Field, FieldMatcher, FieldType, Vector } from '../../types';\nimport { ArrayVector } from '../../vector';\nimport { fieldMatchers } from '../matchers';\nimport { FieldMatcherID } from '../matchers/ids';\n\nimport { JoinMode } from './joinByField';\n\nexport function pickBestJoinField(data: DataFrame[]): FieldMatcher {\n  const { timeField } = getTimeField(data[0]);\n  if (timeField) {\n    return fieldMatchers.get(FieldMatcherID.firstTimeField).get({});\n  }\n  let common: string[] = [];\n  for (const f of data[0].fields) {\n    if (f.type === FieldType.number) {\n      common.push(f.name);\n    }\n  }\n\n  for (let i = 1; i < data.length; i++) {\n    const names: string[] = [];\n    for (const f of data[0].fields) {\n      if (f.type === FieldType.number) {\n        names.push(f.name);\n      }\n    }\n    common = common.filter((v) => !names.includes(v));\n  }\n\n  return fieldMatchers.get(FieldMatcherID.byName).get(common[0]);\n}\n\n/**\n * @internal\n */\nexport interface JoinOptions {\n  /**\n   * The input fields\n   */\n  frames: DataFrame[];\n\n  /**\n   * The field to join -- frames that do not have this field will be droppped\n   */\n  joinBy?: FieldMatcher;\n\n  /**\n   * Optionally filter the non-join fields\n   */\n  keep?: FieldMatcher;\n\n  /**\n   * @internal -- used when we need to keep a reference to the original frame/field index\n   */\n  keepOriginIndices?: boolean;\n\n  /**\n   * @internal -- Optionally specify a join mode (outer or inner)\n   */\n  mode?: JoinMode;\n}\n\nfunction getJoinMatcher(options: JoinOptions): FieldMatcher {\n  return options.joinBy ?? pickBestJoinField(options.frames);\n}\n\n/**\n * @internal\n */\nexport function maybeSortFrame(frame: DataFrame, fieldIdx: number) {\n  if (fieldIdx >= 0) {\n    let sortByField = frame.fields[fieldIdx];\n\n    if (sortByField.type !== FieldType.string && !isLikelyAscendingVector(sortByField.values)) {\n      frame = sortDataFrame(frame, fieldIdx);\n    }\n  }\n\n  return frame;\n}\n\n/**\n * This will return a single frame joined by the first matching field.  When a join field is not specified,\n * the default will use the first time field\n */\nexport function joinDataFrames(options: JoinOptions): DataFrame | undefined {\n  if (!options.frames?.length) {\n    return;\n  }\n\n  if (options.frames.length === 1) {\n    let frame = options.frames[0];\n    let frameCopy = frame;\n\n    const joinFieldMatcher = getJoinMatcher(options);\n    let joinIndex = frameCopy.fields.findIndex((f) => joinFieldMatcher(f, frameCopy, options.frames));\n\n    if (options.keepOriginIndices) {\n      frameCopy = {\n        ...frame,\n        fields: frame.fields.map((f, fieldIndex) => {\n          const copy = { ...f };\n          const origin = {\n            frameIndex: 0,\n            fieldIndex,\n          };\n          if (copy.state) {\n            copy.state.origin = origin;\n          } else {\n            copy.state = { origin };\n          }\n          return copy;\n        }),\n      };\n\n      // Make sure the join field is first\n      if (joinIndex > 0) {\n        const joinField = frameCopy.fields[joinIndex];\n        const fields = frameCopy.fields.filter((f, idx) => idx !== joinIndex);\n        fields.unshift(joinField);\n        frameCopy.fields = fields;\n        joinIndex = 0;\n      }\n    }\n\n    if (joinIndex >= 0) {\n      frameCopy = maybeSortFrame(frameCopy, joinIndex);\n    }\n\n    if (options.keep) {\n      let fields = frameCopy.fields.filter(\n        (f, fieldIdx) => fieldIdx === joinIndex || options.keep!(f, frameCopy, options.frames)\n      );\n\n      // mutate already copied frame\n      if (frame !== frameCopy) {\n        frameCopy.fields = fields;\n      } else {\n        frameCopy = {\n          ...frame,\n          fields,\n        };\n      }\n    }\n\n    return frameCopy;\n  }\n\n  const nullModes: JoinNullMode[][] = [];\n  const allData: AlignedData[] = [];\n  const originalFields: Field[] = [];\n  const joinFieldMatcher = getJoinMatcher(options);\n\n  for (let frameIndex = 0; frameIndex < options.frames.length; frameIndex++) {\n    const frame = options.frames[frameIndex];\n\n    if (!frame || !frame.fields?.length) {\n      continue; // skip the frame\n    }\n\n    const nullModesFrame: JoinNullMode[] = [NULL_REMOVE];\n    let join: Field | undefined = undefined;\n    let fields: Field[] = [];\n\n    for (let fieldIndex = 0; fieldIndex < frame.fields.length; fieldIndex++) {\n      const field = frame.fields[fieldIndex];\n      field.state = field.state || {};\n\n      if (!join && joinFieldMatcher(field, frame, options.frames)) {\n        join = field;\n      } else {\n        if (options.keep && !options.keep(field, frame, options.frames)) {\n          continue; // skip field\n        }\n\n        // Support the standard graph span nulls field config\n        let spanNulls = field.config.custom?.spanNulls;\n        nullModesFrame.push(spanNulls === true ? NULL_REMOVE : spanNulls === -1 ? NULL_RETAIN : NULL_EXPAND);\n\n        let labels = field.labels ?? {};\n        if (frame.name) {\n          labels = { ...labels, name: frame.name };\n        }\n\n        fields.push({\n          ...field,\n          labels, // add the name label from frame\n        });\n      }\n\n      if (options.keepOriginIndices) {\n        field.state.origin = {\n          frameIndex,\n          fieldIndex,\n        };\n      }\n    }\n\n    if (!join) {\n      continue; // skip the frame\n    }\n\n    if (originalFields.length === 0) {\n      originalFields.push(join); // first join field\n    }\n\n    nullModes.push(nullModesFrame);\n    const a: AlignedData = [join.values.toArray()]; //\n\n    for (const field of fields) {\n      a.push(field.values.toArray());\n      originalFields.push(field);\n      // clear field displayName state\n      delete field.state?.displayName;\n    }\n\n    allData.push(a);\n  }\n\n  const joined = join(allData, nullModes, options.mode);\n\n  return {\n    // ...options.data[0], // keep name, meta?\n    length: joined[0].length,\n    fields: originalFields.map((f, index) => ({\n      ...f,\n      values: new ArrayVector(joined[index]),\n    })),\n  };\n}\n\n//--------------------------------------------------------------------------------\n// Below here is copied from uplot (MIT License)\n// https://github.com/leeoniya/uPlot/blob/master/src/utils.js#L325\n// This avoids needing to import uplot into the data package\n//--------------------------------------------------------------------------------\n\n// Copied from uplot\nexport type TypedArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray\n  | Float32Array\n  | Float64Array;\n\nexport type AlignedData =\n  | TypedArray[]\n  | [xValues: number[] | TypedArray, ...yValues: Array<Array<number | null | undefined> | TypedArray>];\n\n// nullModes\nconst NULL_REMOVE = 0; // nulls are converted to undefined (e.g. for spanGaps: true)\nconst NULL_RETAIN = 1; // nulls are retained, with alignment artifacts set to undefined (default)\nconst NULL_EXPAND = 2; // nulls are expanded to include any adjacent alignment artifacts\n\ntype JoinNullMode = number; // NULL_IGNORE | NULL_RETAIN | NULL_EXPAND;\n\n// sets undefined values to nulls when adjacent to existing nulls (minesweeper)\nfunction nullExpand(yVals: Array<number | null>, nullIdxs: number[], alignedLen: number) {\n  for (let i = 0, xi, lastNullIdx = -1; i < nullIdxs.length; i++) {\n    let nullIdx = nullIdxs[i];\n\n    if (nullIdx > lastNullIdx) {\n      xi = nullIdx - 1;\n      while (xi >= 0 && yVals[xi] == null) {\n        yVals[xi--] = null;\n      }\n\n      xi = nullIdx + 1;\n      while (xi < alignedLen && yVals[xi] == null) {\n        yVals[(lastNullIdx = xi++)] = null;\n      }\n    }\n  }\n}\n\n// nullModes is a tables-matched array indicating how to treat nulls in each series\nexport function join(tables: AlignedData[], nullModes?: number[][], mode: JoinMode = JoinMode.outer) {\n  let xVals: Set<number>;\n\n  if (mode === JoinMode.inner) {\n    // @ts-ignore\n    xVals = new Set(intersect(tables.map((t) => t[0])));\n  } else {\n    xVals = new Set();\n\n    for (let ti = 0; ti < tables.length; ti++) {\n      let t = tables[ti];\n      let xs = t[0];\n      let len = xs.length;\n\n      for (let i = 0; i < len; i++) {\n        xVals.add(xs[i]);\n      }\n    }\n  }\n\n  let data = [Array.from(xVals).sort((a, b) => a - b)];\n\n  let alignedLen = data[0].length;\n\n  let xIdxs = new Map();\n\n  for (let i = 0; i < alignedLen; i++) {\n    xIdxs.set(data[0][i], i);\n  }\n\n  for (let ti = 0; ti < tables.length; ti++) {\n    let t = tables[ti];\n    let xs = t[0];\n\n    for (let si = 1; si < t.length; si++) {\n      let ys = t[si];\n\n      let yVals = Array(alignedLen).fill(undefined);\n\n      let nullMode = nullModes ? nullModes[ti][si] : NULL_RETAIN;\n\n      let nullIdxs = [];\n\n      for (let i = 0; i < ys.length; i++) {\n        let yVal = ys[i];\n        let alignedIdx = xIdxs.get(xs[i]);\n\n        if (yVal === null) {\n          if (nullMode !== NULL_REMOVE) {\n            yVals[alignedIdx] = yVal;\n\n            if (nullMode === NULL_EXPAND) {\n              nullIdxs.push(alignedIdx);\n            }\n          }\n        } else {\n          yVals[alignedIdx] = yVal;\n        }\n      }\n\n      nullExpand(yVals, nullIdxs, alignedLen);\n\n      data.push(yVals);\n    }\n  }\n\n  return data;\n}\n\n// Test a few samples to see if the values are ascending\n// Only exported for tests\nexport function isLikelyAscendingVector(data: Vector, samples = 50) {\n  const len = data.length;\n\n  // empty or single value\n  if (len <= 1) {\n    return true;\n  }\n\n  // skip leading & trailing nullish\n  let firstIdx = 0;\n  let lastIdx = len - 1;\n\n  while (firstIdx <= lastIdx && data.get(firstIdx) == null) {\n    firstIdx++;\n  }\n\n  while (lastIdx >= firstIdx && data.get(lastIdx) == null) {\n    lastIdx--;\n  }\n\n  // all nullish or one value surrounded by nullish\n  if (lastIdx <= firstIdx) {\n    return true;\n  }\n\n  const stride = Math.max(1, Math.floor((lastIdx - firstIdx + 1) / samples));\n\n  for (let prevVal = data.get(firstIdx), i = firstIdx + stride; i <= lastIdx; i += stride) {\n    const v = data.get(i);\n\n    if (v != null) {\n      if (v <= prevVal) {\n        return false;\n      }\n\n      prevVal = v;\n    }\n  }\n\n  return true;\n}\n"],"names":["joinFieldMatcher","join"],"mappings":"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"}