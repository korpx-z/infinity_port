{"version":3,"file":"reduce.js","sources":["../../../../src/transformations/transformers/reduce.ts"],"sourcesContent":["import { map } from 'rxjs/operators';\n\nimport { guessFieldTypeForField } from '../../dataframe/processDataFrame';\nimport { getFieldDisplayName } from '../../field';\nimport { KeyValue } from '../../types/data';\nimport { DataFrame, Field, FieldType } from '../../types/dataFrame';\nimport { DataTransformerInfo, FieldMatcher, MatcherConfig } from '../../types/transformations';\nimport { ArrayVector } from '../../vector/ArrayVector';\nimport { fieldReducers, reduceField, ReducerID } from '../fieldReducer';\nimport { getFieldMatcher } from '../matchers';\nimport { alwaysFieldMatcher, notTimeFieldMatcher } from '../matchers/predicates';\n\nimport { DataTransformerID } from './ids';\n\nexport enum ReduceTransformerMode {\n  SeriesToRows = 'seriesToRows', // default\n  ReduceFields = 'reduceFields', // same structure, add additional row for each type\n}\nexport interface ReduceTransformerOptions {\n  reducers: ReducerID[];\n  fields?: MatcherConfig; // Assume all fields\n  mode?: ReduceTransformerMode;\n  includeTimeField?: boolean;\n  labelsToFields?: boolean;\n}\n\nexport const reduceTransformer: DataTransformerInfo<ReduceTransformerOptions> = {\n  id: DataTransformerID.reduce,\n  name: 'Reduce',\n  description: 'Reduce all rows or data points to a single value using a function like max, min, mean or last',\n  defaultOptions: {\n    reducers: [ReducerID.max],\n  },\n\n  /**\n   * Return a modified copy of the series.  If the transform is not or should not\n   * be applied, just return the input series\n   */\n  operator: (options) => (source) =>\n    source.pipe(\n      map((data) => {\n        if (!options?.reducers?.length) {\n          return data; // nothing selected\n        }\n\n        const matcher = options.fields\n          ? getFieldMatcher(options.fields)\n          : options.includeTimeField && options.mode === ReduceTransformerMode.ReduceFields\n          ? alwaysFieldMatcher\n          : notTimeFieldMatcher;\n\n        // Collapse all matching fields into a single row\n        if (options.mode === ReduceTransformerMode.ReduceFields) {\n          return reduceFields(data, matcher, options.reducers);\n        }\n\n        // Add a row for each series\n        const res = reduceSeriesToRows(data, matcher, options.reducers, options.labelsToFields);\n        return res ? [res] : [];\n      })\n    ),\n};\n\n/**\n * @internal only exported for testing\n */\nexport function reduceSeriesToRows(\n  data: DataFrame[],\n  matcher: FieldMatcher,\n  reducerId: ReducerID[],\n  labelsToFields?: boolean\n): DataFrame | undefined {\n  const calculators = fieldReducers.list(reducerId);\n  const reducers = calculators.map((c) => c.id);\n  const processed: DataFrame[] = [];\n  const distinctLabels = labelsToFields ? getDistinctLabelKeys(data) : [];\n\n  for (const series of data) {\n    const source = series.fields.filter((f) => matcher(f, series, data));\n\n    const size = source.length;\n    const fields: Field[] = [];\n    const names = new ArrayVector<string>(new Array(size));\n    fields.push({\n      name: 'Field',\n      type: FieldType.string,\n      values: names,\n      config: {},\n    });\n\n    const labels: KeyValue<ArrayVector> = {};\n    if (labelsToFields) {\n      for (const key of distinctLabels) {\n        labels[key] = new ArrayVector<string>(new Array(size));\n        fields.push({\n          name: key,\n          type: FieldType.string,\n          values: labels[key],\n          config: {},\n        });\n      }\n    }\n\n    const calcs: KeyValue<ArrayVector> = {};\n    for (const info of calculators) {\n      calcs[info.id] = new ArrayVector(new Array(size));\n      fields.push({\n        name: info.name,\n        type: FieldType.other, // UNKNOWN until after we call the functions\n        values: calcs[info.id],\n        config: {},\n      });\n    }\n\n    for (let i = 0; i < source.length; i++) {\n      const field = source[i];\n      const results = reduceField({\n        field,\n        reducers,\n      });\n\n      if (labelsToFields) {\n        names.buffer[i] = field.name;\n        if (field.labels) {\n          for (const key of Object.keys(field.labels)) {\n            labels[key].set(i, field.labels[key]);\n          }\n        }\n      } else {\n        names.buffer[i] = getFieldDisplayName(field, series, data);\n      }\n\n      for (const info of calculators) {\n        const v = results[info.id];\n        calcs[info.id].buffer[i] = v;\n      }\n    }\n\n    // For reduced fields, we don't know the type until we see the value\n    for (const f of fields) {\n      if (f.type === FieldType.other) {\n        const t = guessFieldTypeForField(f);\n        if (t) {\n          f.type = t;\n        }\n      }\n    }\n\n    processed.push({\n      ...series, // Same properties, different fields\n      fields,\n      length: size,\n    });\n  }\n\n  return mergeResults(processed);\n}\n\nexport function getDistinctLabelKeys(frames: DataFrame[]): string[] {\n  const keys = new Set<string>();\n  for (const frame of frames) {\n    for (const field of frame.fields) {\n      if (field.labels) {\n        for (const k of Object.keys(field.labels)) {\n          keys.add(k);\n        }\n      }\n    }\n  }\n  return [...keys];\n}\n\n/**\n * @internal only exported for testing\n */\nexport function mergeResults(data: DataFrame[]): DataFrame | undefined {\n  if (!data?.length) {\n    return undefined;\n  }\n\n  const baseFrame = data[0];\n\n  for (let seriesIndex = 1; seriesIndex < data.length; seriesIndex++) {\n    const series = data[seriesIndex];\n\n    for (let baseIndex = 0; baseIndex < baseFrame.fields.length; baseIndex++) {\n      const baseField = baseFrame.fields[baseIndex];\n      for (let fieldIndex = 0; fieldIndex < series.fields.length; fieldIndex++) {\n        const field = series.fields[fieldIndex];\n        const isFirstField = baseIndex === 0 && fieldIndex === 0;\n        const isSameField = baseField.type === field.type && baseField.name === field.name;\n\n        if (isFirstField || isSameField) {\n          const baseValues: any[] = baseField.values.toArray();\n          const values: any[] = field.values.toArray();\n          (baseField.values as unknown as ArrayVector).buffer = baseValues.concat(values);\n        }\n      }\n    }\n  }\n\n  baseFrame.name = undefined;\n  baseFrame.length = baseFrame.fields[0].values.length;\n  return baseFrame;\n}\n\n/**\n * @internal -- only exported for testing\n */\nexport function reduceFields(data: DataFrame[], matcher: FieldMatcher, reducerId: ReducerID[]): DataFrame[] {\n  const calculators = fieldReducers.list(reducerId);\n  const reducers = calculators.map((c) => c.id);\n  const processed: DataFrame[] = [];\n\n  for (const series of data) {\n    const fields: Field[] = [];\n    for (const field of series.fields) {\n      if (matcher(field, series, data)) {\n        const results = reduceField({\n          field,\n          reducers,\n        });\n        for (const reducer of reducers) {\n          const value = results[reducer];\n          const copy = {\n            ...field,\n            values: new ArrayVector([value]),\n          };\n          copy.state = undefined;\n          if (reducers.length > 1) {\n            if (!copy.labels) {\n              copy.labels = {};\n            }\n            copy.labels['reducer'] = fieldReducers.get(reducer).name;\n          }\n          fields.push(copy);\n        }\n      }\n    }\n    if (fields.length) {\n      processed.push({\n        ...series,\n        fields,\n        length: 1, // always one row\n      });\n    }\n  }\n\n  return processed;\n}\n"],"names":[],"mappings":"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"}