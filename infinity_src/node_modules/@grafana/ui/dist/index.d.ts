/// <reference types="react" />
/// <reference types="jquery" />
import { NoticeProps, GroupBase, ActionMeta as ActionMeta$1, OptionsOrGroups, CommonProps as CommonProps$2, CSSObjectWithLabel, ContainerProps as ContainerProps$1 } from 'react-select';
import * as _grafana_data from '@grafana/data';
import { SelectableValue, GrafanaTheme, GrafanaTheme2, LinkTarget, IconName, LinkModel, Field as Field$1, FieldType, TimeRange, TimeZone, DateTime, InternalTimeZones, VariableSuggestion, NavModelItem, DataFrame, KeyValue, CSVConfig, DisplayValue, FieldSparkline, DisplayValueAlignmentFactors, VizOrientation, DecimalCount, ThresholdsConfig, FieldColorMode, DataFrameFieldIndex, EventBus, FieldConfig, Dimensions, GraphSeriesValue, GraphSeriesXY, Dimension, FormattedValue, FlotDataPoint, DisplayProcessor, LoadingState, DashboardCursorSync, CoreApp, AnnotationEventUIModel, SplitOpen, Labels, LogRowModel, LogsSortOrder, LogsDedupStrategy, LogLevel, ReduceDataOptions, PanelModel, ValueMapping, DataLink, FeatureState, DataSourceJsonData, DataSourceSettings, DataSourcePluginOptionsEditorProps, SliderMarks, RegistryItem, FieldMatcherInfo, Registry, RelativeTimeRange, PluginSignatureStatus, FieldMatcher, DataHoverEvent, LegacyGraphHoverEvent, FieldConfigEditorBuilder, StandardEditorProps, PanelOptionsEditorBuilder, FieldOverrideEditorProps } from '@grafana/data';
export { IconName, toIconName } from '@grafana/data';
import * as React$1 from 'react';
import React__default, { Component, InputHTMLAttributes, ReactElement, CSSProperties, ReactNode, PureComponent, ChangeEvent, ButtonHTMLAttributes, HTMLAttributes, PropsWithChildren, RefCallback, HTMLProps, FC, ComponentType, MouseEvent as MouseEvent$1, AnchorHTMLAttributes, FormEvent, DetailedHTMLProps } from 'react';
import { Placement, VirtualElement, BasePlacement } from '@popperjs/core';
import { SchemaProperties, Document as Document$1, Value, Node, Mark } from 'slate';
import { Editor, Plugin, EventHook } from 'slate-react';
import * as react_hook_form from 'react-hook-form';
import { FieldValues, UseFormReturn, FieldErrors, Mode, UnpackNestedValue, DeepPartial, SubmitHandler, UseFieldArrayProps } from 'react-hook-form';
export { FieldErrors as FormFieldErrors, SubmitHandler as FormsOnSubmit } from 'react-hook-form';
import { Row, IdType, CellProps, DefaultSortTypes, SortByFn, TableOptions } from 'react-table';
export { CellProps, SortByFn } from 'react-table';
export { ansicolor } from 'ansicolor';
import * as memoize_one from 'memoize-one';
import { CSSObject } from '@emotion/css';
import * as _grafana_schema from '@grafana/schema';
import { TableCellHeight, VizTextDisplayOptions, AxisPlacement, ScaleDistribution, ScaleOrientation, ScaleDirection, LineConfig, BarConfig, FillConfig, PointsConfig, GraphGradientMode, GraphDrawStyle, GraphThresholdsStyleConfig, GraphFieldConfig, TooltipDisplayMode, LegendDisplayMode, LegendPlacement, BarGaugeDisplayMode, BarGaugeValueMode, OptionsWithTextFormatting, LineInterpolation, BarAlignment, VisibilityMode, StackingMode, GraphTresholdsStyleMode, VizLegendOptions, SortOrder, AxisConfig, ScaleDistributionConfig, HideableFieldConfig, OptionsWithLegend, OptionsWithTooltip, StackingConfig } from '@grafana/schema';
export { AxisConfig, AxisPlacement, BarAlignment, BarConfig, BarGaugeDisplayMode, VisibilityMode as BarValueVisibility, GraphDrawStyle as DrawStyle, FieldTextAlignment, FillConfig, GraphFieldConfig, GraphGradientMode, GraphThresholdsStyleConfig, GraphTresholdsStyleMode, HideSeriesConfig, HideableFieldConfig, LegendDisplayMode, LegendPlacement, LineConfig, LineInterpolation, LineStyle, OptionsWithLegend, OptionsWithTextFormatting, OptionsWithTooltip, VisibilityMode as PointVisibility, PointsConfig, ScaleDirection, ScaleDistribution, ScaleDistributionConfig, ScaleOrientation, StackableFieldConfig, StackingConfig, StackingMode, TableCellDisplayMode, TableFieldOptions, TooltipDisplayMode, VizLegendOptions, VizTextDisplayOptions, VizTooltipOptions } from '@grafana/schema';
import Prism from 'prismjs';
import { PopperArrowProps } from 'react-popper';
import { positionValues } from 'react-custom-scrollbars-2';
import { EditorProps } from '@monaco-editor/react';
import * as monacoType from 'monaco-editor/esm/vs/editor/editor.api';
export { monacoType as monacoTypes };
import uPlot, { Options, AlignedData, Axis, Scale, Series, Hooks, Cursor, Select as Select$2, Band, Padding, Range } from 'uplot';
import { AsyncState } from 'react-use/lib/useAsync';
import { DropzoneOptions, Accept } from 'react-dropzone';

declare type Props$1g<T> = NoticeProps<SelectableValue<T>, boolean, GroupBase<SelectableValue<T>>>;

/**
 * This API allows popovers to update Popper's position when e.g. popover content changes
 * updatePopperPosition is delivered to content by react-popper.
 */
interface PopoverContentProps {
    updatePopperPosition?: () => void;
}
declare type PopoverContent = string | React.ReactElement | ((props: PopoverContentProps) => JSX.Element);
declare type TooltipPlacement = 'auto-start' | 'auto' | 'auto-end' | 'top-start' | 'top' | 'top-end' | 'right-start' | 'right' | 'right-end' | 'bottom-end' | 'bottom' | 'bottom-start' | 'left-end' | 'left' | 'left-start';

interface TooltipProps {
    theme?: 'info' | 'error' | 'info-alt';
    show?: boolean;
    placement?: TooltipPlacement;
    content: PopoverContent;
    children: JSX.Element;
    /**
     * Set to true if you want the tooltip to stay long enough so the user can move mouse over content to select text or click a link
     */
    interactive?: boolean;
}
declare const Tooltip: React__default.MemoExoticComponent<({ children, theme, interactive, show, placement, content }: TooltipProps) => JSX.Element>;

declare type PopperControllerRenderProp = (showPopper: () => void, hidePopper: () => void, popperProps: {
    show: boolean;
    placement: Placement;
    content: PopoverContent;
}) => JSX.Element;
interface Props$1f {
    placement?: Placement;
    content: PopoverContent;
    className?: string;
    children: PopperControllerRenderProp;
    hideAfter?: number;
}
interface State$7 {
    show: boolean;
}
declare class PopoverController extends Component<Props$1f, State$7> {
    private hideTimeout;
    state: {
        show: boolean;
    };
    showPopper: () => void;
    hidePopper: () => void;
    render(): JSX.Element;
}

interface Props$1e extends InputHTMLAttributes<HTMLInputElement> {
    label: string;
    tooltip?: PopoverContent;
    labelWidth?: number;
    inputWidth?: number | null;
    inputEl?: React__default.ReactNode;
    /** Make tooltip interactive */
    interactive?: boolean;
}

interface Props$1d extends Omit<InputHTMLAttributes<HTMLInputElement>, 'onReset'> {
    onReset: (event: React__default.SyntheticEvent<HTMLButtonElement>) => void;
    isConfigured: boolean;
    label?: string;
    tooltip?: PopoverContent;
    labelWidth?: number;
    inputWidth?: number;
    placeholder?: string;
    interactive?: boolean;
}

interface Themeable {
    theme: GrafanaTheme;
}
interface Themeable2 {
    theme: GrafanaTheme2;
}

interface ValidationRule {
    rule: (valueToValidate: string) => boolean;
    errorMessage: string;
}
interface ValidationEvents {
    [eventName: string]: ValidationRule[];
}

declare function getPreviousCousin(node: any, selector: string): any;
declare function getNextCharacter(global?: any): any;

declare const dom_d_getPreviousCousin: typeof getPreviousCousin;
declare const dom_d_getNextCharacter: typeof getNextCharacter;
declare namespace dom_d {
  export {
    dom_d_getPreviousCousin as getPreviousCousin,
    dom_d_getNextCharacter as getNextCharacter,
  };
}

/** Returns the ID value of the first, and only, child element  */
declare function getChildId(children: ReactElement): string | undefined;
/**
 * Given react node or function returns element accordingly
 *
 * @param itemToRender
 * @param props props to be passed to the function if item provided as such
 */
declare function renderOrCallToRender<TProps = {}>(itemToRender: ((props?: TProps) => React__default.ReactNode) | React__default.ReactNode, props?: TProps): React__default.ReactNode;

declare const reactUtils_d_getChildId: typeof getChildId;
declare const reactUtils_d_renderOrCallToRender: typeof renderOrCallToRender;
declare namespace reactUtils_d {
  export {
    reactUtils_d_getChildId as getChildId,
    reactUtils_d_renderOrCallToRender as renderOrCallToRender,
  };
}

/**
 * @alpha
 */
declare const DEFAULT_ANNOTATION_COLOR = "rgba(0, 211, 255, 1)";
/**
 * @alpha
 */
declare const OK_COLOR = "rgba(11, 237, 50, 1)";
/**
 * @alpha
 */
declare const ALERTING_COLOR = "rgba(237, 46, 24, 1)";
/**
 * @alpha
 */
declare const NO_DATA_COLOR = "rgba(150, 150, 150, 1)";
/**
 * @alpha
 */
declare const PENDING_COLOR = "rgba(247, 149, 32, 1)";
/**
 * @alpha
 */
declare const REGION_FILL_ALPHA = 0.09;
declare const colors: string[];
declare function getTextColorForBackground(color: string): "rgb(32, 34, 38)" | "rgb(247, 248, 250)";
declare function getTextColorForAlphaBackground(color: string, themeIsDark: boolean): "rgb(32, 34, 38)" | "rgb(247, 248, 250)";
declare let sortedColors: boolean[];

declare enum EventsWithValidation {
    onBlur = "onBlur",
    onFocus = "onFocus",
    onChange = "onChange"
}
declare const validate: (value: string, validationRules: ValidationRule[]) => string[] | null;
declare const hasValidationEvent: (event: EventsWithValidation, validationEvents: ValidationEvents | undefined) => ValidationRule[] | undefined;
declare const regexValidation: (pattern: string | RegExp, errorMessage?: string) => ValidationRule;

declare const SCHEMA: SchemaProperties;
declare const makeFragment: (text: string, syntax?: string) => Document$1;
declare const makeValue: (text: string, syntax?: string) => Value;

/** @internal */
declare type MenuItemElement = HTMLAnchorElement & HTMLButtonElement & HTMLDivElement;
/** @internal */
interface MenuItemProps<T = any> {
    /** Label of the menu item */
    label: string;
    /** Aria label for accessibility support */
    ariaLabel?: string;
    /** Aria checked for accessibility support */
    ariaChecked?: boolean;
    /** Target of the menu item (i.e. new window)  */
    target?: LinkTarget;
    /** Icon of the menu item */
    icon?: IconName;
    /** Role of the menu item */
    role?: string;
    /** Url of the menu item */
    url?: string;
    /** Handler for the click behaviour */
    onClick?: (event: React__default.MouseEvent<HTMLElement>, payload?: T) => void;
    /** Custom MenuItem styles*/
    className?: string;
    /** Active */
    active?: boolean;
    /** Disabled */
    disabled?: boolean;
    /** Show in destructive style (error color) */
    destructive?: boolean;
    tabIndex?: number;
    /** List of menu items for the subMenu */
    childItems?: Array<ReactElement<MenuItemProps>>;
    /** Custom style for SubMenu */
    customSubMenuContainerStyles?: CSSProperties;
    /** Shortcut key combination */
    shortcut?: string;
    /** Test id for e2e tests and fullstory*/
    testId?: string;
}
/** @internal */
declare const MenuItem: React__default.MemoExoticComponent<React__default.ForwardRefExoticComponent<MenuItemProps<any> & React__default.RefAttributes<MenuItemElement>>>;

/**
 * Delays creating links until we need to open the ContextMenu
 */
declare const linkModelToContextMenuItems: (links: () => LinkModel[]) => MenuItemProps[];
declare const isCompactUrl: (url: string) => boolean;

/**
 * Returns tag badge background and border colors based on hashed tag name.
 * @param name tag name
 */
declare function getTagColorsFromName(name?: string): {
    color: string;
    borderColor: string;
};
declare function getTagColor(index: number): {
    color: string;
    borderColor: string;
};

declare function getScrollbarWidth(): number;

/**
 * @internal
 */
declare const getCellLinks: (field: Field$1, row: Row<any>) => LinkModel<unknown>[] | undefined;

/**
 * @internal
 */
declare function getCanvasContext(): CanvasRenderingContext2D;
/**
 * @beta
 */
declare function measureText(text: string, fontSize: number, fontWeight?: number): TextMetrics;
/**
 * @beta
 */
declare function calculateFontSize(text: string, width: number, height: number, lineHeight: number, maxSize?: number, fontWeight?: number): number;

/** @internal */
declare function useForceUpdate(): () => void;

/**
 * List of auto-complete search function used by SuggestionsPlugin.handleTypeahead()
 * @alpha
 */
declare enum SearchFunctionType {
    Word = "Word",
    Prefix = "Prefix",
    Fuzzy = "Fuzzy"
}

/**
 * @internal
 */
interface Logger {
    logger: (...t: any[]) => void;
    enable: () => void;
    disable: () => void;
    isEnabled: () => boolean;
}
/** @internal */
declare const createLogger: (name: string) => Logger;

/**
 * Allows debug helpers attachement to the window object
 * @internal
 */
declare function attachDebugger(key: string, thebugger?: any, logger?: Logger): void;

/**
 * @deprecated use it from @grafana/data. Kept here for backward compatibility.
 */
declare enum NodeGraphDataFrameFieldNames {
    id = "id",
    title = "title",
    subTitle = "subTitle",
    mainStat = "mainStat",
    secondaryStat = "secondaryStat",
    source = "source",
    target = "target",
    detail = "detail__",
    arc = "arc__",
    color = "color"
}

declare type FuzzyMatch = {
    /**
     * Total number of unmatched letters between matched letters
     */
    distance: number;
    ranges: HighlightPart[];
    found: boolean;
};
/**
 * Attempts to do a partial input search, e.g. allowing to search for a text (needle)
 * in another text (stack) by skipping some letters in-between. All letters from
 * the needle must exist in the stack in the same order to find a match.
 *
 * The search is case sensitive. Convert stack and needle to lower case
 * to make it case insensitive.
 *
 * @param stack - main text to be searched
 * @param needle - partial text to find in the stack
 *
 * @internal
 */
declare function fuzzyMatch(stack: string, needle: string): FuzzyMatch;

/**
 * @internal
 */
declare type SearchFunction = (items: CompletionItem[], prefix: string) => CompletionItem[];
interface CompletionItemGroup {
    /**
     * Label that will be displayed for all entries of this group.
     */
    label: string;
    /**
     * List of suggestions of this group.
     */
    items: CompletionItem[];
    /**
     * If true, match only by prefix (and not mid-word).
     * @deprecated use searchFunctionType instead
     */
    prefixMatch?: boolean;
    /**
     * Function type used to create auto-complete list
     * @alpha
     */
    searchFunctionType?: SearchFunctionType;
    /**
     * If true, do not filter items in this group based on the search.
     */
    skipFilter?: boolean;
    /**
     * If true, do not sort items.
     */
    skipSort?: boolean;
}
declare enum CompletionItemKind {
    GroupTitle = "GroupTitle"
}
/**
 * @internal
 */
declare type HighlightPart = {
    start: number;
    end: number;
};
interface CompletionItem {
    /**
     * The label of this completion item. By default
     * this is also the text that is inserted when selecting
     * this completion.
     */
    label: string;
    /**
     * The kind of this completion item. An icon is chosen
     * by the editor based on the kind.
     */
    kind?: CompletionItemKind | string;
    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    detail?: string;
    /**
     * A human-readable string, can be Markdown, that represents a doc-comment.
     */
    documentation?: string;
    /**
     * A string that should be used when comparing this item
     * with other items. When `falsy` the `label` is used.
     * @deprecated use sortValue instead
     */
    sortText?: string;
    /**
     * A string or number that should be used when comparing this
     * item with other items. When `undefined` then `label` is used.
     * @alpha
     */
    sortValue?: string | number;
    /**
     * Parts of the label to be highlighted
     * @internal
     */
    highlightParts?: HighlightPart[];
    /**
     * A string that should be used when filtering a set of
     * completion items. When `falsy` the `label` is used.
     */
    filterText?: string;
    /**
     * A string or snippet that should be inserted in a document when selecting
     * this completion. When `falsy` the `label` is used.
     */
    insertText?: string;
    /**
     * Delete number of characters before the caret position,
     * by default the letters from the beginning of the word.
     */
    deleteBackwards?: number;
    /**
     * Number of steps to move after the insertion, can be negative.
     */
    move?: number;
}
interface TypeaheadOutput {
    context?: string;
    suggestions: CompletionItemGroup[];
}
interface TypeaheadInput {
    text: string;
    prefix: string;
    wrapperClasses: string[];
    labelKey?: string;
    value?: Value;
    editor?: Editor;
}
interface SuggestionsState {
    groupedItems: CompletionItemGroup[];
    typeaheadPrefix: string;
    typeaheadContext: string;
    typeaheadText: string;
}

declare type FormAPI<T extends FieldValues> = Omit<UseFormReturn<T>, 'trigger' | 'handleSubmit'> & {
    errors: FieldErrors<T>;
};
declare type FieldArrayValue = Partial<FieldValues> | Array<Partial<FieldValues>>;
interface FieldArrayApi {
    fields: Array<Record<string, any>>;
    append: (value: FieldArrayValue) => void;
    prepend: (value: FieldArrayValue) => void;
    remove: (index?: number | number[]) => void;
    swap: (indexA: number, indexB: number) => void;
    move: (from: number, to: number) => void;
    insert: (index: number, value: FieldArrayValue) => void;
}

declare type ComponentSize = 'xs' | 'sm' | 'md' | 'lg';

declare type IconType = 'mono' | 'default' | 'solid';
declare type IconSize = ComponentSize | 'xl' | 'xxl' | 'xxxl';
declare const getAvailableIcons: () => string[];
/**
 * Get the icon for a given field
 */
declare function getFieldTypeIcon(field?: Field$1): IconName;
/** Get an icon for a given field type  */
declare function getFieldTypeIconName(type?: FieldType): IconName;

declare type SelectValue<T> = T | SelectableValue<T> | T[] | Array<SelectableValue<T>>;
declare type ActionMeta = ActionMeta$1<{}>;
declare type InputActionMeta = {
    action: 'set-value' | 'input-change' | 'input-blur' | 'menu-close';
};
declare type LoadOptionsCallback<T> = (options: Array<SelectableValue<T>>) => void;
interface SelectCommonProps<T> {
    /** Aria label applied to the input field */
    ['aria-label']?: string;
    allowCreateWhileLoading?: boolean;
    allowCustomValue?: boolean;
    /** Focus is set to the Select when rendered*/
    autoFocus?: boolean;
    backspaceRemovesValue?: boolean;
    className?: string;
    closeMenuOnSelect?: boolean;
    /** Used for custom components. For more information, see `react-select` */
    components?: any;
    /** Sets the position of the createOption element in your options list. Defaults to 'last' */
    createOptionPosition?: 'first' | 'last';
    defaultValue?: any;
    disabled?: boolean;
    filterOption?: (option: SelectableValue<T>, searchQuery: string) => boolean;
    formatOptionLabel?: (item: SelectableValue<T>, formatOptionMeta: FormatOptionLabelMeta<T>) => React__default.ReactNode;
    /** Function for formatting the text that is displayed when creating a new value*/
    formatCreateLabel?: (input: string) => string;
    getOptionLabel?: (item: SelectableValue<T>) => React__default.ReactNode;
    getOptionValue?: (item: SelectableValue<T>) => string;
    inputValue?: string;
    invalid?: boolean;
    isClearable?: boolean;
    /** The id to set on the SelectContainer component. To set the id for a label (with htmlFor), @see inputId instead */
    id?: string;
    isLoading?: boolean;
    isMulti?: boolean;
    /** The id of the search input. Use this to set a matching label with htmlFor */
    inputId?: string;
    isOpen?: boolean;
    /** Disables the possibility to type into the input*/
    isSearchable?: boolean;
    showAllSelectedWhenOpen?: boolean;
    maxMenuHeight?: number;
    minMenuHeight?: number;
    maxVisibleValues?: number;
    menuPlacement?: 'auto' | 'bottom' | 'top';
    menuPosition?: 'fixed' | 'absolute';
    /**
     * Setting to false will prevent the menu from portalling to the body.
     */
    menuShouldPortal?: boolean;
    /** The message to display when no options could be found */
    noOptionsMessage?: string;
    onBlur?: () => void;
    onChange: (value: SelectableValue<T>, actionMeta: ActionMeta) => {} | void;
    onCloseMenu?: () => void;
    /** allowCustomValue must be enabled. Function decides what to do with that custom value. */
    onCreateOption?: (value: string) => void;
    onInputChange?: (value: string, actionMeta: InputActionMeta) => void;
    onKeyDown?: (event: React__default.KeyboardEvent) => void;
    onOpenMenu?: () => void;
    onFocus?: () => void;
    openMenuOnFocus?: boolean;
    options?: Array<SelectableValue<T>>;
    placeholder?: string;
    /** item to be rendered in front of the input */
    prefix?: JSX.Element | string | null;
    /** Use a custom element to control Select. A proper ref to the renderControl is needed if 'portal' isn't set to null*/
    renderControl?: ControlComponent<T>;
    tabSelectsValue?: boolean;
    value?: T | SelectValue<T> | null;
    /** Will wrap the MenuList in a react-window FixedSizeVirtualList for improved performance, does not support options with "description" properties */
    virtualized?: boolean;
    /** Sets the width to a multiple of 8px. Should only be used with inline forms. Setting width of the container is preferred in other cases.*/
    width?: number | 'auto';
    isOptionDisabled?: () => boolean;
    /** allowCustomValue must be enabled. Determines whether the "create new" option should be displayed based on the current input value, select value and options array. */
    isValidNewOption?: (inputValue: string, value: SelectableValue<T> | null, options: OptionsOrGroups<SelectableValue<T>, GroupBase<SelectableValue<T>>>) => boolean;
    /** Message to display isLoading=true*/
    loadingMessage?: string;
}
interface SelectAsyncProps<T> {
    /** When specified as boolean the loadOptions will execute when component is mounted */
    defaultOptions?: boolean | Array<SelectableValue<T>>;
    /** Asynchronously load select options */
    loadOptions?: (query: string, cb?: LoadOptionsCallback<T>) => Promise<Array<SelectableValue<T>>> | void;
    /** If cacheOptions is true, then the loaded data will be cached. The cache will remain until cacheOptions changes value. */
    cacheOptions?: boolean;
    /** Message to display when options are loading */
    loadingMessage?: string;
}
/** The VirtualizedSelect component uses a slightly different SelectableValue, description and other props are not supported */
interface VirtualizedSelectProps<T> extends Omit<SelectCommonProps<T>, 'virtualized'> {
    options?: Array<Pick<SelectableValue<T>, 'label' | 'value'>>;
}
/** The AsyncVirtualizedSelect component uses a slightly different SelectableValue, description and other props are not supported */
interface VirtualizedSelectAsyncProps<T> extends Omit<SelectCommonProps<T>, 'virtualized'>, SelectAsyncProps<T> {
}
interface MultiSelectCommonProps<T> extends Omit<SelectCommonProps<T>, 'onChange' | 'isMulti' | 'value'> {
    value?: Array<SelectableValue<T>> | T[];
    onChange: (item: Array<SelectableValue<T>>, actionMeta: ActionMeta) => {} | void;
}
interface SelectBaseProps<T> extends SelectCommonProps<T>, SelectAsyncProps<T> {
    invalid?: boolean;
}
interface CustomControlProps<T> {
    ref: React__default.Ref<any>;
    isOpen: boolean;
    /** Currently selected value */
    value?: SelectableValue<T>;
    /** onClick will be automatically passed to custom control allowing menu toggle */
    onClick: () => void;
    /** onBlur will be automatically passed to custom control closing the menu on element blur */
    onBlur: () => void;
    disabled: boolean;
    invalid: boolean;
}
declare type ControlComponent<T> = React__default.ComponentType<CustomControlProps<T>>;
interface SelectableOptGroup<T = any> {
    label: string;
    options: Array<SelectableValue<T>>;
    [key: string]: any;
}
declare type SelectOptions<T = any> = SelectableValue<T> | Array<SelectableValue<T> | SelectableOptGroup<T> | Array<SelectableOptGroup<T>>>;
declare type FormatOptionLabelMeta<T> = {
    context: string;
    inputValue: string;
    selectValue: Array<SelectableValue<T>>;
};
declare type ReactSelectProps<Option, IsMulti extends boolean, Group extends GroupBase<Option>> = CommonProps$2<Option, IsMulti, Group>['selectProps'] & {
    invalid: boolean;
};
interface CustomComponentProps<Option, isMulti extends boolean, Group extends GroupBase<Option>> {
    selectProps: ReactSelectProps<Option, isMulti, Group>;
}

interface Column<TableData extends object> {
    /**
     * ID of the column. Must be unique among all other columns
     */
    id: IdType<TableData>;
    /**
     * Custom render function for te cell
     */
    cell?: (props: CellProps<TableData>) => ReactNode;
    /**
     * Header name. if `undefined` the header will be empty. Useful for action columns.
     */
    header?: string;
    /**
     * Column sort type. If `undefined` the column will not be sortable.
     * */
    sortType?: DefaultSortTypes | SortByFn<TableData>;
    /**
     * If `true` prevents the column from growing more than its content.
     */
    disableGrow?: boolean;
    /**
     * If the provided function returns `false` the column will be hidden.
     */
    visible?: (data: TableData[]) => boolean;
}

declare enum LegacyInputStatus {
    Invalid = "invalid",
    Valid = "valid"
}
interface Props$1c extends React__default.HTMLProps<HTMLInputElement> {
    validationEvents?: ValidationEvents;
    hideErrorMessage?: boolean;
    inputRef?: React__default.LegacyRef<HTMLInputElement>;
    onBlur?: (event: React__default.FocusEvent<HTMLInputElement>, status?: LegacyInputStatus) => void;
    onFocus?: (event: React__default.FocusEvent<HTMLInputElement>, status?: LegacyInputStatus) => void;
    onChange?: (event: React__default.ChangeEvent<HTMLInputElement>, status?: LegacyInputStatus) => void;
}
interface State$6 {
    error: string | null;
}
declare class Input$1 extends PureComponent<Props$1c, State$6> {
    static defaultProps: {
        className: string;
    };
    state: State$6;
    get status(): LegacyInputStatus;
    get isInvalid(): boolean;
    validatorAsync: (validationRules: ValidationRule[]) => (evt: ChangeEvent<HTMLInputElement>) => void;
    populateEventPropsWithStatus: (restProps: any, validationEvents: ValidationEvents | undefined) => any;
    render(): JSX.Element;
}

declare type Omit$1<T, K> = Pick<T, Exclude<keyof T, K>>;
declare type Subtract<T, K> = Omit$1<T, keyof K>;
/** @public */
declare const ThemeContext: React__default.Context<GrafanaTheme2>;
/** @deprecated use withTheme2 */
/** @public */
declare const withTheme: <P extends Themeable, S extends {} = {}>(Component: React__default.ComponentType<P>) => React__default.FunctionComponent<Subtract<P, Themeable>> & S;
/** @alpha */
declare const withTheme2: <P extends Themeable2, S extends {} = {}>(Component: React__default.ComponentType<P>) => React__default.FunctionComponent<Subtract<P, Themeable2>> & S;
/** @deprecated use useTheme2 */
/** @public */
declare function useTheme(): GrafanaTheme;
/** @public */
declare function useTheme2(): GrafanaTheme2;
/**
 * Hook for using memoized styles with access to the theme.
 *
 * NOTE: For memoization to work, you need to ensure that the function
 * you pass in doesn't change, or only if it needs to. (i.e. declare
 * your style creator outside of a function component or use `useCallback()`.)
 * */
/** @deprecated use useStyles2 */
/** @public */
declare function useStyles<T>(getStyles: (theme: GrafanaTheme) => T): T;
/**
 * Hook for using memoized styles with access to the theme.
 *
 * NOTE: For memoization to work, you need to ensure that the function
 * you pass in doesn't change, or only if it needs to. (i.e. declare
 * your style creator outside of a function component or use `useCallback()`.)
 * */
/** @public */
declare function useStyles2<T>(getStyles: (theme: GrafanaTheme2) => T): T;
/**
 * Enables theme context  mocking
 */
/** @public */
declare const mockThemeContext: (theme: Partial<GrafanaTheme2>) => () => void;

/** @public */
declare const getTheme: (mode?: 'dark' | 'light') => GrafanaTheme;
/** @public */
declare const mockTheme: (mock: (name?: string) => GrafanaTheme) => () => void;

/**
 * @public
 * @deprecated use useStyles hook
 *  Creates memoized version of styles creator
 * @param stylesCreator function accepting dependencies based on which styles are created
 */
declare function stylesFactory<ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>>(stylesCreator: ResultFn): memoize_one.MemoizedFn<ResultFn>;

/** @internal */
declare function GlobalStyles(): JSX.Element;

declare function cardChrome(theme: GrafanaTheme2): string;
declare function hoverColor(color: string, theme: GrafanaTheme2): string;
declare function listItem(theme: GrafanaTheme2): string;
declare function listItemSelected(theme: GrafanaTheme2): string;
declare function mediaUp(breakpoint: string): string;
declare const focusCss: (theme: GrafanaTheme | GrafanaTheme2) => string;
declare function getMouseFocusStyles(theme: GrafanaTheme | GrafanaTheme2): CSSObject;
declare function getFocusStyles(theme: GrafanaTheme2): CSSObject;
declare const getTooltipContainerStyles: (theme: GrafanaTheme2) => string;

declare const mixins_d_cardChrome: typeof cardChrome;
declare const mixins_d_hoverColor: typeof hoverColor;
declare const mixins_d_listItem: typeof listItem;
declare const mixins_d_listItemSelected: typeof listItemSelected;
declare const mixins_d_mediaUp: typeof mediaUp;
declare const mixins_d_focusCss: typeof focusCss;
declare const mixins_d_getMouseFocusStyles: typeof getMouseFocusStyles;
declare const mixins_d_getFocusStyles: typeof getFocusStyles;
declare const mixins_d_getTooltipContainerStyles: typeof getTooltipContainerStyles;
declare namespace mixins_d {
  export {
    mixins_d_cardChrome as cardChrome,
    mixins_d_hoverColor as hoverColor,
    mixins_d_listItem as listItem,
    mixins_d_listItemSelected as listItemSelected,
    mixins_d_mediaUp as mediaUp,
    mixins_d_focusCss as focusCss,
    mixins_d_getMouseFocusStyles as getMouseFocusStyles,
    mixins_d_getFocusStyles as getFocusStyles,
    mixins_d_getTooltipContainerStyles as getTooltipContainerStyles,
  };
}

/**
 * Changes in new selects:
 * - noOptionsMessage & loadingMessage is of string type
 * - isDisabled is renamed to disabled
 */
declare type LegacyCommonProps<T> = Omit<SelectCommonProps<T>, 'noOptionsMessage' | 'disabled' | 'value' | 'loadingMessage'>;
interface AsyncProps<T> extends LegacyCommonProps<T>, Omit<SelectAsyncProps<T>, 'loadingMessage'> {
    loadingMessage?: () => string;
    noOptionsMessage?: () => string;
    tooltipContent?: PopoverContent;
    isDisabled?: boolean;
    value?: SelectableValue<T>;
}
interface LegacySelectProps<T> extends LegacyCommonProps<T> {
    tooltipContent?: PopoverContent;
    noOptionsMessage?: () => string;
    isDisabled?: boolean;
    value?: SelectableValue<T>;
}
declare class Select$1<T> extends PureComponent<LegacySelectProps<T>> {
    context: React__default.ContextType<typeof ThemeContext>;
    static contextType: React__default.Context<_grafana_data.GrafanaTheme2>;
    static defaultProps: Partial<LegacySelectProps<unknown>>;
    render(): JSX.Element;
}
declare class AsyncSelect$1<T> extends PureComponent<AsyncProps<T>> {
    static contextType: React__default.Context<_grafana_data.GrafanaTheme2>;
    static defaultProps: Partial<AsyncProps<unknown>>;
    render(): JSX.Element;
}

interface Props$1b {
    label: string;
    checked: boolean;
    disabled?: boolean;
    className?: string;
    labelClass?: string;
    switchClass?: string;
    tooltip?: string;
    tooltipPlacement?: Placement;
    transparent?: boolean;
    onChange: (event: React__default.SyntheticEvent<HTMLInputElement>) => void;
}
interface State$5 {
    id: string;
}
declare class Switch$1 extends PureComponent<Props$1b, State$5> {
    state: {
        id: string;
    };
    internalOnChange: (event: React__default.FormEvent<HTMLInputElement>) => void;
    render(): JSX.Element;
}

interface IconProps extends React__default.HTMLAttributes<HTMLDivElement> {
    name: IconName;
    size?: IconSize;
    type?: IconType;
    title?: string;
}
declare const Icon: React__default.ForwardRefExoticComponent<IconProps & React__default.RefAttributes<HTMLDivElement>>;

declare type IconButtonVariant = 'primary' | 'secondary' | 'destructive';
interface Props$1a extends React__default.ButtonHTMLAttributes<HTMLButtonElement> {
    /** Name of the icon **/
    name: IconName;
    /** Icon size */
    size?: IconSize;
    /** Type of the icon - mono or default */
    iconType?: IconType;
    /** Tooltip content to display on hover */
    tooltip?: PopoverContent;
    /** Position of the tooltip */
    tooltipPlacement?: TooltipPlacement;
    /** Variant to change the color of the Icon */
    variant?: IconButtonVariant;
    /** Text avilable ony for screenscreen readers. Will use tooltip text as fallback. */
    ariaLabel?: string;
}
declare const IconButton: React__default.ForwardRefExoticComponent<Props$1a & React__default.RefAttributes<HTMLButtonElement>>;

declare type ButtonVariant = 'primary' | 'secondary' | 'destructive' | 'success';
declare type ButtonFill = 'solid' | 'outline' | 'text';
declare type CommonProps$1 = {
    size?: ComponentSize;
    variant?: ButtonVariant;
    fill?: ButtonFill;
    icon?: IconName;
    className?: string;
    children?: React__default.ReactNode;
    fullWidth?: boolean;
    type?: string;
    /** Tooltip content to display on hover */
    tooltip?: PopoverContent;
    /** Position of the tooltip */
    tooltipPlacement?: TooltipPlacement;
};
declare type ButtonProps = CommonProps$1 & ButtonHTMLAttributes<HTMLButtonElement>;
declare const Button: React__default.ForwardRefExoticComponent<CommonProps$1 & React__default.ButtonHTMLAttributes<HTMLButtonElement> & React__default.RefAttributes<HTMLButtonElement>>;
declare const LinkButton: React__default.ForwardRefExoticComponent<CommonProps$1 & React__default.ButtonHTMLAttributes<HTMLButtonElement> & React__default.AnchorHTMLAttributes<HTMLAnchorElement> & React__default.RefAttributes<HTMLAnchorElement>>;
declare const clearButtonStyles: (theme: GrafanaTheme2) => string;

interface Props$19 extends HTMLAttributes<HTMLDivElement> {
    className?: string;
}
declare const ButtonGroup: React__default.ForwardRefExoticComponent<Props$19 & React__default.RefAttributes<HTMLDivElement>>;

declare const ConfirmButton: React__default.FunctionComponent<{
    disabled?: boolean | undefined;
    onClick?: (() => void) | undefined;
    children?: React__default.ReactNode;
    size?: ComponentSize | undefined;
    className?: string | undefined;
    autoFocus?: boolean | undefined;
    onConfirm: () => void;
    confirmText?: string | undefined;
    confirmVariant?: ButtonVariant | undefined;
    closeOnConfirm?: boolean | undefined;
    onCancel?: (() => void) | undefined;
}>;

interface Props$18 {
    /** Confirm action callback */
    onConfirm(): void;
    /** Button size */
    size?: ComponentSize;
    /** Disable button click action */
    disabled?: boolean;
    'aria-label'?: string;
    /** Close after delete button is clicked */
    closeOnConfirm?: boolean;
}
declare const DeleteButton: ({ size, disabled, onConfirm, "aria-label": ariaLabel, closeOnConfirm }: Props$18) => JSX.Element;

declare type RenderPopperArrowFn = (props: {
    arrowProps: PopperArrowProps;
    placement: string;
}) => JSX.Element;
interface Props$17 extends React__default.HTMLAttributes<HTMLDivElement> {
    show: boolean;
    placement?: Placement;
    content: PopoverContent;
    referenceElement: HTMLElement | VirtualElement;
    wrapperClassName?: string;
    renderArrow?: RenderPopperArrowFn;
}
declare class Popover extends PureComponent<Props$17> {
    render(): JSX.Element;
}

/**
 * This API allows popovers to update Popper's position when e.g. popover content changes
 * update is delivered to content by react-popper.
 */
interface ToggletipContentProps {
    update?: () => void;
}
declare type ToggletipContent = string | React.ReactElement | ((props: ToggletipContentProps) => JSX.Element);

interface ToggletipProps {
    /** The theme used to display the toggletip */
    theme?: 'info' | 'error';
    /** The title to be displayed on the header */
    title?: JSX.Element | string;
    /** determine whether to show or not the close button **/
    closeButton?: boolean;
    /** Callback function to be called when the toggletip is closed */
    onClose?: Function;
    /** The preferred placement of the toggletip */
    placement?: Placement;
    /** The text or component that houses the content of the toggleltip */
    content: ToggletipContent;
    /** The text or component to be displayed on the toggletip's bottom */
    footer?: JSX.Element | string;
    /** The UI control users interact with to display toggletips */
    children: JSX.Element;
}
declare const Toggletip: React__default.MemoExoticComponent<({ children, theme, placement, content, title, closeButton, onClose, footer, }: ToggletipProps) => JSX.Element>;

interface Props$16 {
    className?: string;
    root?: HTMLElement;
    forwardedRef?: React__default.ForwardedRef<HTMLDivElement>;
}
declare function Portal(props: PropsWithChildren<Props$16>): React$1.ReactPortal;
/** @internal */
declare function getPortalContainer(): HTMLElement;
/** @internal */
declare function PortalContainer(): JSX.Element;

declare type ScrollbarPosition = positionValues;
interface Props$15 {
    className?: string;
    testId?: string;
    autoHide?: boolean;
    autoHideTimeout?: number;
    autoHeightMax?: string;
    hideTracksWhenNotNeeded?: boolean;
    hideHorizontalTrack?: boolean;
    hideVerticalTrack?: boolean;
    scrollRefCallback?: RefCallback<HTMLDivElement>;
    scrollTop?: number;
    setScrollTop?: (position: ScrollbarPosition) => void;
    showScrollIndicators?: boolean;
    autoHeightMin?: number | string;
    updateAfterMountMs?: number;
    onScroll?: React__default.UIEventHandler;
}
/**
 * Wraps component into <Scrollbars> component from `react-custom-scrollbars`
 */
declare const CustomScrollbar: ({ autoHide, autoHideTimeout, setScrollTop, className, testId, autoHeightMin, autoHeightMax, hideTracksWhenNotNeeded, hideHorizontalTrack, hideVerticalTrack, scrollRefCallback, showScrollIndicators, updateAfterMountMs, scrollTop, onScroll, children, }: React__default.PropsWithChildren<Props$15>) => JSX.Element;

interface TabConfig {
    label: string;
    value: string;
    content: React__default.ReactNode;
    icon: IconName;
}
interface TabbedContainerProps {
    tabs: TabConfig[];
    defaultTab?: string;
    closeIconTooltip?: string;
    onClose: () => void;
}
declare function TabbedContainer(props: TabbedContainerProps): JSX.Element;

interface Props$14 extends ButtonProps {
    /** A function that returns text to be copied */
    getText(): string;
    /** Callback when the text has been successfully copied */
    onClipboardCopy?(copiedText: string): void;
    /** Callback when there was an error copying the text */
    onClipboardError?(copiedText: string, error: unknown): void;
}
declare function ClipboardButton({ onClipboardCopy, onClipboardError, children, getText, icon, variant, ...buttonProps }: Props$14): JSX.Element;

interface CascaderProps {
    /** The separator between levels in the search */
    separator?: string;
    placeholder?: string;
    options: CascaderOption[];
    /** Changes the value for every selection, including branch nodes. Defaults to true. */
    changeOnSelect?: boolean;
    onSelect(val: string): void;
    /** Sets the width to a multiple of 8px. Should only be used with inline forms. Setting width of the container is preferred in other cases.*/
    width?: number;
    initialValue?: string;
    allowCustomValue?: boolean;
    /** A function for formatting the message for custom value creation. Only applies when allowCustomValue is set to true*/
    formatCreateLabel?: (val: string) => string;
    /** If true all levels are shown in the input by simple concatenating the labels */
    displayAllSelectedLevels?: boolean;
    onBlur?: () => void;
    /** When mounted focus automatically on the input */
    autoFocus?: boolean;
    /** Keep the dropdown open all the time, useful in case whole cascader visibility is controlled by the parent */
    alwaysOpen?: boolean;
    /** Don't show what is selected in the cascader input/search. Useful when input is used just as search and the
        cascader is hidden after selection. */
    hideActiveLevelLabel?: boolean;
}
interface CascaderState {
    isSearching: boolean;
    focusCascade: boolean;
    rcValue: SelectableValue<string[]>;
    activeLabel: string;
}
interface CascaderOption {
    /**
     *  The value used under the hood
     */
    value: any;
    /**
     *  The label to display in the UI
     */
    label: string;
    /** Items will be just flattened into the main list of items recursively. */
    items?: CascaderOption[];
    disabled?: boolean;
    /** Avoid using */
    title?: string;
    /**  Children will be shown in a submenu. Use 'items' instead, as 'children' exist to ensure backwards compatibility.*/
    children?: CascaderOption[];
}
declare class Cascader extends PureComponent<CascaderProps, CascaderState> {
    constructor(props: CascaderProps);
    static defaultProps: {
        changeOnSelect: boolean;
    };
    flattenOptions: (options: CascaderOption[], optionPath?: CascaderOption[]) => SelectableValue<string[]>[];
    getSearchableOptions: memoize_one.MemoizedFn<(options: CascaderOption[]) => SelectableValue<string[]>[]>;
    setInitialValue(searchableOptions: Array<SelectableValue<string[]>>, initValue?: string): {
        rcValue: string[];
        activeLabel: any;
    };
    onChange: (value: string[], selectedOptions: CascaderOption[]) => void;
    onSelect: (obj: SelectableValue<string[]>) => void;
    onCreateOption: (value: string) => void;
    onBlur: () => void;
    onBlurCascade: () => void;
    onInputKeyDown: (e: React__default.KeyboardEvent<HTMLInputElement>) => void;
    onSelectInputChange: (value: string) => void;
    render(): JSX.Element;
}

interface ButtonCascaderProps {
    options: CascaderOption[];
    children?: string;
    icon?: IconName;
    disabled?: boolean;
    value?: string[];
    fieldNames?: {
        label: string;
        value: string;
        children: string;
    };
    loadData?: (selectedOptions: CascaderOption[]) => void;
    onChange?: (value: string[], selectedOptions: CascaderOption[]) => void;
    onPopupVisibleChange?: (visible: boolean) => void;
    className?: string;
    variant?: ButtonProps['variant'];
    buttonProps?: ButtonProps;
    hideDownIcon?: boolean;
}
declare const ButtonCascader: {
    (props: ButtonCascaderProps): JSX.Element;
    displayName: string;
};

interface InlineToastProps {
    children: React__default.ReactNode;
    suffixIcon?: IconName;
    referenceElement: HTMLElement | null;
    placement: BasePlacement;
}
declare function InlineToast({ referenceElement, children, suffixIcon, placement }: InlineToastProps): JSX.Element;

/**
 * @public
 */
interface LoadingPlaceholderProps extends HTMLAttributes<HTMLDivElement> {
    text: React__default.ReactNode;
}
/**
 * @public
 */
declare const LoadingPlaceholder: ({ text, className, ...rest }: LoadingPlaceholderProps) => JSX.Element;

interface LoadingBarProps {
    width: number;
    ariaLabel?: string;
}
declare function LoadingBar({ width, ariaLabel }: LoadingBarProps): JSX.Element;

declare type ColorPickerChangeHandler = (color: string) => void;
interface ColorPickerProps extends Themeable2 {
    color: string;
    onChange: ColorPickerChangeHandler;
    enableNamedColors?: boolean;
}

/**
 * If you need custom trigger for the color picker you can do that with a render prop pattern and supply a function
 * as a child. You will get show/hide function which you can map to desired interaction (like onClick or onMouseLeave)
 * and a ref which needs to be passed to an HTMLElement for correct positioning. If you want to use class or functional
 * component as a custom trigger you will need to forward the reference to first HTMLElement child.
 */
declare type ColorPickerTriggerRenderer = (props: {
    ref: React__default.RefObject<any>;
    showColorPicker: () => void;
    hideColorPicker: () => void;
}) => React__default.ReactNode;
declare const ColorPicker: React__default.FunctionComponent<{
    color: string;
    onChange: ColorPickerChangeHandler;
    children?: ColorPickerTriggerRenderer | undefined;
    enableNamedColors?: boolean | undefined;
}>;
declare const SeriesColorPicker: React__default.FunctionComponent<{
    color: string;
    onChange: ColorPickerChangeHandler;
    children?: ColorPickerTriggerRenderer | undefined;
    enableNamedColors?: boolean | undefined;
    updatePopperPosition?: (() => void) | undefined;
    yaxis?: number | undefined;
    onToggleAxis?: (() => void) | undefined;
}>;

interface Props$13 extends Omit<HTMLProps<HTMLInputElement>, 'prefix' | 'size'> {
    /** Sets the width to a multiple of 8px. Should only be used with inline forms. Setting width of the container is preferred in other cases.*/
    width?: number;
    /** Show an invalid state around the input */
    invalid?: boolean;
    /** Show an icon as a prefix in the input */
    prefix?: ReactNode;
    /** Show an icon as a suffix in the input */
    suffix?: ReactNode;
    /** Show a loading indicator as a suffix in the input */
    loading?: boolean;
    /** Add a component as an addon before the input  */
    addonBefore?: ReactNode;
    /** Add a component as an addon after the input */
    addonAfter?: ReactNode;
}
interface StyleDeps {
    theme: GrafanaTheme2;
    invalid?: boolean;
    width?: number;
}
declare const Input: React__default.ForwardRefExoticComponent<Pick<Props$13, "width" | "type" | "hidden" | "name" | "target" | "id" | "label" | "title" | "min" | "max" | "color" | "style" | "role" | "value" | "suffix" | "prefix" | "key" | "data" | "rows" | "action" | "disabled" | "selected" | "shape" | "step" | "pattern" | "form" | "async" | "onChange" | "capture" | "onClick" | "cite" | "slot" | "span" | "summary" | "onBlur" | "readOnly" | "children" | "default" | "className" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlurCapture" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "list" | "height" | "media" | "method" | "crossOrigin" | "href" | "src" | "content" | "useMap" | "invalid" | "htmlFor" | "classID" | "accept" | "alt" | "autoComplete" | "autoFocus" | "checked" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "maxLength" | "minLength" | "multiple" | "required" | "coords" | "download" | "hrefLang" | "rel" | "acceptCharset" | "allowFullScreen" | "allowTransparency" | "as" | "autoPlay" | "cellPadding" | "cellSpacing" | "charSet" | "challenge" | "cols" | "colSpan" | "controls" | "dateTime" | "defer" | "encType" | "frameBorder" | "headers" | "high" | "httpEquiv" | "integrity" | "keyParams" | "keyType" | "kind" | "loop" | "low" | "manifest" | "marginHeight" | "marginWidth" | "mediaGroup" | "muted" | "nonce" | "noValidate" | "open" | "optimum" | "playsInline" | "poster" | "preload" | "reversed" | "rowSpan" | "sandbox" | "scope" | "scoped" | "scrolling" | "seamless" | "sizes" | "srcDoc" | "srcLang" | "srcSet" | "start" | "wmode" | "wrap" | "loading" | "addonBefore" | "addonAfter"> & React__default.RefAttributes<HTMLInputElement>>;
declare const getInputStyles: memoize_one.MemoizedFn<({ theme, invalid, width }: StyleDeps) => {
    wrapper: string;
    inputWrapper: string;
    input: string;
    inputDisabled: string;
    addon: string;
    prefix: string;
    suffix: string;
    loadingIndicator: string;
}>;

interface ColorPickerInputProps extends Omit<Props$13, 'value' | 'onChange'> {
    value?: string;
    onChange: (color: string) => void;
    /** Format for returning the color in onChange callback, defaults to 'rgb' */
    returnColorAs?: 'rgb' | 'hex';
}
declare const ColorPickerInput: React__default.ForwardRefExoticComponent<Pick<ColorPickerInputProps, "width" | "type" | "hidden" | "name" | "target" | "id" | "label" | "title" | "min" | "max" | "color" | "style" | "role" | "value" | "suffix" | "prefix" | "key" | "data" | "rows" | "action" | "disabled" | "selected" | "shape" | "step" | "pattern" | "form" | "async" | "onChange" | "capture" | "onClick" | "cite" | "slot" | "span" | "summary" | "onBlur" | "readOnly" | "children" | "default" | "className" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlurCapture" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "list" | "height" | "media" | "method" | "crossOrigin" | "href" | "src" | "content" | "useMap" | "invalid" | "htmlFor" | "classID" | "accept" | "alt" | "autoComplete" | "autoFocus" | "checked" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "maxLength" | "minLength" | "multiple" | "required" | "coords" | "download" | "hrefLang" | "rel" | "acceptCharset" | "allowFullScreen" | "allowTransparency" | "as" | "autoPlay" | "cellPadding" | "cellSpacing" | "charSet" | "challenge" | "cols" | "colSpan" | "controls" | "dateTime" | "defer" | "encType" | "frameBorder" | "headers" | "high" | "httpEquiv" | "integrity" | "keyParams" | "keyType" | "kind" | "loop" | "low" | "manifest" | "marginHeight" | "marginWidth" | "mediaGroup" | "muted" | "nonce" | "noValidate" | "open" | "optimum" | "playsInline" | "poster" | "preload" | "reversed" | "rowSpan" | "sandbox" | "scope" | "scoped" | "scrolling" | "seamless" | "sizes" | "srcDoc" | "srcLang" | "srcSet" | "start" | "wmode" | "wrap" | "loading" | "addonBefore" | "addonAfter" | "returnColorAs"> & React__default.RefAttributes<HTMLInputElement>>;

interface SeriesColorPickerPopoverProps extends ColorPickerProps, PopoverContentProps {
    yaxis?: number;
    onToggleAxis?: () => void;
}
declare const SeriesColorPickerPopover: (props: SeriesColorPickerPopoverProps) => JSX.Element;
declare const SeriesColorPickerPopoverWithTheme: React__default.FunctionComponent<{
    color: string;
    onChange: ColorPickerChangeHandler;
    enableNamedColors?: boolean | undefined;
    updatePopperPosition?: (() => void) | undefined;
    yaxis?: number | undefined;
    onToggleAxis?: (() => void) | undefined;
}>;

interface Props$12 {
    children: JSX.Element | string;
}
declare const EmptySearchResult: ({ children }: Props$12) => JSX.Element;

interface UnitPickerProps {
    onChange: (item?: string) => void;
    value?: string;
    width?: number;
}
declare class UnitPicker extends PureComponent<UnitPickerProps> {
    onChange: (value: SelectableValue<string>) => void;
    render(): JSX.Element;
}

interface Props$11 {
    placeholder?: string;
    onChange: (stats: string[]) => void;
    stats: string[];
    allowMultiple?: boolean;
    defaultStat?: string;
    className?: string;
    width?: number;
    menuPlacement?: 'auto' | 'bottom' | 'top';
    inputId?: string;
}
declare class StatsPicker extends PureComponent<Props$11> {
    static defaultProps: Partial<Props$11>;
    componentDidMount(): void;
    componentDidUpdate(prevProps: Props$11): void;
    checkInput: () => void;
    onSelectionChange: (item: SelectableValue<string>) => void;
    render(): JSX.Element;
}

declare type CommonProps = {
    /** Icon name */
    icon?: IconName | React__default.ReactNode;
    /** Icon size */
    iconSize?: IconSize;
    /** Tooltip */
    tooltip?: string;
    /** For image icons */
    imgSrc?: string;
    /** Alt text for imgSrc */
    imgAlt?: string;
    /** if true or false will show angle-down/up */
    isOpen?: boolean;
    /** Controls flex-grow: 1 */
    fullWidth?: boolean;
    /** reduces padding to xs */
    narrow?: boolean;
    /** variant */
    variant?: ToolbarButtonVariant;
    /** Hide any children and only show icon */
    iconOnly?: boolean;
    /** Show highlight dot */
    isHighlighted?: boolean;
};
declare type ToolbarButtonVariant = 'default' | 'primary' | 'destructive' | 'active' | 'canvas';
declare const ToolbarButton: React__default.ForwardRefExoticComponent<CommonProps & React__default.ButtonHTMLAttributes<HTMLButtonElement> & React__default.RefAttributes<HTMLButtonElement>>;

interface Props$10 extends HTMLAttributes<HTMLDivElement> {
    className?: string;
    /** Determine flex-alignment of child buttons. Needed for overflow behaviour. */
    alignment?: 'left' | 'right';
}
declare const ToolbarButtonRow: React__default.ForwardRefExoticComponent<Props$10 & React__default.RefAttributes<HTMLDivElement>>;

declare const defaultIntervals: string[];
interface Props$$ {
    intervals?: string[];
    onRefresh?: () => void;
    onIntervalChanged: (interval: string) => void;
    value?: string;
    tooltip?: string;
    isLoading?: boolean;
    isLive?: boolean;
    text?: string;
    noIntervalPicker?: boolean;
    width?: string;
    primary?: boolean;
    isOnCanvas?: boolean;
}
declare class RefreshPicker extends PureComponent<Props$$> {
    static offOption: {
        label: string;
        value: string;
        ariaLabel: string;
    };
    static liveOption: {
        label: string;
        value: string;
        ariaLabel: string;
    };
    static isLive: (refreshInterval?: string) => boolean;
    constructor(props: Props$$);
    onChangeSelect: (item: SelectableValue<string>) => void;
    getVariant(): ToolbarButtonVariant;
    render(): JSX.Element;
}

/** @public */
interface TimeRangePickerProps {
    hideText?: boolean;
    value: TimeRange;
    timeZone?: TimeZone;
    fiscalYearStartMonth?: number;
    timeSyncButton?: JSX.Element;
    isSynced?: boolean;
    onChange: (timeRange: TimeRange) => void;
    onChangeTimeZone: (timeZone: TimeZone) => void;
    onChangeFiscalYearStartMonth?: (month: number) => void;
    onMoveBackward: () => void;
    onMoveForward: () => void;
    onZoom: () => void;
    history?: TimeRange[];
    hideQuickRanges?: boolean;
    widthOverride?: number;
    isOnCanvas?: boolean;
}
declare function TimeRangePicker(props: TimeRangePickerProps): JSX.Element;
declare namespace TimeRangePicker {
    var displayName: string;
}
declare const TimePickerTooltip: ({ timeRange, timeZone }: {
    timeRange: TimeRange;
    timeZone?: string | undefined;
}) => JSX.Element;

declare type FormInputSize = 'sm' | 'md' | 'lg' | 'auto';

interface Props$_ {
    onChange: (value: DateTime) => void;
    value?: DateTime;
    showHour?: boolean;
    showSeconds?: boolean;
    minuteStep?: number;
    size?: FormInputSize;
    disabled?: boolean;
    disabledHours?: () => number[];
    disabledMinutes?: () => number[];
    disabledSeconds?: () => number[];
}
declare const TimeOfDayPicker: ({ minuteStep, showHour, showSeconds, onChange, value, size, disabled, disabledHours, disabledMinutes, disabledSeconds, }: Props$_) => JSX.Element;

interface Props$Z {
    onChange: (timeZone?: TimeZone) => void;
    value?: TimeZone;
    width?: number;
    autoFocus?: boolean;
    onBlur?: () => void;
    includeInternal?: boolean | InternalTimeZones[];
    disabled?: boolean;
    inputId?: string;
}
declare const TimeZonePicker: (props: Props$Z) => JSX.Element;

interface Props$Y {
    onChange: (weekStart: string) => void;
    value: string;
    width?: number;
    autoFocus?: boolean;
    onBlur?: () => void;
    disabled?: boolean;
    inputId?: string;
}
declare const WeekStartPicker: (props: Props$Y) => JSX.Element;

/** @public */
interface DatePickerProps {
    isOpen?: boolean;
    onClose: () => void;
    onChange: (value: Date) => void;
    value?: Date;
    minDate?: Date;
    maxDate?: Date;
}
/** @public */
declare const DatePicker: React__default.NamedExoticComponent<DatePickerProps>;

/** @public */
interface DatePickerWithInputProps extends Omit<Props$13, 'ref' | 'value' | 'onChange'> {
    /** Value selected by the DatePicker */
    value?: Date | string;
    /** The minimum date the value can be set to */
    minDate?: Date;
    /** The maximum date the value can be set to */
    maxDate?: Date;
    /** Handles changes when a new date is selected */
    onChange: (value: Date | string) => void;
    /** Hide the calendar when date is selected */
    closeOnSelect?: boolean;
    /** Text that appears when the input has no text */
    placeholder?: string;
}
/** @public */
declare const DatePickerWithInput: ({ value, minDate, maxDate, onChange, closeOnSelect, placeholder, ...rest }: DatePickerWithInputProps) => JSX.Element;

interface Props$X {
    /** Input date for the component */
    date?: DateTime;
    /** Callback for returning the selected date */
    onChange: (date: DateTime) => void;
    /** label for the input field */
    label?: ReactNode;
    /** Set the latest selectable date */
    maxDate?: Date;
    /** Set the minimum selectable date */
    minDate?: Date;
    /** Display seconds on the time picker */
    showSeconds?: boolean;
    /** Set the hours that can't be selected */
    disabledHours?: () => number[];
    /** Set the minutes that can't be selected */
    disabledMinutes?: () => number[];
    /** Set the seconds that can't be selected */
    disabledSeconds?: () => number[];
}
declare const DateTimePicker: ({ date, maxDate, minDate, label, onChange, disabledHours, disabledMinutes, disabledSeconds, showSeconds, }: Props$X) => JSX.Element;

interface ListProps<T> {
    items: T[];
    renderItem: (item: T, index: number) => JSX.Element;
    getItemKey?: (item: T) => string;
    className?: string;
}

declare class List<T> extends PureComponent<ListProps<T>> {
    render(): JSX.Element;
}

interface Props$W<TableData extends object> {
    /**
     * Table's columns definition. Must be memoized.
     */
    columns: Array<Column<TableData>>;
    /**
     * The data to display in the table. Must be memoized.
     */
    data: TableData[];
    /**
     * Render function for the expanded row. if not provided, the tables rows will not be expandable.
     */
    renderExpandedRow?: (row: TableData) => ReactNode;
    className?: string;
    /**
     * Must return a unique id for each row
     */
    getRowId: TableOptions<TableData>['getRowId'];
}
/** @alpha */
declare function InteractiveTable<TableData extends object>({ data, className, columns, renderExpandedRow, getRowId, }: Props$W<TableData>): JSX.Element;

interface Props$V {
    placeholder?: string;
    /** Array of selected tags */
    tags?: string[];
    onChange: (tags: string[]) => void;
    width?: number;
    id?: string;
    className?: string;
    /** Toggle disabled state */
    disabled?: boolean;
    /** Enable adding new tags when input loses focus */
    addOnBlur?: boolean;
    /** Toggle invalid state */
    invalid?: boolean;
}
declare const TagsInput: ({ placeholder, tags, onChange, width, className, disabled, addOnBlur, invalid, id, }: Props$V) => JSX.Element;

interface Props$U {
    /** The current page index being shown. */
    currentPage: number;
    /** Number of total pages. */
    numberOfPages: number;
    /** Callback function for fetching the selected page.  */
    onNavigate: (toPage: number) => void;
    /** When set to true and the pagination result is only one page it will not render the pagination at all. */
    hideWhenSinglePage?: boolean;
    /** Small version only shows the current page and the navigation buttons. */
    showSmallVersion?: boolean;
    className?: string;
}
declare const Pagination: ({ currentPage, numberOfPages, onNavigate, hideWhenSinglePage, showSmallVersion, className, }: Props$U) => JSX.Element | null;

/**
 * @public
 */
declare type OnTagClick = (name: string, event: React__default.MouseEvent<HTMLElement>) => void;
interface Props$T extends Omit<HTMLAttributes<HTMLElement>, 'onClick'> {
    /** Name of the tag to display */
    name: string;
    icon?: IconName;
    /** Use constant color from TAG_COLORS. Using index instead of color directly so we can match other styling. */
    colorIndex?: number;
    onClick?: OnTagClick;
}
declare const Tag: React__default.ForwardRefExoticComponent<Props$T & React__default.RefAttributes<HTMLElement>>;

interface Props$S {
    /** Maximum number of the tags to display */
    displayMax?: number;
    /** Names of the tags to display */
    tags: string[];
    /** Callback when the tag is clicked */
    onClick?: OnTagClick;
    /** Custom styles for the wrapper component */
    className?: string;
    /** aria-label for the `i`-th Tag component */
    getAriaLabel?: (name: string, i: number) => string;
    /** Icon to show next to tag label */
    icon?: IconName;
}
declare const TagList: React__default.MemoExoticComponent<React__default.ForwardRefExoticComponent<Props$S & React__default.RefAttributes<HTMLUListElement>>>;

interface FilterPillProps {
    selected: boolean;
    label: string;
    onClick: React__default.MouseEventHandler<HTMLElement>;
    icon?: IconName;
}
declare const FilterPill: ({ label, selected, onClick, icon }: FilterPillProps) => JSX.Element;

interface ConfirmModalProps {
    /** Toggle modal's open/closed state */
    isOpen: boolean;
    /** Title for the modal header */
    title: string;
    /** Modal content */
    body: React__default.ReactNode;
    /** Modal description */
    description?: React__default.ReactNode;
    /** Text for confirm button */
    confirmText: string;
    /** Variant for confirm button */
    confirmVariant?: ButtonVariant;
    /** Text for dismiss button */
    dismissText?: string;
    /** Variant for dismiss button */
    dismissVariant?: ButtonVariant;
    /** Icon for the modal header */
    icon?: IconName;
    /** Additional styling for modal container */
    modalClass?: string;
    /** Text user needs to fill in before confirming */
    confirmationText?: string;
    /** Text for alternative button */
    alternativeText?: string;
    /** Confirm button variant */
    confirmButtonVariant?: ButtonVariant;
    /** Confirm action callback */
    onConfirm(): void;
    /** Dismiss action callback */
    onDismiss(): void;
    /** Alternative action callback */
    onAlternative?(): void;
}
declare const ConfirmModal: ({ isOpen, title, body, description, confirmText, confirmVariant, confirmationText, dismissText, dismissVariant, alternativeText, modalClass, icon, onConfirm, onDismiss, onAlternative, confirmButtonVariant, }: ConfirmModalProps) => JSX.Element;

interface QueryFieldProps extends Themeable2 {
    additionalPlugins?: Plugin[];
    cleanText?: (text: string) => string;
    disabled?: boolean;
    query?: string | null;
    onRunQuery?: () => void;
    onBlur?: () => void;
    onChange?: (value: string) => void;
    onRichValueChange?: (value: Value) => void;
    onClick?: EventHook<React__default.MouseEvent<Element, MouseEvent>>;
    onTypeahead?: (typeahead: TypeaheadInput) => Promise<TypeaheadOutput>;
    onWillApplySuggestion?: (suggestion: string, state: SuggestionsState) => string;
    placeholder?: string;
    portalOrigin: string;
    syntax?: string;
    syntaxLoaded?: boolean;
    theme: GrafanaTheme2;
}
declare const QueryField: React__default.FunctionComponent<{
    query?: string | null | undefined;
    disabled?: boolean | undefined;
    onChange?: ((value: string) => void) | undefined;
    onClick?: EventHook<React__default.MouseEvent<Element, MouseEvent>> | undefined;
    onRunQuery?: (() => void) | undefined;
    onBlur?: (() => void) | undefined;
    placeholder?: string | undefined;
    syntax?: string | undefined;
    onTypeahead?: ((typeahead: TypeaheadInput) => Promise<TypeaheadOutput>) | undefined;
    cleanText?: ((text: string) => string) | undefined;
    onWillApplySuggestion?: ((suggestion: string, state: SuggestionsState) => string) | undefined;
    portalOrigin: string;
    additionalPlugins?: Plugin<Editor>[] | undefined;
    onRichValueChange?: ((value: Value) => void) | undefined;
    syntaxLoaded?: boolean | undefined;
}>;

declare type ReactMonacoEditorProps = Omit<EditorProps, 'theme'>;
declare type CodeEditorChangeHandler = (value: string) => void;
declare type CodeEditorSuggestionProvider = () => CodeEditorSuggestionItem[];

declare type Monaco = typeof monacoType;
declare type MonacoEditor = monacoType.editor.IStandaloneCodeEditor;
declare type MonacoOptions = MonacoOptionsWithGrafanaDefaults;
/**
 * @alpha
 */
declare enum CodeEditorSuggestionItemKind {
    Method = "method",
    Field = "field",
    Property = "property",
    Constant = "constant",
    Text = "text"
}
/**
 * @alpha
 */
interface CodeEditorSuggestionItem {
    /**
     * The label of this completion item. By default
     * this is also the text that is inserted when selecting
     * this completion.
     */
    label: string;
    /**
     * The kind of this completion item. An icon is chosen
     * by the editor based on the kind.
     */
    kind?: CodeEditorSuggestionItemKind;
    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    detail?: string;
    /**
     * A human-readable string that represents a doc-comment.
     */
    documentation?: string;
    /**
     * A string or snippet that should be inserted in a document when selecting
     * this completion. When `falsy` the `label` is used.
     */
    insertText?: string;
}
/**
 * This interface will extend the original Monaco editor options interface
 * but changing the code comments to contain the proper default values to
 * prevent the consumer of the CodeEditor to get incorrect documentation in editor.
 */
interface MonacoOptionsWithGrafanaDefaults extends monacoType.editor.IStandaloneEditorConstructionOptions {
    /**
     * Enable custom contextmenu.
     * Defaults to false.
     */
    contextmenu?: boolean;
    /**
     * The number of spaces a tab is equal to.
     * This setting is overridden based on the file contents when `detectIndentation` is on.
     * Defaults to 4.
     */
    tabSize?: number;
    /**
     * Show code lens
     * Defaults to false.
     */
    codeLens?: boolean;
    /**
     * Control the width of line numbers, by reserving horizontal space for rendering at least an amount of digits.
     * Defaults to 4.
     */
    lineNumbersMinChars?: number;
    /**
     * The width reserved for line decorations (in px).
     * Line decorations are placed between line numbers and the editor content.
     * You can pass in a string in the format floating point followed by "ch". e.g. 1.3ch.
     * Defaults to 1 * theme.spacing.gridSize.
     */
    lineDecorationsWidth?: number | string;
    /**
     * Controls if a border should be drawn around the overview ruler.
     * Defaults to `false`.
     */
    overviewRulerBorder?: boolean;
    /**
     * Enable that the editor will install an interval to check if its container dom node size has changed.
     * Enabling this might have a severe performance impact.
     * Defaults to true.
     */
    automaticLayout?: boolean;
}

declare const CodeEditor: React__default.FunctionComponent<{
    width?: string | number | undefined;
    value: string;
    onChange?: CodeEditorChangeHandler | undefined;
    onBlur?: CodeEditorChangeHandler | undefined;
    readOnly?: boolean | undefined;
    height?: string | number | undefined;
    language: string;
    showMiniMap?: boolean | undefined;
    showLineNumbers?: boolean | undefined;
    monacoOptions?: MonacoOptionsWithGrafanaDefaults | undefined;
    onBeforeEditorMount?: ((monaco: typeof monacoType) => void) | undefined;
    onEditorDidMount?: ((editor: monacoType.editor.IStandaloneCodeEditor, monaco: typeof monacoType) => void) | undefined;
    onSave?: CodeEditorChangeHandler | undefined;
    getSuggestions?: CodeEditorSuggestionProvider | undefined;
    containerStyles?: string | undefined;
}>;

/**
 * @internal
 * Experimental export
 **/
declare const ReactMonacoEditorLazy: (props: ReactMonacoEditorProps) => JSX.Element;

/**
 * @alpha
 */
declare function variableSuggestionToCodeEditorSuggestion(sug: VariableSuggestion): CodeEditorSuggestionItem;

interface Props$R {
    /** @deprecated no longer used */
    icon?: IconName;
    /** @deprecated no longer used */
    iconTooltip?: string;
    /** Title for the modal or custom header element */
    title: string | JSX.Element;
    className?: string;
    contentClassName?: string;
    closeOnEscape?: boolean;
    closeOnBackdropClick?: boolean;
    trapFocus?: boolean;
    isOpen?: boolean;
    onDismiss?: () => void;
    /** If not set will call onDismiss if that is set. */
    onClickBackdrop?: () => void;
}
declare function Modal(props: PropsWithChildren<Props$R>): JSX.Element | null;
declare namespace Modal {
    var ButtonRow: typeof ModalButtonRow;
}
declare function ModalButtonRow({ leftItems, children }: {
    leftItems?: React__default.ReactNode;
    children: React__default.ReactNode;
}): JSX.Element;

interface Props$Q {
    title: string;
    id?: string;
    /** @deprecated */
    icon?: IconName;
    /** @deprecated */
    iconTooltip?: string;
}
/** @internal */
declare const ModalHeader: ({ icon, iconTooltip, title, children, id }: React__default.PropsWithChildren<Props$Q>) => JSX.Element;

interface ModalTab {
    value: string;
    label: string;
    icon?: IconName;
    tabSuffix?: NavModelItem['tabSuffix'];
}
interface Props$P {
    icon: IconName;
    title: string;
    tabs: ModalTab[];
    activeTab: string;
    onChangeTab(tab: ModalTab): void;
}
declare const ModalTabsHeader: ({ icon, title, tabs, activeTab, onChangeTab }: Props$P) => JSX.Element;

interface Props$O {
    /** @deprecated */
    icon?: IconName;
    /** @deprecated */
    iconClass?: string;
}
/** @internal */
declare const ModalTabContent: ({ children }: React__default.PropsWithChildren<Props$O>) => JSX.Element;

interface ModalsContextState {
    component: React__default.ComponentType<any> | null;
    props: any;
    showModal: <T>(component: React__default.ComponentType<T>, props: T) => void;
    hideModal: () => void;
}
declare const ModalsContext: React__default.Context<ModalsContextState>;
interface ModalsProviderProps {
    children: React__default.ReactNode;
    /** Set default component to render as modal. Useful when rendering modals from Angular */
    component?: React__default.ComponentType<any> | null;
    /** Set default component props. Useful when rendering modals from Angular */
    props?: any;
}
declare class ModalsProvider extends Component<ModalsProviderProps, ModalsContextState> {
    constructor(props: ModalsProviderProps);
    showModal: (component: React__default.ComponentType<any>, props: any) => void;
    hideModal: () => void;
    render(): JSX.Element;
}
declare const ModalRoot: () => JSX.Element;
declare const ModalsController: React__default.Consumer<ModalsContextState>;

interface Props$N {
    pageIcon?: IconName;
    title?: string;
    section?: string;
    parent?: string;
    onGoBack?: () => void;
    titleHref?: string;
    parentHref?: string;
    leftItems?: ReactNode[];
    children?: ReactNode;
    className?: string;
    isFullscreen?: boolean;
    'aria-label'?: string;
    buttonOverflowAlignment?: 'left' | 'right';
    /**
     * Forces left items to be visible on small screens.
     * By default left items are hidden on small screens.
     */
    forceShowLeftItems?: boolean;
}
/** @alpha */
declare const PageToolbar: React__default.MemoExoticComponent<({ title, section, parent, pageIcon, onGoBack, children, titleHref, parentHref, leftItems, isFullscreen, className, "aria-label": ariaLabel, buttonOverflowAlignment, forceShowLeftItems, }: Props$N) => JSX.Element>;

interface Props$M {
    func: () => unknown;
    loading: boolean;
    interval: string;
}
declare class SetInterval extends PureComponent<Props$M> {
    private propsSubject;
    private subscription;
    constructor(props: Props$M);
    componentDidMount(): void;
    componentDidUpdate(prevProps: Props$M): void;
    componentWillUnmount(): void;
    render(): null;
}

declare const FILTER_FOR_OPERATOR = "=";
declare const FILTER_OUT_OPERATOR = "!=";
declare type AdHocFilterOperator = typeof FILTER_FOR_OPERATOR | typeof FILTER_OUT_OPERATOR;
declare type AdHocFilterItem = {
    key: string;
    value: string;
    operator: AdHocFilterOperator;
};
declare type TableFilterActionCallback = (item: AdHocFilterItem) => void;
declare type TableColumnResizeActionCallback = (fieldDisplayName: string, width: number) => void;
declare type TableSortByActionCallback = (state: TableSortByFieldState[]) => void;
interface TableSortByFieldState {
    displayName: string;
    desc?: boolean;
}
declare type FooterItem = Array<KeyValue<string>> | string | undefined;
interface TableFooterCalc {
    show: boolean;
    reducer: string[];
    fields?: string[];
    enablePagination?: boolean;
    countRows?: boolean;
}
interface Props$L {
    ariaLabel?: string;
    data: DataFrame;
    width: number;
    height: number;
    maxHeight?: number;
    /** Minimal column width specified in pixels */
    columnMinWidth?: number;
    noHeader?: boolean;
    showTypeIcons?: boolean;
    resizable?: boolean;
    initialSortBy?: TableSortByFieldState[];
    onColumnResize?: TableColumnResizeActionCallback;
    onSortByChange?: TableSortByActionCallback;
    onCellFilterAdded?: TableFilterActionCallback;
    footerOptions?: TableFooterCalc;
    footerValues?: FooterItem[];
    enablePagination?: boolean;
    cellHeight?: TableCellHeight;
    /** @alpha */
    subData?: DataFrame[];
}

declare const Table: React__default.MemoExoticComponent<(props: Props$L) => JSX.Element>;

declare const TableInputCSV: React__default.FunctionComponent<{
    width: string | number;
    config?: CSVConfig | undefined;
    text: string;
    height: string | number;
    onSeriesParsed: (data: DataFrame[], text: string) => void;
}>;

interface Props$K {
    /** Children should be a single <Tab /> or an array of <Tab /> */
    children: ReactNode;
    className?: string;
    /** For hiding the bottom border (on PageHeader for example) */
    hideBorder?: boolean;
}
declare const TabsBar: React__default.ForwardRefExoticComponent<Props$K & React__default.RefAttributes<HTMLDivElement>>;

interface TabProps extends HTMLProps<HTMLAnchorElement> {
    label: string;
    active?: boolean;
    /** When provided, it is possible to use the tab as a hyperlink. Use in cases where the tabs update location. */
    href?: string;
    icon?: IconName;
    onChangeTab?: (event?: React__default.MouseEvent<HTMLAnchorElement>) => void;
    /** A number rendered next to the text. Usually used to display the number of items in a tab's view. */
    counter?: number | null;
    /** Extra content, displayed after the tab label and counter */
    suffix?: NavModelItem['tabSuffix'];
}
declare const Tab: React__default.ForwardRefExoticComponent<Pick<TabProps, "width" | "type" | "hidden" | "name" | "target" | "id" | "label" | "icon" | "title" | "min" | "max" | "color" | "style" | "role" | "value" | "suffix" | "prefix" | "key" | "data" | "rows" | "action" | "disabled" | "selected" | "shape" | "step" | "pattern" | "form" | "async" | "onChange" | "capture" | "onClick" | "cite" | "slot" | "span" | "summary" | "onBlur" | "readOnly" | "children" | "default" | "size" | "className" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlurCapture" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "list" | "height" | "media" | "method" | "crossOrigin" | "href" | "src" | "content" | "useMap" | "htmlFor" | "classID" | "accept" | "alt" | "autoComplete" | "autoFocus" | "checked" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "maxLength" | "minLength" | "multiple" | "required" | "active" | "coords" | "download" | "hrefLang" | "rel" | "acceptCharset" | "allowFullScreen" | "allowTransparency" | "as" | "autoPlay" | "cellPadding" | "cellSpacing" | "charSet" | "challenge" | "cols" | "colSpan" | "controls" | "dateTime" | "defer" | "encType" | "frameBorder" | "headers" | "high" | "httpEquiv" | "integrity" | "keyParams" | "keyType" | "kind" | "loop" | "low" | "manifest" | "marginHeight" | "marginWidth" | "mediaGroup" | "muted" | "nonce" | "noValidate" | "open" | "optimum" | "playsInline" | "poster" | "preload" | "reversed" | "rowSpan" | "sandbox" | "scope" | "scoped" | "scrolling" | "seamless" | "sizes" | "srcDoc" | "srcLang" | "srcSet" | "start" | "wmode" | "wrap" | "onChangeTab" | "counter"> & React__default.RefAttributes<HTMLAnchorElement>>;

declare const VerticalTab: React__default.ForwardRefExoticComponent<Pick<TabProps, "width" | "type" | "hidden" | "name" | "target" | "id" | "label" | "icon" | "title" | "min" | "max" | "color" | "style" | "role" | "value" | "suffix" | "prefix" | "key" | "data" | "rows" | "action" | "disabled" | "selected" | "shape" | "step" | "pattern" | "form" | "async" | "onChange" | "capture" | "onClick" | "cite" | "slot" | "span" | "summary" | "onBlur" | "readOnly" | "children" | "default" | "size" | "className" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlurCapture" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "list" | "height" | "media" | "method" | "crossOrigin" | "href" | "src" | "content" | "useMap" | "htmlFor" | "classID" | "accept" | "alt" | "autoComplete" | "autoFocus" | "checked" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "maxLength" | "minLength" | "multiple" | "required" | "active" | "coords" | "download" | "hrefLang" | "rel" | "acceptCharset" | "allowFullScreen" | "allowTransparency" | "as" | "autoPlay" | "cellPadding" | "cellSpacing" | "charSet" | "challenge" | "cols" | "colSpan" | "controls" | "dateTime" | "defer" | "encType" | "frameBorder" | "headers" | "high" | "httpEquiv" | "integrity" | "keyParams" | "keyType" | "kind" | "loop" | "low" | "manifest" | "marginHeight" | "marginWidth" | "mediaGroup" | "muted" | "nonce" | "noValidate" | "open" | "optimum" | "playsInline" | "poster" | "preload" | "reversed" | "rowSpan" | "sandbox" | "scope" | "scoped" | "scrolling" | "seamless" | "sizes" | "srcDoc" | "srcLang" | "srcSet" | "start" | "wmode" | "wrap" | "onChangeTab" | "counter"> & React__default.RefAttributes<HTMLAnchorElement>>;

interface Props$J extends HTMLAttributes<HTMLDivElement> {
    children: ReactNode;
}
declare const TabContent: ({ children, className, ...restProps }: Props$J) => JSX.Element;

interface CounterProps {
    value: number;
}
declare const Counter: ({ value }: CounterProps) => JSX.Element;

interface RenderUserContentAsHTMLProps<T = HTMLSpanElement> extends Omit<HTMLAttributes<T>, 'dangerouslySetInnerHTML'> {
    component?: keyof React__default.ReactHTML;
    content: string;
}
declare function RenderUserContentAsHTML<T>({ component, content, ...rest }: PropsWithChildren<RenderUserContentAsHTMLProps<T>>): JSX.Element;

declare enum BigValueColorMode {
    Background = "background",
    BackgroundSolid = "background_solid",
    None = "none",
    Value = "value"
}
declare enum BigValueGraphMode {
    None = "none",
    Line = "line",
    Area = "area"
}
declare enum BigValueJustifyMode {
    Auto = "auto",
    Center = "center"
}
/**
 * Options for how the value & title are to be displayed
 */
declare enum BigValueTextMode {
    Auto = "auto",
    Value = "value",
    ValueAndName = "value_and_name",
    Name = "name",
    None = "none"
}
interface Props$I extends Themeable2 {
    /** Height of the component */
    height: number;
    /** Width of the component */
    width: number;
    /** Value displayed as Big Value */
    value: DisplayValue;
    /** Sparkline values for showing a graph under/behind the value  */
    sparkline?: FieldSparkline;
    /** onClick handler for the value */
    onClick?: React__default.MouseEventHandler<HTMLElement>;
    /** Custom styling */
    className?: string;
    /** Color mode for coloring the value or the background */
    colorMode: BigValueColorMode;
    /** Show a graph behind/under the value */
    graphMode: BigValueGraphMode;
    /** Auto justify value and text or center it */
    justifyMode?: BigValueJustifyMode;
    /** Factors that should influence the positioning of the text  */
    alignmentFactors?: DisplayValueAlignmentFactors;
    /** Explicit font size control */
    text?: VizTextDisplayOptions;
    /** Specify which text should be visible in the BigValue */
    textMode?: BigValueTextMode;
    /** If true disables the tooltip */
    hasLinks?: boolean;
    /** The orientation of the parent container */
    parentOrientation?: VizOrientation;
    /**
     * If part of a series of stat panes, this is the total number.
     * Used by BigValueTextMode.Auto text mode.
     */
    count?: number;
}
declare class BigValue extends PureComponent<Props$I> {
    static defaultProps: Partial<Props$I>;
    render(): JSX.Element;
}

declare type PlotConfig = Pick<Options, 'mode' | 'series' | 'scales' | 'axes' | 'cursor' | 'bands' | 'hooks' | 'select' | 'tzDate' | 'padding'>;
declare type FacetValues = any[];
declare type FacetSeries = FacetValues[];
declare type FacetedData = [_: null, ...series: FacetSeries];
interface PlotProps {
    data: AlignedData | FacetedData;
    width: number;
    height: number;
    config: UPlotConfigBuilder;
    timeRange: TimeRange;
    children?: React__default.ReactNode;
    plotRef?: (u: uPlot) => void;
}
declare abstract class PlotConfigBuilder<P, T> {
    props: P;
    constructor(props: P);
    abstract getConfig(): T;
}
/**
 * @alpha
 */
declare type PlotTooltipInterpolator = (updateActiveSeriesIdx: (sIdx: number | null) => void, updateActiveDatapointIdx: (dIdx: number | null) => void, updateTooltipPosition: (clear?: boolean) => void, u: uPlot) => void;
interface PlotSelection {
    min: number;
    max: number;
    bbox: {
        top: number;
        left: number;
        width: number;
        height: number;
    };
}

/** @internal */
interface StackingGroup {
    series: number[];
    dir: StackDirection;
}
/** @internal */
declare const enum StackDirection {
    Pos = 1,
    Neg = -1
}

interface AxisProps {
    scaleKey: string;
    theme: GrafanaTheme2;
    label?: string;
    show?: boolean;
    size?: number | null;
    gap?: number;
    tickLabelRotation?: number;
    placement?: AxisPlacement;
    grid?: Axis.Grid;
    ticks?: Axis.Ticks;
    filter?: Axis.Filter;
    space?: Axis.Space;
    formatValue?: (v: any, decimals?: DecimalCount) => string;
    incrs?: Axis.Incrs;
    splits?: Axis.Splits;
    values?: Axis.Values;
    isTime?: boolean;
    timeZone?: TimeZone;
    color?: uPlot.Axis.Stroke;
    border?: uPlot.Axis.Border;
    decimals?: DecimalCount;
    distr?: ScaleDistribution;
}
declare const UPLOT_AXIS_FONT_SIZE = 12;

interface ScaleProps {
    scaleKey: string;
    isTime?: boolean;
    min?: number | null;
    max?: number | null;
    softMin?: number | null;
    softMax?: number | null;
    range?: Scale.Range;
    distribution?: ScaleDistribution;
    orientation: ScaleOrientation;
    direction: ScaleDirection;
    log?: number;
    linearThreshold?: number;
    centeredZero?: boolean;
    decimals?: DecimalCount;
}

interface SeriesProps extends LineConfig, BarConfig, FillConfig, PointsConfig {
    scaleKey: string;
    pxAlign?: boolean;
    gradientMode?: GraphGradientMode;
    dynamicSeriesColor?: (seriesIdx: number) => string | undefined;
    facets?: uPlot.Series.Facet[];
    /** Used when gradientMode is set to Scheme */
    thresholds?: ThresholdsConfig;
    colorMode?: FieldColorMode;
    hardMin?: number | null;
    hardMax?: number | null;
    softMin?: number | null;
    softMax?: number | null;
    drawStyle?: GraphDrawStyle;
    pathBuilder?: Series.PathBuilder | null;
    pointsFilter?: Series.Points.Filter | null;
    pointsBuilder?: Series.Points.Show | null;
    show?: boolean;
    dataFrameFieldIndex?: DataFrameFieldIndex;
    theme: GrafanaTheme2;
    value?: uPlot.Series.Value;
}
declare class UPlotSeriesBuilder extends PlotConfigBuilder<SeriesProps, Series> {
    getConfig(): {
        show: boolean;
        class?: string | undefined;
        scale: string;
        auto?: boolean | undefined;
        sorted?: Series.Sorted | undefined;
        spanGaps: boolean | undefined;
        gaps?: Series.GapsRefiner | undefined;
        pxAlign: number | boolean | undefined;
        label?: string | undefined;
        value: Series.Value;
        values?: Series.Values | undefined;
        paths?: Series.PathBuilder | undefined;
        points?: Series.Points | undefined;
        facets: Series.Facet[] | undefined;
        width?: number | undefined;
        stroke?: Series.Stroke | undefined;
        fill: Series.Fill | undefined;
        fillTo?: Series.FillTo | undefined;
        dash?: number[] | undefined;
        cap?: CanvasLineCap | undefined;
        alpha?: number | undefined;
        idxs?: Series.MinMaxIdxs | undefined;
        min?: number | undefined;
        max?: number | undefined;
    };
    private getLineColor;
    private getFill;
}

interface UPlotThresholdOptions {
    scaleKey: string;
    thresholds: ThresholdsConfig;
    config: GraphThresholdsStyleConfig;
    theme: GrafanaTheme2;
    hardMin?: number | null;
    hardMax?: number | null;
    softMin?: number | null;
    softMax?: number | null;
}

declare type PrepData = (frames: DataFrame[]) => AlignedData | FacetedData;
declare type PreDataStacked = (frames: DataFrame[], stackingGroups: StackingGroup[]) => AlignedData | FacetedData;
declare class UPlotConfigBuilder {
    series: UPlotSeriesBuilder[];
    private axes;
    private scales;
    private bands;
    private stackingGroups;
    private cursor;
    private select;
    private hasLeftAxis;
    private hooks;
    private tz;
    private sync;
    private mode;
    private frames;
    private thresholds;
    private tooltipInterpolator;
    private padding?;
    prepData: PrepData | undefined;
    constructor(timeZone?: TimeZone);
    scaleKeys: [string, string];
    addHook<T extends keyof Hooks.Defs>(type: T, hook: Hooks.Defs[T]): void;
    addThresholds(options: UPlotThresholdOptions): void;
    addAxis(props: AxisProps): void;
    getAxisPlacement(scaleKey: string): AxisPlacement;
    setCursor(cursor?: Cursor): void;
    setMode(mode: uPlot.Mode): void;
    setSelect(select: Select$2): void;
    addSeries(props: SeriesProps): void;
    getSeries(): UPlotSeriesBuilder[];
    /** Add or update the scale with the scale key */
    addScale(props: ScaleProps): void;
    addBand(band: Band): void;
    setStackingGroups(groups: StackingGroup[]): void;
    getStackingGroups(): StackingGroup[];
    setTooltipInterpolator(interpolator: PlotTooltipInterpolator): void;
    getTooltipInterpolator(): PlotTooltipInterpolator | undefined;
    setPrepData(prepData: PreDataStacked): void;
    setSync(): void;
    hasSync(): boolean;
    setPadding(padding: Padding): void;
    getConfig(): PlotConfig;
    private tzDate;
    private ensureNonOverlappingAxes;
}
declare type Renderers = Array<{
    fieldMap: Record<string, string>;
    indicesOnly: string[];
    init: (config: UPlotConfigBuilder, fieldIndices: Record<string, number>) => void;
}>;
/** @alpha */
declare type UPlotConfigPrepOpts<T extends Record<string, any> = {}> = {
    frame: DataFrame;
    theme: GrafanaTheme2;
    timeZones: TimeZone[];
    getTimeRange: () => TimeRange;
    eventBus: EventBus;
    allFrames: DataFrame[];
    renderers?: Renderers;
    tweakScale?: (opts: ScaleProps, forField: Field$1) => ScaleProps;
    tweakAxis?: (opts: AxisProps, forField: Field$1) => AxisProps;
} & T;
/** @alpha */
declare type UPlotConfigPrepFn<T extends {} = {}> = (opts: UPlotConfigPrepOpts<T>) => UPlotConfigBuilder;

interface SparklineProps extends Themeable2 {
    width: number;
    height: number;
    config?: FieldConfig<GraphFieldConfig>;
    sparkline: FieldSparkline;
}
interface State$4 {
    data: AlignedData;
    alignedDataFrame: DataFrame;
    configBuilder: UPlotConfigBuilder;
}
/** @internal */
declare class Sparkline extends PureComponent<SparklineProps, State$4> {
    constructor(props: SparklineProps);
    static getDerivedStateFromProps(props: SparklineProps, state: State$4): {
        data: AlignedData;
        alignedDataFrame: DataFrame;
        configBuilder: UPlotConfigBuilder;
    };
    componentDidUpdate(prevProps: SparklineProps, prevState: State$4): void;
    getYRange(field: Field$1): Range.MinMax;
    prepareConfig(data: DataFrame): UPlotConfigBuilder;
    render(): JSX.Element;
}

interface Props$H {
    height: number;
    field: FieldConfig;
    showThresholdMarkers: boolean;
    showThresholdLabels: boolean;
    width: number;
    value: DisplayValue;
    text?: VizTextDisplayOptions;
    onClick?: React__default.MouseEventHandler<HTMLElement>;
    className?: string;
    theme: GrafanaTheme2;
}
declare class Gauge extends PureComponent<Props$H> {
    canvasElement: HTMLDivElement | null;
    static defaultProps: Partial<Props$H>;
    componentDidMount(): void;
    componentDidUpdate(): void;
    draw(): void;
    renderVisualization: () => JSX.Element;
    render(): JSX.Element;
}

interface FlotPosition {
    pageX: number;
    pageY: number;
    x: number;
    x1: number;
    y: number;
    y1: number;
}
interface FlotItem<T> {
    datapoint: [number, number];
    dataIndex: number;
    series: T;
    seriesIndex: number;
    pageX: number;
    pageY: number;
}

declare type ActiveDimensions<T extends Dimensions = any> = {
    [key in keyof T]: [number, number | undefined] | null;
};
interface VizTooltipContentProps<T extends Dimensions = any> {
    dimensions: T;
    activeDimensions?: ActiveDimensions<T>;
    timeZone?: TimeZone;
    pos: FlotPosition;
    mode: TooltipDisplayMode;
}
interface VizTooltipProps {
    /** Element used as tooltips content */
    content?: React__default.ReactElement;
    /** Optional component to be used as a tooltip content */
    tooltipComponent?: React__default.ComponentType<React__default.PropsWithChildren<VizTooltipContentProps>>;
    /** x/y position relative to the window */
    position?: {
        x: number;
        y: number;
    };
    /** x/y offset relative to tooltip origin element, i.e. graph's datapoint */
    offset?: {
        x: number;
        y: number;
    };
    mode?: TooltipDisplayMode;
}
/**
 * @public
 */
declare const VizTooltip: {
    ({ content, position, offset }: VizTooltipProps): JSX.Element | null;
    displayName: string;
};

/**
 * @public
 */
interface VizTooltipContainerProps extends HTMLAttributes<HTMLDivElement> {
    position: {
        x: number;
        y: number;
    };
    offset: {
        x: number;
        y: number;
    };
    children?: React__default.ReactNode;
    allowPointerEvents?: boolean;
}
/**
 * @public
 */
declare const VizTooltipContainer: {
    ({ position: { x: positionX, y: positionY }, offset: { x: offsetX, y: offsetY }, children, allowPointerEvents, className, ...otherProps }: VizTooltipContainerProps): JSX.Element;
    displayName: string;
};

/**
 * @public
 */
interface SeriesTableRowProps {
    color?: string;
    label?: React__default.ReactNode;
    value?: string | GraphSeriesValue;
    isActive?: boolean;
}
/**
 * @public
 */
declare const SeriesTableRow: ({ color, label, value, isActive }: SeriesTableRowProps) => JSX.Element;
/**
 * @public
 */
interface SeriesTableProps {
    timestamp?: string | GraphSeriesValue;
    series: SeriesTableRowProps[];
}
/**
 * @public
 */
declare const SeriesTable: ({ timestamp, series }: SeriesTableProps) => JSX.Element;

interface GraphProps {
    ariaLabel?: string;
    children?: JSX.Element | JSX.Element[];
    series: GraphSeriesXY[];
    timeRange: TimeRange;
    timeZone?: TimeZone;
    showLines?: boolean;
    showPoints?: boolean;
    showBars?: boolean;
    width: number;
    height: number;
    isStacked?: boolean;
    lineWidth?: number;
    onHorizontalRegionSelected?: (from: number, to: number) => void;
}
interface GraphState {
    pos?: FlotPosition;
    contextPos?: FlotPosition;
    isTooltipVisible: boolean;
    isContextVisible: boolean;
    activeItem?: FlotItem<GraphSeriesXY>;
    contextItem?: FlotItem<GraphSeriesXY>;
}
/**
 * This is a react wrapper for the angular, flot based graph visualization.
 * Rather than using this component, you should use the `<PanelRender .../> with
 * timeseries panel configs.
 *
 * @deprecated
 */
declare class Graph extends PureComponent<GraphProps, GraphState> {
    static defaultProps: {
        showLines: boolean;
        showPoints: boolean;
        showBars: boolean;
        isStacked: boolean;
        lineWidth: number;
    };
    state: GraphState;
    element: HTMLElement | null;
    $element: any;
    componentDidUpdate(prevProps: GraphProps, prevState: GraphState): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    onPlotSelected: (event: JQueryEventObject, ranges: {
        xaxis: {
            from: number;
            to: number;
        };
    }) => void;
    onPlotHover: (event: JQueryEventObject, pos: FlotPosition, item?: FlotItem<GraphSeriesXY>) => void;
    onPlotClick: (event: JQueryEventObject, contextPos: FlotPosition, item?: FlotItem<GraphSeriesXY>) => void;
    getYAxes(series: GraphSeriesXY[]): {
        show: boolean;
        index: number;
        position: string;
        min: number | null;
        tickDecimals: number | null;
    }[] | {
        show: boolean;
        min: number;
        max: number;
    }[];
    renderTooltip: () => React__default.ReactElement<VizTooltipProps, string | React__default.JSXElementConstructor<any>> | null;
    renderContextMenu: () => JSX.Element | null;
    getBarWidth: () => number;
    draw(): void;
    render(): JSX.Element;
}

interface GraphWithLegendProps extends GraphProps {
    legendDisplayMode: LegendDisplayMode;
    legendVisibility: boolean;
    placement: LegendPlacement;
    hideEmpty?: boolean;
    hideZero?: boolean;
    sortLegendBy?: string;
    sortLegendDesc?: boolean;
    onSeriesToggle?: (label: string, event: React__default.MouseEvent<HTMLElement>) => void;
    onToggleSort: (sortBy: string) => void;
}
declare const GraphWithLegend: (props: GraphWithLegendProps) => JSX.Element;

interface ContextMenuProps {
    /** Starting horizontal position for the menu */
    x: number;
    /** Starting vertical position for the menu */
    y: number;
    /** Callback for closing the menu */
    onClose?: () => void;
    /** On menu open focus the first element */
    focusOnOpen?: boolean;
    /** RenderProp function that returns menu items to display */
    renderMenuItems?: () => React__default.ReactNode;
    /** A function that returns header element */
    renderHeader?: () => React__default.ReactNode;
}
declare const ContextMenu: React__default.MemoExoticComponent<({ x, y, onClose, focusOnOpen, renderMenuItems, renderHeader }: ContextMenuProps) => JSX.Element>;

/** @internal */
interface MenuItemsGroup<T = any> {
    /** Label for the menu items group */
    label?: string;
    /** Aria label for accessibility support */
    ariaLabel?: string;
    /** Items of the group */
    items: Array<MenuItemProps<T>>;
}
/** @internal */
interface MenuGroupProps extends Partial<MenuItemsGroup> {
    /** special children prop to pass children elements */
    children: React__default.ReactNode;
}
/** @internal */
declare const MenuGroup: {
    ({ label, ariaLabel, children }: MenuGroupProps): JSX.Element;
    displayName: string;
};

interface GraphDimensions extends Dimensions {
    xAxis: Dimension<number>;
    yAxis: Dimension<number>;
}

declare type ContextDimensions<T extends Dimensions = any> = {
    [key in keyof T]: [number, number | undefined] | null;
};
declare type GraphContextMenuProps = ContextMenuProps & {
    getContextMenuSource: () => FlotDataPoint | null;
    timeZone?: TimeZone;
    itemsGroup?: MenuGroupProps[];
    dimensions?: GraphDimensions;
    contextDimensions?: ContextDimensions;
};
/** @internal */
declare const GraphContextMenu: ({ getContextMenuSource, timeZone, itemsGroup, dimensions, contextDimensions, ...otherProps }: GraphContextMenuProps) => JSX.Element;
/** @internal */
declare const GraphContextMenuHeader: ({ timestamp, seriesColor, displayName, displayValue, }: {
    timestamp: string;
    seriesColor: string;
    displayName: string;
    displayValue: FormattedValue;
}) => JSX.Element;

interface Props$G extends Themeable2 {
    height: number;
    width: number;
    field: FieldConfig;
    display?: DisplayProcessor;
    value: DisplayValue;
    orientation: VizOrientation;
    text?: VizTextDisplayOptions;
    itemSpacing?: number;
    lcdCellWidth?: number;
    displayMode: BarGaugeDisplayMode;
    onClick?: React__default.MouseEventHandler<HTMLElement>;
    className?: string;
    showUnfilled?: boolean;
    alignmentFactors?: DisplayValueAlignmentFactors;
    valueDisplayMode?: BarGaugeValueMode;
}
declare class BarGauge extends PureComponent<Props$G> {
    static defaultProps: Partial<Props$G>;
    render(): JSX.Element;
    renderBarAndValue(): React__default.ReactNode;
    renderBasicAndGradientBars(): ReactNode;
    renderRetroBars(): ReactNode;
}

interface Props$F<V, D> {
    /**
     * Optionally precalculate dimensions to support consistent behavior between repeated
     * values.  Two typical patterns are:
     * 1) Calculate raw values like font size etc and pass them to each vis
     * 2) find the maximum input values and pass that to the vis
     */
    getAlignmentFactors?: (values: V[], width: number, height: number) => D;
    /**
     * Render a single value
     */
    renderValue: (props: VizRepeaterRenderValueProps<V, D>) => JSX.Element;
    height: number;
    width: number;
    source: unknown;
    getValues: () => V[];
    renderCounter: number;
    orientation: VizOrientation;
    itemSpacing?: number;
    /** When orientation is set to auto layout items in a grid */
    autoGrid?: boolean;
    minVizWidth?: number;
    minVizHeight?: number;
}
interface VizRepeaterRenderValueProps<V, D = {}> {
    value: V;
    width: number;
    height: number;
    orientation: VizOrientation;
    alignmentFactors: D;
    /**
     * Total number of values being shown in repeater
     */
    count: number;
}
interface DefaultProps {
    itemSpacing: number;
}
interface State$3<V> {
    values: V[];
}
declare class VizRepeater<V, D = {}> extends PureComponent<Props$F<V, D>, State$3<V>> {
    static defaultProps: DefaultProps;
    constructor(props: Props$F<V, D>);
    componentDidUpdate(prevProps: Props$F<V, D>): void;
    getOrientation(): VizOrientation;
    renderGrid(): JSX.Element;
    render(): JSX.Element;
}

declare const graphTickFormatter: (epoch: number, axis: any) => string;
declare const graphTimeFormat: (ticks: number | null, min: number | null, max: number | null) => string;

/**
 * @internal
 */
declare type ErrorIndicatorProps = {
    error?: string;
    onClick?: () => void;
};
/**
 * @internal
 */
declare const ErrorIndicator: ({ error, onClick }: ErrorIndicatorProps) => JSX.Element | null;

/**
 * @internal
 */
declare type LoadingIndicatorProps = {
    loading: boolean;
    onCancel: () => void;
};
/**
 * @internal
 */
declare const LoadingIndicator: ({ onCancel, loading }: LoadingIndicatorProps) => JSX.Element | null;

/**
 * @internal
 */
interface PanelChromeProps {
    width: number;
    height: number;
    children: (innerWidth: number, innerHeight: number) => ReactNode;
    padding?: PanelPadding;
    hoverHeaderOffset?: number;
    title?: string;
    description?: string | (() => string);
    titleItems?: ReactNode;
    menu?: ReactElement | (() => ReactElement);
    dragClass?: string;
    dragClassCancel?: string;
    hoverHeader?: boolean;
    /**
     * Use only to indicate loading or streaming data in the panel.
     * Any other values of loadingState are ignored.
     */
    loadingState?: LoadingState;
    /**
     * Used to display status message (used for panel errors currently)
     */
    statusMessage?: string;
    /**
     * Handle opening error details view (like inspect / error tab)
     */
    statusMessageOnClick?: (e: React__default.SyntheticEvent) => void;
    /**
     * @deprecated use `actions' instead
     **/
    leftItems?: ReactNode[];
    actions?: ReactNode;
    displayMode?: 'default' | 'transparent';
    onCancelQuery?: () => void;
    /**
     * callback when opening the panel menu
     */
    onOpenMenu?: () => void;
}
/**
 * @internal
 */
declare type PanelPadding = 'none' | 'md';

declare type TitleItemProps = {
    className?: string;
    children: React__default.ReactNode;
    onClick?: LinkModel['onClick'];
    href?: string;
    target?: LinkTarget;
    title?: string;
};
declare type TitleItemElement = HTMLAnchorElement & HTMLButtonElement;
declare const TitleItem: React__default.ForwardRefExoticComponent<TitleItemProps & React__default.RefAttributes<TitleItemElement>>;

/** @alpha */
interface PanelContext {
    eventBus: EventBus;
    /** Dashboard panels sync */
    sync?: () => DashboardCursorSync;
    /** Information on what the outer container is */
    app?: CoreApp | 'string';
    /**
     * Called when a component wants to change the color for a series
     *
     * @alpha -- experimental
     */
    onSeriesColorChange?: (label: string, color: string) => void;
    onToggleSeriesVisibility?: (label: string, mode: SeriesVisibilityChangeMode) => void;
    canAddAnnotations?: () => boolean;
    canEditAnnotations?: (dashboardUID?: string) => boolean;
    canDeleteAnnotations?: (dashboardUID?: string) => boolean;
    onAnnotationCreate?: (annotation: AnnotationEventUIModel) => void;
    onAnnotationUpdate?: (annotation: AnnotationEventUIModel) => void;
    onAnnotationDelete?: (id: string) => void;
    /**
     * Used from visualizations like Table to add ad-hoc filters from cell values
     */
    onAddAdHocFilter?: (item: AdHocFilterItem) => void;
    /**
     * Enables modifying thresholds directly from the panel
     *
     * @alpha -- experimental
     */
    canEditThresholds?: boolean;
    /**
     * Shows threshold indicators on the right-hand side of the panel
     *
     * @alpha -- experimental
     */
    showThresholds?: boolean;
    /**
     * Called when a panel wants to change default thresholds configuration
     *
     * @alpha -- experimental
     */
    onThresholdsChange?: (thresholds: ThresholdsConfig) => void;
    /**
     * onSplitOpen is used in Explore to open the split view. It can be used in panels which has intercations and used in Explore as well.
     * For example TimeSeries panel.
     */
    onSplitOpen?: SplitOpen;
    /** For instance state that can be shared between panel & options UI  */
    instanceState?: any;
    /** Update instance state, this is only supported in dashboard panel context currently */
    onInstanceStateChange?: (state: any) => void;
    /**
     * Called when a panel is changing the sort order of the legends.
     */
    onToggleLegendSort?: (sortBy: string) => void;
}
declare const PanelContextRoot: React__default.Context<PanelContext>;
/**
 * @alpha
 */
declare const PanelContextProvider: React__default.Provider<PanelContext>;
/**
 * @alpha
 */
declare const usePanelContext: () => PanelContext;

/**
 * Mode to describe if a legend is isolated/selected or being appended to an existing
 * series selection.
 * @alpha
 */
declare enum SeriesVisibilityChangeMode {
    ToggleSelection = "select",
    AppendToSelection = "append"
}

/**
 * @internal
 */
interface PanelChromeType extends React__default.FC<PanelChromeProps> {
    LoadingIndicator: typeof LoadingIndicator;
    ErrorIndicator: typeof ErrorIndicator;
    TitleItem: typeof TitleItem;
}
/**
 * @internal
 */
declare const PanelChrome: PanelChromeType;

/**
 * @beta
 */
interface VizLayoutProps {
    width: number;
    height: number;
    legend?: React__default.ReactElement<VizLayoutLegendProps> | null;
    children: (width: number, height: number) => React__default.ReactNode;
}
/**
 * @beta
 */
interface VizLayoutComponentType extends FC<VizLayoutProps> {
    Legend: ComponentType<VizLayoutLegendProps>;
}
/**
 * @beta
 */
declare const VizLayout: VizLayoutComponentType;
/**
 * @beta
 */
interface VizLayoutLegendProps {
    placement: LegendPlacement;
    children: React__default.ReactNode;
    maxHeight?: string;
    maxWidth?: string;
    width?: number;
}

declare enum SeriesVisibilityChangeBehavior {
    Isolate = 0,
    Hide = 1
}
interface VizLegendBaseProps<T> {
    placement: LegendPlacement;
    className?: string;
    items: Array<VizLegendItem<T>>;
    seriesVisibilityChangeBehavior?: SeriesVisibilityChangeBehavior;
    onLabelClick?: (item: VizLegendItem<T>, event: React__default.MouseEvent<HTMLButtonElement>) => void;
    itemRenderer?: (item: VizLegendItem<T>, index: number) => JSX.Element;
    onLabelMouseOver?: (item: VizLegendItem, event: React__default.MouseEvent<HTMLButtonElement> | React__default.FocusEvent<HTMLButtonElement>) => void;
    onLabelMouseOut?: (item: VizLegendItem, event: React__default.MouseEvent<HTMLButtonElement> | React__default.FocusEvent<HTMLButtonElement>) => void;
    readonly?: boolean;
}
interface VizLegendTableProps<T> extends VizLegendBaseProps<T> {
    sortBy?: string;
    sortDesc?: boolean;
    onToggleSort?: (sortBy: string) => void;
}
interface LegendProps<T = any> extends VizLegendBaseProps<T>, VizLegendTableProps<T> {
    displayMode: LegendDisplayMode;
}
interface VizLegendItem<T = any> {
    getItemKey?: () => string;
    label: string;
    color?: string;
    gradient?: string;
    yAxis: number;
    disabled?: boolean;
    getDisplayValues?: () => DisplayValue[];
    fieldIndex?: DataFrameFieldIndex;
    data?: T;
}

/**
 * @public
 */
declare function VizLegend<T>({ items, displayMode, sortBy: sortKey, seriesVisibilityChangeBehavior, sortDesc, onLabelClick, onToggleSort, placement, className, itemRenderer, readonly, }: LegendProps<T>): JSX.Element | null;
declare namespace VizLegend {
    var displayName: string;
}

interface Props$E<T> {
    item: VizLegendItem<T>;
    className?: string;
    onLabelClick?: (item: VizLegendItem<T>, event: React__default.MouseEvent<HTMLButtonElement>) => void;
    onLabelMouseOver?: (item: VizLegendItem, event: React__default.MouseEvent<HTMLButtonElement> | React__default.FocusEvent<HTMLButtonElement>) => void;
    onLabelMouseOut?: (item: VizLegendItem, event: React__default.MouseEvent<HTMLButtonElement> | React__default.FocusEvent<HTMLButtonElement>) => void;
    readonly?: boolean;
}
/**
 * @internal
 */
declare const VizLegendListItem: {
    <T = unknown>({ item, onLabelClick, onLabelMouseOver, onLabelMouseOut, className, readonly, }: Props$E<T>): JSX.Element;
    displayName: string;
};

declare type AlertVariant = 'success' | 'warning' | 'error' | 'info';
interface Props$D extends HTMLAttributes<HTMLDivElement> {
    title: string;
    /** On click handler for alert button, mostly used for dismissing the alert */
    onRemove?: (event: React__default.MouseEvent) => void;
    severity?: AlertVariant;
    children?: ReactNode;
    elevated?: boolean;
    buttonContent?: React__default.ReactNode | string;
    bottomSpacing?: number;
    topSpacing?: number;
}
declare const Alert: React__default.ForwardRefExoticComponent<Props$D & React__default.RefAttributes<HTMLDivElement>>;

interface GraphSeriesTogglerAPI {
    onSeriesToggle: (label: string, event: React__default.MouseEvent<HTMLElement>) => void;
    toggledSeries: GraphSeriesXY[];
}
interface GraphSeriesTogglerProps {
    children: (api: GraphSeriesTogglerAPI) => JSX.Element;
    series: GraphSeriesXY[];
    onHiddenSeriesChanged?: (hiddenSeries: string[]) => void;
}
interface GraphSeriesTogglerState {
    hiddenSeries: string[];
    toggledSeries: GraphSeriesXY[];
}
declare class GraphSeriesToggler extends Component<GraphSeriesTogglerProps, GraphSeriesTogglerState> {
    constructor(props: GraphSeriesTogglerProps);
    componentDidUpdate(prevProps: Readonly<GraphSeriesTogglerProps>): void;
    onSeriesToggle(label: string, event: React__default.MouseEvent<HTMLElement>): void;
    render(): JSX.Element;
}

interface Props$C {
    /** Expand or collapse te content */
    isOpen?: boolean;
    /** Element or text for the Collapse header */
    label: React__default.ReactNode;
    /** Indicates loading state of the content */
    loading?: boolean;
    /** Toggle collapsed header icon */
    collapsible?: boolean;
    /** Callback for the toggle functionality */
    onToggle?: (isOpen: boolean) => void;
    /** Additional class name for the root element */
    className?: string;
}
declare const ControlledCollapse: ({ isOpen, onToggle, ...otherProps }: React__default.PropsWithChildren<Props$C>) => JSX.Element;
declare const Collapse: {
    ({ isOpen, label, loading, collapsible, onToggle, className, children, }: React__default.PropsWithChildren<Props$C>): JSX.Element;
    displayName: string;
};

interface Props$B {
    label: ReactNode;
    isOpen: boolean;
    /** Callback for the toggle functionality */
    onToggle?: (isOpen: boolean) => void;
    children: ReactNode;
    className?: string;
    contentClassName?: string;
    loading?: boolean;
    labelId?: string;
    headerDataTestId?: string;
    contentDataTestId?: string;
}
declare const CollapsableSection: ({ label, isOpen, onToggle, className, contentClassName, children, labelId, loading, headerDataTestId, contentDataTestId, }: Props$B) => JSX.Element;

interface Props$A {
    labels: Labels;
}
/** @deprecated will be removed in the next major version */
declare const LogLabels: ({ labels }: Props$A) => JSX.Element;

/** @deprecated will be removed in the next major version */
declare const LogMessageAnsi: React__default.FunctionComponent<{
    value: string;
    highlight?: {
        searchWords: string[];
        highlightClassName: string;
    } | undefined;
}>;

/** @deprecated will be removed in the next major version */
interface RowContextOptions {
    direction?: 'BACKWARD' | 'FORWARD';
    limit?: number;
}

/** @deprecated will be removed in the next major version */
declare const LogRows: React__default.FunctionComponent<{
    timeZone: TimeZone;
    wrapLogMessage: boolean;
    onClickFilterLabel?: ((key: string, value: string) => void) | undefined;
    onClickFilterOutLabel?: ((key: string, value: string) => void) | undefined;
    showDetectedFields?: string[] | undefined;
    onClickShowDetectedField?: ((key: string) => void) | undefined;
    onClickHideDetectedField?: ((key: string) => void) | undefined;
    getRowContext?: ((row: LogRowModel, options?: RowContextOptions) => Promise<any>) | undefined;
    logsSortOrder?: LogsSortOrder | null | undefined;
    prettifyLogMessage: boolean;
    showContextToggle?: ((row?: LogRowModel) => boolean) | undefined;
    getFieldLinks?: ((field: Field$1, rowIndex: number) => Array<LinkModel<Field$1>>) | undefined;
    showLabels: boolean;
    showTime: boolean;
    enableLogDetails: boolean;
    forceEscape?: boolean | undefined;
    onLogRowHover?: ((row?: LogRowModel) => void) | undefined;
    logRows?: LogRowModel[] | undefined;
    deduplicatedRows?: LogRowModel[] | undefined;
    dedupStrategy: LogsDedupStrategy;
    previewLimit?: number | undefined;
}>;

/** @deprecated will be removed in the next major version */
declare const getLogRowStyles: (theme: GrafanaTheme2, logLevel?: LogLevel) => {
    logsRowMatchHighLight: string;
    logsRowsTable: string;
    context: string;
    logsRow: string;
    logsRowDuplicates: string;
    logsRowLevel: string;
    logIconError: string;
    logsRowToggleDetails: string;
    logsRowLocalTime: string;
    logsRowLabels: string;
    logsRowMessage: string;
    logDetailsContainer: string;
    logDetailsTable: string;
    logsDetailsIcon: string;
    logDetailsLabel: string;
    logDetailsHeading: string;
    logDetailsValue: string;
};

declare type DataLinkButtonProps = {
    link: LinkModel<Field$1>;
    buttonProps?: ButtonProps;
};
/**
 * @internal
 */
declare function DataLinkButton({ link, buttonProps }: DataLinkButtonProps): JSX.Element;

declare type Props$z = {
    links: Array<LinkModel<Field$1>>;
};
/**
 * @internal
 */
declare function FieldLinkList({ links }: Props$z): JSX.Element;

interface Props$y {
    className?: string;
}
declare const FullWidthButtonContainer: ({ className, children }: React__default.PropsWithChildren<Props$y>) => JSX.Element;

interface Props$x {
    /**
     *  Callback to trigger when clicking outside of current element occurs.
     */
    onClick: () => void;
    /**
     *  Runs the 'onClick' function when pressing a key outside of the current element. Defaults to true.
     */
    includeButtonPress: boolean;
    /** Object to attach the click event listener to. */
    parent: Window | Document;
    /**
     * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener. Defaults to false.
     */
    useCapture?: boolean;
}
interface State$2 {
    hasEventListener: boolean;
}
declare class ClickOutsideWrapper extends PureComponent<React__default.PropsWithChildren<Props$x>, State$2> {
    static defaultProps: {
        includeButtonPress: boolean;
        parent: (Window & typeof globalThis) | null;
        useCapture: boolean;
    };
    myRef: React__default.RefObject<HTMLDivElement>;
    state: {
        hasEventListener: boolean;
    };
    componentDidMount(): void;
    componentWillUnmount(): void;
    onOutsideClick: (event: any) => void;
    render(): JSX.Element;
}

interface SingleStatBaseOptions extends OptionsWithTextFormatting {
    reduceOptions: ReduceDataOptions;
    orientation: VizOrientation;
}
declare function sharedSingleStatPanelChangedHandler(panel: PanelModel<Partial<SingleStatBaseOptions>> | any, prevPluginId: string, prevOptions: any): any;
declare function sharedSingleStatMigrationHandler(panel: PanelModel<SingleStatBaseOptions>): SingleStatBaseOptions;
/**
 * @deprecated use convertOldAngularValueMappings instead
 * Convert the angular single stat mapping to new react style
 */
declare function convertOldAngularValueMapping(panel: any): ValueMapping[];

interface CallToActionCardProps {
    message?: string | JSX.Element;
    callToActionElement: JSX.Element;
    footer?: string | JSX.Element;
    className?: string;
}
declare const CallToActionCard: ({ message, callToActionElement, footer, className }: CallToActionCardProps) => JSX.Element;

declare function MenuDivider(): JSX.Element;

interface MenuProps extends React__default.HTMLAttributes<HTMLDivElement> {
    /** React element rendered at the top of the menu */
    header?: React__default.ReactNode;
    children: React__default.ReactNode;
    ariaLabel?: string;
    onOpen?: (focusOnItem: (itemId: number) => void) => void;
    onClose?: () => void;
    onKeyDown?: React__default.KeyboardEventHandler;
}
declare const Menu: React__default.ForwardRefExoticComponent<MenuProps & React__default.RefAttributes<HTMLDivElement>> & {
    Item: React__default.MemoExoticComponent<React__default.ForwardRefExoticComponent<MenuItemProps<any> & React__default.RefAttributes<MenuItemElement>>>;
    Divider: typeof MenuDivider;
    Group: {
        ({ label, ariaLabel, children }: MenuGroupProps): JSX.Element;
        displayName: string;
    };
};

interface WithContextMenuProps {
    /** Menu item trigger that accepts openMenu prop */
    children: (props: {
        openMenu: React__default.MouseEventHandler<HTMLElement>;
    }) => JSX.Element;
    /** A function that returns an array of menu items */
    renderMenuItems: () => React__default.ReactNode;
    /** On menu open focus the first element */
    focusOnOpen?: boolean;
}
declare const WithContextMenu: ({ children, renderMenuItems, focusOnOpen }: WithContextMenuProps) => JSX.Element;

interface DataLinksInlineEditorProps {
    links?: DataLink[];
    onChange: (links: DataLink[]) => void;
    getSuggestions: () => VariableSuggestion[];
    data: DataFrame[];
}
declare const DataLinksInlineEditor: ({ links, onChange, getSuggestions, data }: DataLinksInlineEditorProps) => JSX.Element;

interface DataLinkInputProps {
    value: string;
    onChange: (url: string, callback?: () => void) => void;
    suggestions: VariableSuggestion[];
    placeholder?: string;
}
declare const DataLinkInput: React__default.MemoExoticComponent<({ value, onChange, suggestions, placeholder, }: DataLinkInputProps) => JSX.Element>;

interface DataLinksContextMenuProps {
    children: (props: DataLinksContextMenuApi) => JSX.Element;
    links: () => LinkModel[];
    style?: CSSProperties;
}
interface DataLinksContextMenuApi {
    openMenu?: React__default.MouseEventHandler<HTMLOrSVGElement>;
    targetClassName?: string;
}
declare const DataLinksContextMenu: ({ children, links, style }: DataLinksContextMenuProps) => JSX.Element;

interface Props$w extends React__default.HTMLAttributes<HTMLDivElement> {
    color?: string;
    gradient?: string;
}
declare const SeriesIcon: React__default.MemoExoticComponent<React__default.ForwardRefExoticComponent<Props$w & React__default.RefAttributes<HTMLDivElement>>>;

interface InfoBoxProps extends Omit<React__default.HTMLAttributes<HTMLDivElement>, 'title'> {
    children: React__default.ReactNode;
    /** Title of the box */
    title?: string | JSX.Element;
    /** Url of the read more link */
    url?: string;
    /** Text of the read more link */
    urlTitle?: string;
    /** Indicates whether or not box should be rendered with Grafana branding background */
    branded?: boolean;
    /** Color variant of the box */
    severity?: AlertVariant;
    /** Call back to be performed when box is dismissed */
    onDismiss?: () => void;
}
/** @deprecated use Alert with severity info */
declare const InfoBox: React__default.MemoExoticComponent<React__default.ForwardRefExoticComponent<InfoBoxProps & React__default.RefAttributes<HTMLDivElement>>>;

interface FeatureInfoBoxProps extends Omit<InfoBoxProps, 'title' | 'urlTitle'> {
    title: string;
    featureState?: FeatureState;
}
/** @deprecated use Alert with severity info */
declare const FeatureInfoBox: React__default.MemoExoticComponent<React__default.ForwardRefExoticComponent<FeatureInfoBoxProps & React__default.RefAttributes<HTMLDivElement>>>;
interface FeatureBadgeProps {
    featureState: FeatureState;
    tooltip?: string;
}
declare const FeatureBadge: ({ featureState, tooltip }: FeatureBadgeProps) => JSX.Element;

interface JsonExplorerConfig {
    animateOpen?: boolean;
    animateClose?: boolean;
    theme?: string;
}
/**
 * @class JsonExplorer
 *
 * JsonExplorer allows you to render JSON objects in HTML with a
 * **collapsible** navigation.
 */
declare class JsonExplorer {
    json: any;
    private open;
    private config;
    private key?;
    private _isOpen;
    private element;
    private skipChildren;
    /**
     * @param {object} json The JSON object you want to render. It has to be an
     * object or array. Do NOT pass raw JSON string.
     *
     * @param {number} [open=1] his number indicates up to how many levels the
     * rendered tree should expand. Set it to `0` to make the whole tree collapsed
     * or set it to `Infinity` to expand the tree deeply
     *
     * @param {object} [config=defaultConfig] -
     *  defaultConfig = {
     *   hoverPreviewEnabled: false,
     *   hoverPreviewArrayCount: 100,
     *   hoverPreviewFieldCount: 5
     * }
     *
     * Available configurations:
     *  #####Hover Preview
     * * `hoverPreviewEnabled`:  enable preview on hover
     * * `hoverPreviewArrayCount`: number of array items to show in preview Any
     *    array larger than this number will be shown as `Array[XXX]` where `XXX`
     *    is length of the array.
     * * `hoverPreviewFieldCount`: number of object properties to show for object
     *   preview. Any object with more properties that thin number will be
     *   truncated.
     *
     * @param {string} [key=undefined] The key that this object in its parent
     * context
     */
    constructor(json: any, open?: number, config?: JsonExplorerConfig, key?: string | undefined);
    private get isOpen();
    private set isOpen(value);
    private get isDate();
    private get isUrl();
    private get isArray();
    private get isObject();
    private get isEmptyObject();
    private get isEmpty();
    private get hasKey();
    private get constructorName();
    private get type();
    private get keys();
    /**
     * Toggles `isOpen` state
     *
     */
    toggleOpen(): void;
    /**
     * Open all children up to a certain depth.
     * Allows actions such as expand all/collapse all
     *
     */
    openAtDepth(depth?: number): void;
    isNumberArray(): boolean;
    renderArray(): Element;
    /**
     * Renders an HTML element and installs event listeners
     *
     * @returns {HTMLDivElement}
     */
    render(skipRoot?: boolean): HTMLDivElement;
    /**
     * Appends all the children to children element
     * Animated option is used when user triggers this via a click
     */
    appendChildren(animated?: boolean): void;
    /**
     * Removes all the children from children element
     * Animated option is used when user triggers this via a click
     */
    removeChildren(animated?: boolean): void;
}

interface Props$v {
    className?: string;
    json: {};
    config?: JsonExplorerConfig;
    open?: number;
    onDidRender?: (formattedJson: any) => void;
}
declare class JSONFormatter extends PureComponent<Props$v> {
    private wrapperRef;
    static defaultProps: {
        open: number;
        config: {
            animateOpen: boolean;
        };
    };
    componentDidMount(): void;
    componentDidUpdate(): void;
    renderJson: () => void;
    render(): JSX.Element;
}

interface ErrorInfo {
    componentStack: string;
}
interface ErrorBoundaryApi {
    error: Error | null;
    errorInfo: ErrorInfo | null;
}
interface Props$u {
    children: (r: ErrorBoundaryApi) => ReactNode;
    /** Will re-render children after error if recover values changes */
    dependencies?: unknown[];
    /** Callback called on error */
    onError?: (error: Error) => void;
    /** Callback error state is cleared due to recover props change */
    onRecover?: () => void;
}
interface State$1 {
    error: Error | null;
    errorInfo: ErrorInfo | null;
}
declare class ErrorBoundary extends PureComponent<Props$u, State$1> {
    readonly state: State$1;
    componentDidCatch(error: Error, errorInfo: ErrorInfo): void;
    componentDidUpdate(prevProps: Props$u): void;
    render(): React__default.ReactNode;
}
/**
 * Props for the ErrorBoundaryAlert component
 *
 * @public
 */
interface ErrorBoundaryAlertProps {
    /** Title for the error boundary alert */
    title?: string;
    /** Component to be wrapped with an error boundary */
    children: ReactNode;
    /** 'page' will render full page error with stacktrace. 'alertbox' will render an <Alert />. Default 'alertbox' */
    style?: 'page' | 'alertbox';
    /** Will re-render children after error if recover values changes */
    dependencies?: unknown[];
}
declare class ErrorBoundaryAlert extends PureComponent<ErrorBoundaryAlertProps> {
    static defaultProps: Partial<ErrorBoundaryAlertProps>;
    render(): JSX.Element;
}
/**
 * HOC for wrapping a component in an error boundary.
 *
 * @param Component - the react component to wrap in error boundary
 * @param errorBoundaryProps - error boundary options
 *
 * @public
 */
declare function withErrorBoundary<P extends {} = {}>(Component: ComponentType<P>, errorBoundaryProps?: Omit<ErrorBoundaryAlertProps, 'children'>): ComponentType<P>;

interface Props$t extends ErrorBoundaryApi {
    title: string;
}
declare const ErrorWithStack: {
    ({ error, errorInfo, title }: Props$t): JSX.Element;
    displayName: string;
};

interface AzureAuthSettings {
    /** Set to true if Azure authentication supported by the datasource */
    readonly azureAuthSupported: boolean;
    /** Gets whether the Azure authentication currently enabled for the datasource */
    readonly getAzureAuthEnabled: (config: DataSourceSettings<any, any>) => boolean;
    /** Enables/disables the Azure authentication from the datasource */
    readonly setAzureAuthEnabled: (config: DataSourceSettings<any, any>, enabled: boolean) => Partial<DataSourceSettings<any, any>>;
    /** Optional React component of additional Azure settings UI if authentication is enabled  */
    readonly azureSettingsUI?: React__default.ComponentType<HttpSettingsBaseProps>;
}
interface HttpSettingsBaseProps<JSONData extends DataSourceJsonData = any, SecureJSONData = any> {
    /** The configuration object of the data source */
    dataSourceConfig: DataSourceSettings<JSONData, SecureJSONData>;
    /** Callback for handling changes to the configuration object */
    onChange: (config: DataSourceSettings<JSONData, SecureJSONData>) => void;
    /** Show the Forward OAuth identity option */
    showForwardOAuthIdentityOption?: boolean;
}
interface HttpSettingsProps extends HttpSettingsBaseProps {
    /** The default url for the data source */
    defaultUrl: string;
    /** Show the http access help box */
    showAccessOptions?: boolean;
    /** Show the SigV4 auth toggle option */
    sigV4AuthToggleEnabled?: boolean;
    /** Azure authentication settings **/
    azureAuthSettings?: AzureAuthSettings;
    /** If SIGV4 is enabled, provide an editor for SIGV4 connection config  **/
    renderSigV4Editor?: React__default.ReactNode;
}

declare const DataSourceHttpSettings: (props: HttpSettingsProps) => JSX.Element;

interface CustomHeader {
    id: string;
    name: string;
    value: string;
    configured: boolean;
}
declare type CustomHeaders = CustomHeader[];
interface Props$s {
    dataSourceConfig: DataSourceSettings<any, any>;
    onChange: (config: DataSourceSettings) => void;
}
interface State {
    headers: CustomHeaders;
}
declare class CustomHeadersSettings extends PureComponent<Props$s, State> {
    state: State;
    constructor(props: Props$s);
    updateSettings: () => void;
    onHeaderAdd: () => void;
    onHeaderChange: (headerIndex: number, value: CustomHeader) => void;
    onHeaderReset: (headerId: string) => void;
    onHeaderRemove: (headerId: string) => void;
    render(): JSX.Element;
}

interface Props$r<T extends DataSourceJsonData> extends Pick<DataSourcePluginOptionsEditorProps<T>, 'options' | 'onOptionsChange'> {
}
interface AlertingConfig extends DataSourceJsonData {
    manageAlerts?: boolean;
}
declare function AlertingSettings<T extends AlertingConfig>({ options, onOptionsChange }: Props$r<T>): JSX.Element;

interface Props$q<T extends DataSourceJsonData> extends Pick<DataSourcePluginOptionsEditorProps<T>, 'options' | 'onOptionsChange'> {
}
interface SecureSocksProxyConfig extends DataSourceJsonData {
    enableSecureSocksProxy?: boolean;
}
declare function SecureSocksProxySettings<T extends SecureSocksProxyConfig>({ options, onOptionsChange, }: Props$q<T>): JSX.Element;

declare const TLSAuthSettings: ({ dataSourceConfig, onChange }: HttpSettingsBaseProps) => JSX.Element;

interface Props$p {
    label: string;
    hasCert: boolean;
    placeholder: string;
    onChange: (event: ChangeEvent<HTMLTextAreaElement>) => void;
    onClick: (event: MouseEvent$1<HTMLButtonElement>) => void;
}
declare const CertificationKey: ({ hasCert, label, onChange, onClick, placeholder }: Props$p) => JSX.Element;

declare type Props$o = {
    className?: string;
    style?: React__default.CSSProperties;
    iconClassName?: string;
    inline?: boolean;
    size?: number;
};
/**
 * @public
 */
declare const Spinner: ({ className, inline, iconClassName, style, size }: Props$o) => JSX.Element;

declare type Props$n = {
    children: React__default.ReactNode;
    visible: boolean;
    duration?: number;
};
declare function FadeTransition(props: Props$n): JSX.Element;

declare type Props$m = {
    children: React__default.ReactNode;
    visible: boolean;
    size: number;
    duration?: number;
    horizontal?: boolean;
};
declare function SlideOutTransition(props: Props$m): JSX.Element;

interface SegmentSyncProps<T> extends SegmentProps<T>, Omit<HTMLProps<HTMLDivElement>, 'value' | 'onChange'> {
    value?: T | SelectableValue<T>;
    onChange: (item: SelectableValue<T>) => void;
    options: Array<SelectableValue<T>>;
    inputMinWidth?: number;
}
declare function Segment<T>({ options, value, onChange, Component, className, allowCustomValue, allowEmptyValue, placeholder, disabled, inputMinWidth, inputPlaceholder, onExpandedChange, autofocus, ...rest }: React__default.PropsWithChildren<SegmentSyncProps<T>>): JSX.Element;

interface SegmentAsyncProps<T> extends SegmentProps<T>, Omit<HTMLProps<HTMLDivElement>, 'value' | 'onChange'> {
    value?: T | SelectableValue<T>;
    loadOptions: (query?: string) => Promise<Array<SelectableValue<T>>>;
    /**
     *  If true options will be reloaded when user changes the value in the input,
     *  otherwise, options will be loaded when the segment is clicked
     */
    reloadOptionsOnChange?: boolean;
    onChange: (item: SelectableValue<T>) => void;
    noOptionMessageHandler?: (state: AsyncState<Array<SelectableValue<T>>>) => string;
    inputMinWidth?: number;
}
declare function SegmentAsync<T>({ value, onChange, loadOptions, reloadOptionsOnChange, Component, className, allowCustomValue, allowEmptyValue, disabled, placeholder, inputMinWidth, inputPlaceholder, autofocus, onExpandedChange, noOptionMessageHandler, ...rest }: React__default.PropsWithChildren<SegmentAsyncProps<T>>): JSX.Element;

/** @internal
 * Should be used only internally by Segment/SegmentAsync which can guarantee that SegmentSelect is hidden
 * when a value is selected. See comment below on closeMenuOnSelect()
 */
interface Props$l<T> extends Omit<HTMLProps<HTMLDivElement>, 'value' | 'onChange'> {
    value?: T | SelectableValue<T>;
    options: Array<SelectableValue<T>>;
    onChange: (item: SelectableValue<T>) => void;
    /**
     * If provided - AsyncSelect will be used allowing to reload options when the value in the input changes
     */
    loadOptions?: (inputValue: string) => Promise<Array<SelectableValue<T>>>;
    onClickOutside: () => void;
    width: number;
    noOptionsMessage?: string;
    allowCustomValue?: boolean;
    /**
     * If true, empty value will be passed to onChange callback otherwise using empty value
     * will work as canceling and using the previous value
     */
    allowEmptyValue?: boolean;
    placeholder?: string;
}
/** @internal */
declare function SegmentSelect<T>({ value, placeholder, options, onChange, onClickOutside, loadOptions, width: widthPixels, noOptionsMessage, allowCustomValue, allowEmptyValue, ...rest }: React__default.PropsWithChildren<Props$l<T>>): JSX.Element;

interface SegmentInputProps<T> extends Omit<SegmentProps<T>, 'allowCustomValue' | 'allowEmptyValue'>, Omit<HTMLProps<HTMLInputElement>, 'value' | 'onChange'> {
    value: string | number;
    onChange: (text: string | number) => void;
}
declare function SegmentInput<T>({ value: initialValue, onChange, Component, className, placeholder, inputPlaceholder, disabled, autofocus, onExpandedChange, ...rest }: React__default.PropsWithChildren<SegmentInputProps<T>>): JSX.Element;

/**
 * Horizontal section for editor components.
 *
 * @alpha
 */
declare const SegmentSection: ({ label, htmlFor, children, fill, }: {
    label: string;
    htmlFor?: string | undefined;
    children: React__default.ReactNode;
    fill?: boolean | undefined;
}) => JSX.Element;

interface SegmentProps<T> {
    Component?: ReactElement;
    className?: string;
    allowCustomValue?: boolean;
    placeholder?: string;
    disabled?: boolean;
    onExpandedChange?: (expanded: boolean) => void;
    autofocus?: boolean;
    allowEmptyValue?: boolean;
    inputPlaceholder?: string;
}

interface Props$k {
    children: ReactNode;
    /** Title shown at the top of the drawer */
    title?: ReactNode;
    /** Subtitle shown below the title */
    subtitle?: ReactNode;
    /** Should the Drawer be closable by clicking on the mask, defaults to true */
    closeOnMaskClick?: boolean;
    /** Render the drawer inside a container on the page */
    inline?: boolean;
    /** Either a number in px or a string with unit postfix */
    width?: number | string;
    /** Should the Drawer be expandable to full width */
    expandable?: boolean;
    /** Tabs */
    tabs?: React__default.ReactNode;
    /** Set to true if the component rendered within in drawer content has its own scroll */
    scrollableContent?: boolean;
    /** Callback for closing the drawer */
    onClose: () => void;
}
declare function Drawer({ children, inline, onClose, closeOnMaskClick, scrollableContent, title, subtitle, width, expandable, tabs, }: Props$k): JSX.Element;

declare type Orientation$1 = 'horizontal' | 'vertical';

interface CommonSliderProps {
    min: number;
    max: number;
    orientation?: Orientation$1;
    /** Set current positions of handle(s). If only 1 value supplied, only 1 handle displayed. */
    reverse?: boolean;
    step?: number;
    tooltipAlwaysVisible?: boolean;
    /** Marks on the slider. The key determines the position, and the value determines what will show. If you want to set the style of a specific mark point, the value should be an object which contains style and label properties. */
    marks?: SliderMarks;
    /** If the value is true, it means a continuous value interval, otherwise, it is a independent value. */
    included?: boolean;
}
interface SliderProps extends CommonSliderProps {
    value?: number;
    onChange?: (value: number) => void;
    onAfterChange?: (value?: number) => void;
    formatTooltipResult?: (value: number) => number;
    ariaLabelForHandle?: string;
}
interface RangeSliderProps extends CommonSliderProps {
    value?: number[];
    onChange?: (value: number[]) => void;
    onAfterChange?: (value?: number[]) => void;
    formatTooltipResult?: (value: number) => number | string;
}

/**
 * @public
 */
declare const Slider: {
    ({ min, max, onChange, onAfterChange, orientation, reverse, step, value, ariaLabelForHandle, marks, included, }: SliderProps): JSX.Element;
    displayName: string;
};

/**
 * @public
 *
 * RichHistoryQueriesTab uses this Range Component
 */
declare const RangeSlider: {
    ({ min, max, onChange, onAfterChange, orientation, reverse, step, formatTooltipResult, value, tooltipAlwaysVisible, }: RangeSliderProps): JSX.Element;
    displayName: string;
};

interface FormProps<T extends FieldValues> extends Omit<HTMLProps<HTMLFormElement>, 'onSubmit' | 'children'> {
    validateOn?: Mode;
    validateOnMount?: boolean;
    validateFieldsOnMount?: string | string[];
    defaultValues?: UnpackNestedValue<DeepPartial<T>>;
    onSubmit: SubmitHandler<T>;
    children: (api: FormAPI<T>) => React__default.ReactNode;
    /** Sets max-width for container. Use it instead of setting individual widths on inputs.*/
    maxWidth?: number | 'none';
}
declare function Form<T extends FieldValues>({ defaultValues, onSubmit, validateOnMount, validateFieldsOnMount, children, validateOn, maxWidth, ...htmlProps }: FormProps<T>): JSX.Element;

declare const sharedInputStyle: (theme: GrafanaTheme2, invalid?: boolean) => string;

declare const InputControl: <TFieldValues extends react_hook_form.FieldValues = react_hook_form.FieldValues, TName extends react_hook_form.Path<TFieldValues> = react_hook_form.Path<TFieldValues>>(props: react_hook_form.ControllerProps<TFieldValues, TName>) => React$1.ReactElement<any, string | React$1.JSXElementConstructor<any>>;

interface ValuePickerProps<T> {
    /** Aria label applied to the input field */
    ['aria-label']?: string;
    /** Label to display on the picker button */
    label: string;
    /** Icon to display on the picker button */
    icon?: IconName;
    /** ValuePicker options  */
    options: Array<SelectableValue<T>>;
    /** Callback to handle selected option */
    onChange: (value: SelectableValue<T>) => void;
    /** Which ButtonVariant to render */
    variant?: ButtonVariant;
    /** Size of button  */
    size?: ComponentSize;
    /** Min width for select in grid units */
    minWidth?: number;
    /** Should the picker cover the full width of its parent */
    isFullWidth?: boolean;
    /** Control where the menu is rendered */
    menuPlacement?: 'auto' | 'bottom' | 'top';
    /** Which ButtonFill to use */
    fill?: ButtonFill;
    /** custom css applied to the button */
    buttonCss?: string;
}
declare function ValuePicker<T>({ 'aria-label': ariaLabel, label, icon, options, onChange, variant, minWidth, size, isFullWidth, menuPlacement, fill, buttonCss, }: ValuePickerProps<T>): JSX.Element;

interface FieldMatcherUIRegistryItem<TOptions> extends RegistryItem {
    component: React__default.ComponentType<MatcherUIProps<TOptions>>;
    matcher: FieldMatcherInfo<TOptions>;
    optionsToLabel: (options: TOptions) => string;
}
interface MatcherUIProps<T> {
    matcher: FieldMatcherInfo<T>;
    id?: string;
    data: DataFrame[];
    options: T;
    onChange: (options: T) => void;
}

declare const fieldMatchersUI: Registry<FieldMatcherUIRegistryItem<any>>;

interface Props$j extends AnchorHTMLAttributes<HTMLAnchorElement> {
}
/**
 * @alpha
 */
declare const Link: React__default.ForwardRefExoticComponent<Props$j & React__default.RefAttributes<HTMLAnchorElement>>;

interface LabelProps$1 extends React__default.LabelHTMLAttributes<HTMLLabelElement> {
    children: React__default.ReactNode;
    description?: React__default.ReactNode;
    category?: React__default.ReactNode[];
}
declare const Label$1: ({ children, description, className, category, ...labelProps }: LabelProps$1) => JSX.Element;

interface FieldProps extends HTMLAttributes<HTMLDivElement> {
    /** Form input element, i.e Input or Switch */
    children: React__default.ReactElement;
    /** Label for the field */
    label?: React__default.ReactNode;
    /** Description of the field */
    description?: React__default.ReactNode;
    /** Indicates if field is in invalid state */
    invalid?: boolean;
    /** Indicates if field is in loading state */
    loading?: boolean;
    /** Indicates if field is disabled */
    disabled?: boolean;
    /** Indicates if field is required */
    required?: boolean;
    /** Error message to display */
    error?: React__default.ReactNode;
    /** Indicates horizontal layout of the field */
    horizontal?: boolean;
    /** make validation message overflow horizontally. Prevents pushing out adjacent inline components */
    validationMessageHorizontalOverflow?: boolean;
    className?: string;
    /**
     *  A unique id that associates the label of the Field component with the control with the unique id.
     *  If the `htmlFor` property is missing the `htmlFor` will be inferred from the `id` or `inputId` property of the first child.
     *  https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label#attr-for
     */
    htmlFor?: string;
}
declare const Field: ({ label, description, horizontal, invalid, loading, disabled, required, error, children, className, validationMessageHorizontalOverflow, htmlFor, ...otherProps }: FieldProps) => JSX.Element;

interface LabelProps extends React__default.HTMLAttributes<HTMLLegendElement> {
    children: string | ReactNode;
    description?: string;
}
declare const Legend: ({ children, className, ...legendProps }: LabelProps) => JSX.Element;

interface Props$i extends Omit<HTMLProps<HTMLFieldSetElement>, 'label'> {
    children: React__default.ReactNode[] | React__default.ReactNode;
    /** Label for the fieldset's legend */
    label?: React__default.ReactNode;
}
declare const FieldSet: ({ label, children, className, ...rest }: Props$i) => JSX.Element;

interface FieldValidationMessageProps {
    /** Override component style */
    className?: string;
    horizontal?: boolean;
}
declare const FieldValidationMessage: ({ children, horizontal, className, }: React__default.PropsWithChildren<FieldValidationMessageProps>) => JSX.Element;

interface Props$h extends Omit<FieldProps, 'css' | 'horizontal' | 'description' | 'error'> {
    /** Content for the label's tooltip */
    tooltip?: PopoverContent;
    /** Custom width for the label as a multiple of 8px */
    labelWidth?: number | 'auto';
    /** Make the field's child to fill the width of the row. Equivalent to setting `flex-grow:1` on the field */
    grow?: boolean;
    /** Make the field's child shrink with width of the row. Equivalent to setting `flex-shrink:1` on the field */
    shrink?: boolean;
    /** Make field's background transparent */
    transparent?: boolean;
    /** Error message to display */
    error?: string | null;
    htmlFor?: string;
    /** Make tooltip interactive */
    interactive?: boolean;
}
declare const InlineField: {
    ({ children, label, tooltip, labelWidth, invalid, loading, disabled, required, className, htmlFor, grow, shrink, error, transparent, interactive, ...htmlProps }: Props$h): JSX.Element;
    displayName: string;
};

interface Props$g {
    grow?: boolean;
    className?: string;
}
/** @beta */
declare const InlineSegmentGroup: {
    ({ children, className, grow, ...htmlProps }: React__default.PropsWithChildren<Props$g>): JSX.Element;
    displayName: string;
};

interface Props$f extends Omit<LabelProps$1, 'css' | 'description' | 'category'> {
    /** Content for the labels tooltip. If provided, an info icon with the tooltip content
     * will be displayed */
    tooltip?: PopoverContent;
    /** Custom width for the label */
    width?: number | 'auto';
    /** Make labels's background transparent */
    transparent?: boolean;
    /** Make tooltip interactive */
    interactive?: boolean;
    /** @beta */
    /** Controls which element the InlineLabel should be rendered into */
    as?: React__default.ElementType;
}
declare const InlineLabel: ({ children, className, tooltip, width, transparent, interactive, as: Component, ...rest }: Props$f) => JSX.Element;

interface Props$e extends Omit<HTMLProps<HTMLDivElement>, 'css'> {
    children: ReactNode | ReactNode[];
}
declare const InlineFieldRow: ({ children, className, ...htmlProps }: Props$e) => JSX.Element;

interface FieldArrayProps extends UseFieldArrayProps {
    children: (api: FieldArrayApi) => JSX.Element;
}
declare const FieldArray: FC<FieldArrayProps>;

declare function resetSelectStyles(theme: GrafanaTheme2): {
    clearIndicator: () => {};
    container: () => {};
    control: () => {};
    dropdownIndicator: () => {};
    group: () => {};
    groupHeading: () => {};
    indicatorsContainer: () => {};
    indicatorSeparator: () => {};
    input: (originalStyles: CSSObjectWithLabel) => CSSObjectWithLabel;
    loadingIndicator: () => {};
    loadingMessage: () => {};
    menu: () => {};
    menuList: ({ maxHeight }: {
        maxHeight: number;
    }) => {
        maxHeight: number;
    };
    multiValue: () => {};
    multiValueLabel: () => {};
    multiValueRemove: () => {};
    noOptionsMessage: () => {};
    option: () => {};
    placeholder: (originalStyles: CSSObjectWithLabel) => CSSObjectWithLabel;
    singleValue: () => {};
    valueContainer: () => {};
};

declare type SelectContainerProps<Option, isMulti extends boolean, Group extends GroupBase<Option>> = ContainerProps$1<Option, isMulti, Group> & CustomComponentProps<Option, isMulti, Group>;
declare const SelectContainer: <Option, isMulti extends boolean, Group extends GroupBase<Option>>(props: SelectContainerProps<Option, isMulti, Group>) => JSX.Element;

declare function Select<T>(props: SelectCommonProps<T>): JSX.Element;
declare function MultiSelect<T>(props: MultiSelectCommonProps<T>): JSX.Element;
interface AsyncSelectProps<T> extends Omit<SelectCommonProps<T>, 'options'>, SelectAsyncProps<T> {
    value?: T | SelectableValue<T> | null;
}
declare function AsyncSelect<T>(props: AsyncSelectProps<T>): JSX.Element;
declare function VirtualizedSelect<T>(props: VirtualizedSelectProps<T>): JSX.Element;
declare function AsyncVirtualizedSelect<T>(props: VirtualizedSelectAsyncProps<T>): JSX.Element;
interface AsyncMultiSelectProps<T> extends Omit<MultiSelectCommonProps<T>, 'options'>, SelectAsyncProps<T> {
    value?: Array<SelectableValue<T>>;
}
declare function AsyncMultiSelect<T>(props: AsyncMultiSelectProps<T>): JSX.Element;

interface DropdownIndicatorProps {
    isOpen: boolean;
}
declare const DropdownIndicator: ({ isOpen }: DropdownIndicatorProps) => JSX.Element;

declare const getSelectStyles: memoize_one.MemoizedFn<(theme: GrafanaTheme2) => {
    menu: string;
    option: string;
    optionIcon: string;
    optionImage: string;
    optionDescription: string;
    optionBody: string;
    optionFocused: string;
    optionSelected: string;
    optionDisabled: string;
    singleValue: string;
    valueContainer: string;
    valueContainerMulti: string;
    loadingMessage: string;
    multiValueContainer: string;
    multiValueRemove: string;
    singleValueRemove: string;
}>;

declare enum Orientation {
    Horizontal = 0,
    Vertical = 1
}
declare type Spacing = 'none' | 'xs' | 'sm' | 'md' | 'lg';
declare type Justify = 'flex-start' | 'flex-end' | 'space-between' | 'center';
declare type Align = 'normal' | 'flex-start' | 'flex-end' | 'center';
interface LayoutProps extends Omit<HTMLProps<HTMLDivElement>, 'align' | 'children' | 'wrap'> {
    children: React__default.ReactNode[] | React__default.ReactNode;
    orientation?: Orientation;
    spacing?: Spacing;
    justify?: Justify;
    align?: Align;
    width?: string;
    wrap?: boolean;
}
interface ContainerProps {
    padding?: Spacing;
    margin?: Spacing;
    grow?: number;
    shrink?: number;
}
declare const HorizontalGroup: ({ children, spacing, justify, align, wrap, width, height, }: Omit<LayoutProps, 'orientation'>) => JSX.Element;
declare const VerticalGroup: ({ children, spacing, justify, align, width, height, }: Omit<LayoutProps, 'orientation' | 'wrap'>) => JSX.Element;
declare const Container: ({ children, padding, margin, grow, shrink }: React__default.PropsWithChildren<ContainerProps>) => JSX.Element;

declare type BadgeColor = 'blue' | 'red' | 'green' | 'orange' | 'purple';
interface BadgeProps extends HTMLAttributes<HTMLDivElement> {
    text: React__default.ReactNode;
    color: BadgeColor;
    icon?: IconName;
    tooltip?: string;
}
declare const Badge: React__default.NamedExoticComponent<BadgeProps>;

declare type RadioButtonSize = 'sm' | 'md';

interface RadioButtonGroupProps<T> {
    value?: T;
    id?: string;
    disabled?: boolean;
    disabledOptions?: T[];
    options: Array<SelectableValue<T>>;
    onChange?: (value: T) => void;
    onClick?: (value: T) => void;
    size?: RadioButtonSize;
    fullWidth?: boolean;
    className?: string;
    autoFocus?: boolean;
}
declare function RadioButtonGroup<T>({ options, value, onChange, onClick, disabled, disabledOptions, size, id, className, fullWidth, autoFocus, }: RadioButtonGroupProps<T>): JSX.Element;
declare namespace RadioButtonGroup {
    var displayName: string;
}

interface RadioButtonListProps<T> {
    /** A name of a radio group. Used to group multiple radio inputs into a single group */
    name: string;
    id?: string;
    /** An array of available options */
    options: Array<SelectableValue<T>>;
    value?: T;
    onChange?: (value: T) => void;
    /** Disables all elements in the list */
    disabled?: boolean;
    /** Disables subset of elements in the list. Compares values using the === operator */
    disabledOptions?: T[];
    className?: string;
}
declare function RadioButtonList<T>({ name, id, options, value, onChange, className, disabled, disabledOptions, }: RadioButtonListProps<T>): JSX.Element;

interface Props$d extends Props$13 {
    /** Sets the min-width to a multiple of 8px. Default value is 10*/
    minWidth?: number;
    /** Sets the max-width to a multiple of 8px.*/
    maxWidth?: number;
    /** onChange function that will be run on onBlur and onKeyPress with enter*/
    onCommitChange?: (event: React__default.FormEvent<HTMLInputElement>) => void;
}
declare const AutoSizeInput: React__default.ForwardRefExoticComponent<Pick<Props$d, "width" | "type" | "hidden" | "minWidth" | "name" | "target" | "id" | "label" | "title" | "min" | "max" | "color" | "style" | "role" | "value" | "suffix" | "prefix" | "key" | "data" | "rows" | "action" | "disabled" | "selected" | "shape" | "step" | "pattern" | "form" | "async" | "onChange" | "capture" | "onClick" | "cite" | "slot" | "span" | "summary" | "onBlur" | "readOnly" | "children" | "default" | "className" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlurCapture" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "list" | "height" | "media" | "method" | "crossOrigin" | "href" | "src" | "content" | "maxWidth" | "useMap" | "invalid" | "htmlFor" | "classID" | "accept" | "alt" | "autoComplete" | "autoFocus" | "checked" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "maxLength" | "minLength" | "multiple" | "required" | "coords" | "download" | "hrefLang" | "rel" | "acceptCharset" | "allowFullScreen" | "allowTransparency" | "as" | "autoPlay" | "cellPadding" | "cellSpacing" | "charSet" | "challenge" | "cols" | "colSpan" | "controls" | "dateTime" | "defer" | "encType" | "frameBorder" | "headers" | "high" | "httpEquiv" | "integrity" | "keyParams" | "keyType" | "kind" | "loop" | "low" | "manifest" | "marginHeight" | "marginWidth" | "mediaGroup" | "muted" | "nonce" | "noValidate" | "open" | "optimum" | "playsInline" | "poster" | "preload" | "reversed" | "rowSpan" | "sandbox" | "scope" | "scoped" | "scrolling" | "seamless" | "sizes" | "srcDoc" | "srcLang" | "srcSet" | "start" | "wmode" | "wrap" | "loading" | "addonBefore" | "addonAfter" | "onCommitChange"> & React__default.RefAttributes<HTMLInputElement>>;

interface Props$c extends Omit<HTMLProps<HTMLInputElement>, 'onChange'> {
    value: string | undefined;
    width?: number;
    onChange: (value: string) => void;
    escapeRegex?: boolean;
}
declare const FilterInput: React__default.ForwardRefExoticComponent<Pick<Props$c, "width" | "type" | "hidden" | "name" | "target" | "id" | "label" | "title" | "min" | "max" | "color" | "style" | "role" | "value" | "prefix" | "key" | "data" | "rows" | "action" | "disabled" | "selected" | "shape" | "step" | "pattern" | "form" | "async" | "onChange" | "capture" | "onClick" | "cite" | "slot" | "span" | "summary" | "onBlur" | "readOnly" | "children" | "default" | "size" | "className" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlurCapture" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "list" | "height" | "media" | "method" | "crossOrigin" | "href" | "src" | "content" | "useMap" | "htmlFor" | "classID" | "accept" | "alt" | "autoComplete" | "autoFocus" | "checked" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "maxLength" | "minLength" | "multiple" | "required" | "coords" | "download" | "hrefLang" | "rel" | "acceptCharset" | "allowFullScreen" | "allowTransparency" | "as" | "autoPlay" | "cellPadding" | "cellSpacing" | "charSet" | "challenge" | "cols" | "colSpan" | "controls" | "dateTime" | "defer" | "encType" | "frameBorder" | "headers" | "high" | "httpEquiv" | "integrity" | "keyParams" | "keyType" | "kind" | "loop" | "low" | "manifest" | "marginHeight" | "marginWidth" | "mediaGroup" | "muted" | "nonce" | "noValidate" | "open" | "optimum" | "playsInline" | "poster" | "preload" | "reversed" | "rowSpan" | "sandbox" | "scope" | "scoped" | "scrolling" | "seamless" | "sizes" | "srcDoc" | "srcLang" | "srcSet" | "start" | "wmode" | "wrap" | "escapeRegex"> & React__default.RefAttributes<HTMLInputElement>>;

declare type Props$b = React$1.ComponentProps<typeof Input> & {
    /** TRUE if the secret was already configured. (It is needed as often the backend doesn't send back the actual secret, only the information that it was configured) */
    isConfigured: boolean;
    /** Called when the user clicks on the "Reset" button in order to clear the secret */
    onReset: () => void;
};
declare const SecretInput: ({ isConfigured, onReset, ...props }: Props$b) => JSX.Element;

interface Props$a extends Omit<HTMLProps<HTMLTextAreaElement>, 'size'> {
    /** Show an invalid state around the input */
    invalid?: boolean;
}
declare const TextArea: React__default.ForwardRefExoticComponent<Pick<Props$a, "width" | "type" | "hidden" | "name" | "target" | "id" | "label" | "title" | "min" | "max" | "color" | "style" | "role" | "value" | "prefix" | "key" | "data" | "rows" | "action" | "disabled" | "selected" | "shape" | "step" | "pattern" | "form" | "async" | "onChange" | "capture" | "onClick" | "cite" | "slot" | "span" | "summary" | "onBlur" | "readOnly" | "children" | "default" | "className" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlurCapture" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "list" | "height" | "media" | "method" | "crossOrigin" | "href" | "src" | "content" | "useMap" | "invalid" | "htmlFor" | "classID" | "accept" | "alt" | "autoComplete" | "autoFocus" | "checked" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "maxLength" | "minLength" | "multiple" | "required" | "coords" | "download" | "hrefLang" | "rel" | "acceptCharset" | "allowFullScreen" | "allowTransparency" | "as" | "autoPlay" | "cellPadding" | "cellSpacing" | "charSet" | "challenge" | "cols" | "colSpan" | "controls" | "dateTime" | "defer" | "encType" | "frameBorder" | "headers" | "high" | "httpEquiv" | "integrity" | "keyParams" | "keyType" | "kind" | "loop" | "low" | "manifest" | "marginHeight" | "marginWidth" | "mediaGroup" | "muted" | "nonce" | "noValidate" | "open" | "optimum" | "playsInline" | "poster" | "preload" | "reversed" | "rowSpan" | "sandbox" | "scope" | "scoped" | "scrolling" | "seamless" | "sizes" | "srcDoc" | "srcLang" | "srcSet" | "start" | "wmode" | "wrap"> & React__default.RefAttributes<HTMLTextAreaElement>>;

declare type Props$9 = React$1.ComponentProps<typeof TextArea> & {
    /** TRUE if the secret was already configured. (It is needed as often the backend doesn't send back the actual secret, only the information that it was configured) */
    isConfigured: boolean;
    /** Called when the user clicks on the "Reset" button in order to clear the secret */
    onReset: () => void;
};
/**
 * Text area that does not disclose an already configured value but lets the user reset the current value and enter a new one.
 * Typically useful for asymmetric cryptography keys.
 */
declare const SecretTextArea: ({ isConfigured, onReset, ...props }: Props$9) => JSX.Element;

interface Props$8 extends Omit<HTMLProps<HTMLInputElement>, 'value'> {
    value?: boolean;
    /** Make switch's background and border transparent */
    transparent?: boolean;
}
declare const Switch: React__default.ForwardRefExoticComponent<Pick<Props$8, "width" | "type" | "hidden" | "name" | "target" | "id" | "label" | "title" | "min" | "max" | "transparent" | "color" | "style" | "role" | "value" | "prefix" | "key" | "data" | "rows" | "action" | "disabled" | "selected" | "shape" | "step" | "pattern" | "form" | "async" | "onChange" | "capture" | "onClick" | "cite" | "slot" | "span" | "summary" | "onBlur" | "readOnly" | "children" | "default" | "size" | "className" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlurCapture" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "list" | "height" | "media" | "method" | "crossOrigin" | "href" | "src" | "content" | "useMap" | "htmlFor" | "classID" | "accept" | "alt" | "autoComplete" | "autoFocus" | "checked" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "maxLength" | "minLength" | "multiple" | "required" | "coords" | "download" | "hrefLang" | "rel" | "acceptCharset" | "allowFullScreen" | "allowTransparency" | "as" | "autoPlay" | "cellPadding" | "cellSpacing" | "charSet" | "challenge" | "cols" | "colSpan" | "controls" | "dateTime" | "defer" | "encType" | "frameBorder" | "headers" | "high" | "httpEquiv" | "integrity" | "keyParams" | "keyType" | "kind" | "loop" | "low" | "manifest" | "marginHeight" | "marginWidth" | "mediaGroup" | "muted" | "nonce" | "noValidate" | "open" | "optimum" | "playsInline" | "poster" | "preload" | "reversed" | "rowSpan" | "sandbox" | "scope" | "scoped" | "scrolling" | "seamless" | "sizes" | "srcDoc" | "srcLang" | "srcSet" | "start" | "wmode" | "wrap"> & React__default.RefAttributes<HTMLInputElement>>;
interface InlineSwitchProps extends Props$8 {
    showLabel?: boolean;
}
declare const InlineSwitch: React__default.ForwardRefExoticComponent<Pick<InlineSwitchProps, "width" | "type" | "hidden" | "name" | "target" | "id" | "label" | "title" | "min" | "max" | "transparent" | "color" | "style" | "role" | "value" | "prefix" | "key" | "data" | "rows" | "action" | "disabled" | "selected" | "shape" | "step" | "pattern" | "form" | "async" | "onChange" | "capture" | "onClick" | "cite" | "slot" | "span" | "summary" | "onBlur" | "readOnly" | "children" | "default" | "size" | "className" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlurCapture" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "list" | "height" | "media" | "method" | "crossOrigin" | "href" | "src" | "content" | "useMap" | "htmlFor" | "classID" | "accept" | "alt" | "autoComplete" | "autoFocus" | "checked" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "maxLength" | "minLength" | "multiple" | "required" | "coords" | "download" | "hrefLang" | "rel" | "acceptCharset" | "allowFullScreen" | "allowTransparency" | "as" | "autoPlay" | "cellPadding" | "cellSpacing" | "charSet" | "challenge" | "cols" | "colSpan" | "controls" | "dateTime" | "defer" | "encType" | "frameBorder" | "headers" | "high" | "httpEquiv" | "integrity" | "keyParams" | "keyType" | "kind" | "loop" | "low" | "manifest" | "marginHeight" | "marginWidth" | "mediaGroup" | "muted" | "nonce" | "noValidate" | "open" | "optimum" | "playsInline" | "poster" | "preload" | "reversed" | "rowSpan" | "sandbox" | "scope" | "scoped" | "scrolling" | "seamless" | "sizes" | "srcDoc" | "srcLang" | "srcSet" | "start" | "wmode" | "wrap" | "showLabel"> & React__default.RefAttributes<HTMLInputElement>>;

interface CheckboxProps extends Omit<HTMLProps<HTMLInputElement>, 'value'> {
    label?: string;
    description?: string;
    value?: boolean;
    htmlValue?: string | number;
}
declare const Checkbox: React__default.ForwardRefExoticComponent<Pick<CheckboxProps, "width" | "type" | "hidden" | "name" | "target" | "description" | "id" | "label" | "title" | "min" | "max" | "color" | "style" | "role" | "value" | "prefix" | "key" | "data" | "rows" | "action" | "disabled" | "selected" | "shape" | "step" | "pattern" | "form" | "async" | "onChange" | "capture" | "onClick" | "cite" | "slot" | "span" | "summary" | "onBlur" | "readOnly" | "children" | "default" | "size" | "className" | "defaultChecked" | "defaultValue" | "suppressContentEditableWarning" | "suppressHydrationWarning" | "accessKey" | "contentEditable" | "contextMenu" | "dir" | "draggable" | "lang" | "placeholder" | "spellCheck" | "tabIndex" | "translate" | "radioGroup" | "about" | "datatype" | "inlist" | "property" | "resource" | "typeof" | "vocab" | "autoCapitalize" | "autoCorrect" | "autoSave" | "itemProp" | "itemScope" | "itemType" | "itemID" | "itemRef" | "results" | "security" | "unselectable" | "inputMode" | "is" | "aria-activedescendant" | "aria-atomic" | "aria-autocomplete" | "aria-busy" | "aria-checked" | "aria-colcount" | "aria-colindex" | "aria-colspan" | "aria-controls" | "aria-current" | "aria-describedby" | "aria-details" | "aria-disabled" | "aria-dropeffect" | "aria-errormessage" | "aria-expanded" | "aria-flowto" | "aria-grabbed" | "aria-haspopup" | "aria-hidden" | "aria-invalid" | "aria-keyshortcuts" | "aria-label" | "aria-labelledby" | "aria-level" | "aria-live" | "aria-modal" | "aria-multiline" | "aria-multiselectable" | "aria-orientation" | "aria-owns" | "aria-placeholder" | "aria-posinset" | "aria-pressed" | "aria-readonly" | "aria-relevant" | "aria-required" | "aria-roledescription" | "aria-rowcount" | "aria-rowindex" | "aria-rowspan" | "aria-selected" | "aria-setsize" | "aria-sort" | "aria-valuemax" | "aria-valuemin" | "aria-valuenow" | "aria-valuetext" | "dangerouslySetInnerHTML" | "onCopy" | "onCopyCapture" | "onCut" | "onCutCapture" | "onPaste" | "onPasteCapture" | "onCompositionEnd" | "onCompositionEndCapture" | "onCompositionStart" | "onCompositionStartCapture" | "onCompositionUpdate" | "onCompositionUpdateCapture" | "onFocus" | "onFocusCapture" | "onBlurCapture" | "onChangeCapture" | "onBeforeInput" | "onBeforeInputCapture" | "onInput" | "onInputCapture" | "onReset" | "onResetCapture" | "onSubmit" | "onSubmitCapture" | "onInvalid" | "onInvalidCapture" | "onLoad" | "onLoadCapture" | "onError" | "onErrorCapture" | "onKeyDown" | "onKeyDownCapture" | "onKeyPress" | "onKeyPressCapture" | "onKeyUp" | "onKeyUpCapture" | "onAbort" | "onAbortCapture" | "onCanPlay" | "onCanPlayCapture" | "onCanPlayThrough" | "onCanPlayThroughCapture" | "onDurationChange" | "onDurationChangeCapture" | "onEmptied" | "onEmptiedCapture" | "onEncrypted" | "onEncryptedCapture" | "onEnded" | "onEndedCapture" | "onLoadedData" | "onLoadedDataCapture" | "onLoadedMetadata" | "onLoadedMetadataCapture" | "onLoadStart" | "onLoadStartCapture" | "onPause" | "onPauseCapture" | "onPlay" | "onPlayCapture" | "onPlaying" | "onPlayingCapture" | "onProgress" | "onProgressCapture" | "onRateChange" | "onRateChangeCapture" | "onSeeked" | "onSeekedCapture" | "onSeeking" | "onSeekingCapture" | "onStalled" | "onStalledCapture" | "onSuspend" | "onSuspendCapture" | "onTimeUpdate" | "onTimeUpdateCapture" | "onVolumeChange" | "onVolumeChangeCapture" | "onWaiting" | "onWaitingCapture" | "onAuxClick" | "onAuxClickCapture" | "onClickCapture" | "onContextMenu" | "onContextMenuCapture" | "onDoubleClick" | "onDoubleClickCapture" | "onDrag" | "onDragCapture" | "onDragEnd" | "onDragEndCapture" | "onDragEnter" | "onDragEnterCapture" | "onDragExit" | "onDragExitCapture" | "onDragLeave" | "onDragLeaveCapture" | "onDragOver" | "onDragOverCapture" | "onDragStart" | "onDragStartCapture" | "onDrop" | "onDropCapture" | "onMouseDown" | "onMouseDownCapture" | "onMouseEnter" | "onMouseLeave" | "onMouseMove" | "onMouseMoveCapture" | "onMouseOut" | "onMouseOutCapture" | "onMouseOver" | "onMouseOverCapture" | "onMouseUp" | "onMouseUpCapture" | "onSelect" | "onSelectCapture" | "onTouchCancel" | "onTouchCancelCapture" | "onTouchEnd" | "onTouchEndCapture" | "onTouchMove" | "onTouchMoveCapture" | "onTouchStart" | "onTouchStartCapture" | "onPointerDown" | "onPointerDownCapture" | "onPointerMove" | "onPointerMoveCapture" | "onPointerUp" | "onPointerUpCapture" | "onPointerCancel" | "onPointerCancelCapture" | "onPointerEnter" | "onPointerEnterCapture" | "onPointerLeave" | "onPointerLeaveCapture" | "onPointerOver" | "onPointerOverCapture" | "onPointerOut" | "onPointerOutCapture" | "onGotPointerCapture" | "onGotPointerCaptureCapture" | "onLostPointerCapture" | "onLostPointerCaptureCapture" | "onScroll" | "onScrollCapture" | "onWheel" | "onWheelCapture" | "onAnimationStart" | "onAnimationStartCapture" | "onAnimationEnd" | "onAnimationEndCapture" | "onAnimationIteration" | "onAnimationIterationCapture" | "onTransitionEnd" | "onTransitionEndCapture" | "list" | "height" | "media" | "method" | "crossOrigin" | "href" | "src" | "content" | "useMap" | "htmlFor" | "classID" | "accept" | "alt" | "autoComplete" | "autoFocus" | "checked" | "formAction" | "formEncType" | "formMethod" | "formNoValidate" | "formTarget" | "maxLength" | "minLength" | "multiple" | "required" | "coords" | "download" | "hrefLang" | "rel" | "acceptCharset" | "allowFullScreen" | "allowTransparency" | "as" | "autoPlay" | "cellPadding" | "cellSpacing" | "charSet" | "challenge" | "cols" | "colSpan" | "controls" | "dateTime" | "defer" | "encType" | "frameBorder" | "headers" | "high" | "httpEquiv" | "integrity" | "keyParams" | "keyType" | "kind" | "loop" | "low" | "manifest" | "marginHeight" | "marginWidth" | "mediaGroup" | "muted" | "nonce" | "noValidate" | "open" | "optimum" | "playsInline" | "poster" | "preload" | "reversed" | "rowSpan" | "sandbox" | "scope" | "scoped" | "scrolling" | "seamless" | "sizes" | "srcDoc" | "srcLang" | "srcSet" | "start" | "wmode" | "wrap" | "htmlValue"> & React__default.RefAttributes<HTMLInputElement>>;

interface Props$7 {
    /** Callback function to handle uploaded file  */
    onFileUpload: (event: FormEvent<HTMLInputElement>) => void;
    /** Accepted file extensions */
    accept?: string;
    /** Overwrite or add to style */
    className?: string;
    /** Button size */
    size?: ComponentSize;
    /** Show the file name */
    showFileName?: boolean;
}
declare const FileUpload: ({ onFileUpload, className, children, accept, size, showFileName, }: React__default.PropsWithChildren<Props$7>) => JSX.Element;

declare type BackwardsCompatibleDropzoneOptions = Omit<DropzoneOptions, 'accept'> & {
    accept?: string | string[] | Accept;
};
interface FileDropzoneProps {
    /**
     * Use the children property to have custom dropzone view.
     */
    children?: ReactNode;
    /**
     * Use this property to override the default behaviour for the react-dropzone options.
     * @default {
     *  maxSize: Infinity,
     *  minSize: 0,
     *  multiple: true,
     *  useFsAccessApi: false,
     *  maxFiles: 0,
     * }
     */
    options?: BackwardsCompatibleDropzoneOptions;
    /**
     * Use this to change the FileReader's read.
     */
    readAs?: 'readAsArrayBuffer' | 'readAsText' | 'readAsBinaryString' | 'readAsDataURL';
    /**
     * Use the onLoad function to get the result from FileReader.
     */
    onLoad?: (result: string | ArrayBuffer | null) => void;
    /**
     * The fileListRenderer property can be used to overwrite the list of files. To not to show
     * any list return null in the function.
     */
    fileListRenderer?: (file: DropzoneFile, removeFile: (file: DropzoneFile) => void) => ReactNode;
    onFileRemove?: (file: DropzoneFile) => void;
}
interface DropzoneFile {
    file: File;
    id: string;
    error: DOMException | null;
    progress?: number;
    abortUpload?: () => void;
    retryUpload?: () => void;
}
declare function FileDropzone({ options, children, readAs, onLoad, fileListRenderer, onFileRemove }: FileDropzoneProps): JSX.Element;
declare function FileDropzoneDefaultChildren({ primaryText, secondaryText, }: {
    primaryText?: string | undefined;
    secondaryText?: string | undefined;
}): JSX.Element;

interface FileListItemProps {
    file: DropzoneFile;
    removeFile?: (file: DropzoneFile) => void;
}
declare function FileListItem({ file: customFile, removeFile }: FileListItemProps): JSX.Element;

interface TimeRangeInputProps {
    value: TimeRange;
    timeZone?: TimeZone;
    onChange: (timeRange: TimeRange) => void;
    onChangeTimeZone?: (timeZone: TimeZone) => void;
    hideTimeZone?: boolean;
    placeholder?: string;
    clearable?: boolean;
    /** Controls horizontal alignment of the picker menu */
    isReversed?: boolean;
    /** Controls visibility of the preset time ranges (e.g. **Last 5 minutes**) in the picker menu */
    hideQuickRanges?: boolean;
    disabled?: boolean;
}
declare const TimeRangeInput: ({ value, onChange, onChangeTimeZone, clearable, hideTimeZone, timeZone, placeholder, isReversed, hideQuickRanges, disabled, }: TimeRangeInputProps) => JSX.Element;

/**
 * @internal
 */
interface RelativeTimeRangePickerProps {
    timeRange: RelativeTimeRange;
    onChange: (timeRange: RelativeTimeRange) => void;
}
/**
 * @internal
 */
declare function RelativeTimeRangePicker(props: RelativeTimeRangePickerProps): JSX.Element;

/**
 * @public
 */
interface CardInnerProps {
    href?: string;
    children?: React__default.ReactNode;
}
/**
 * @public
 */
interface CardContainerProps extends HTMLAttributes<HTMLOrSVGElement>, CardInnerProps {
    /** Disable pointer events for the Card, e.g. click events */
    disableEvents?: boolean;
    /** No style change on hover */
    disableHover?: boolean;
    /** Makes the card selectable, set to "true" to apply selected styles */
    isSelected?: boolean;
    /** Custom container styles */
    className?: string;
}
/** @deprecated Using `CardContainer` directly is discouraged and should be replaced with `Card` */
declare const CardContainer: ({ children, disableEvents, disableHover, isSelected, className, href, ...props }: CardContainerProps) => JSX.Element;

/**
 * @public
 */
interface Props$6 extends Omit<CardContainerProps, 'disableEvents' | 'disableHover'> {
    /** Indicates if the card and all its actions can be interacted with */
    disabled?: boolean;
    /** Link to redirect to on card click. If provided, the Card inner content will be rendered inside `a` */
    href?: string;
    /** On click handler for the Card */
    onClick?: (e: React__default.MouseEvent<HTMLElement>) => void;
    /** @deprecated Use `Card.Heading` instead */
    heading?: ReactNode;
    /** @deprecated Use `Card.Description` instead */
    description?: string;
    isSelected?: boolean;
}
interface CardInterface extends FC<Props$6> {
    Heading: typeof Heading;
    Tags: typeof Tags;
    Figure: typeof Figure;
    Meta: typeof Meta;
    Actions: typeof Actions;
    SecondaryActions: typeof SecondaryActions;
    Description: typeof Description;
}
/**
 * Generic card component
 *
 * @public
 */
declare const Card: CardInterface;
interface ChildProps {
    className?: string;
    disabled?: boolean;
    children?: React__default.ReactNode;
}
/** Main heading for the card */
declare const Heading: {
    ({ children, className, "aria-label": ariaLabel }: ChildProps & {
        'aria-label'?: string;
    }): JSX.Element;
    displayName: string;
};
declare const Tags: {
    ({ children, className }: ChildProps): JSX.Element;
    displayName: string;
};
/** Card description text */
declare const Description: {
    ({ children, className }: ChildProps): JSX.Element;
    displayName: string;
};
declare const Figure: {
    ({ children, align, className }: ChildProps & {
        align?: "center" | "start" | undefined;
    }): JSX.Element;
    displayName: string;
};
declare const Meta: React__default.MemoExoticComponent<({ children, className, separator }: ChildProps & {
    separator?: string | undefined;
}) => JSX.Element | null>;
declare const Actions: {
    ({ children, disabled, className }: ChildProps): JSX.Element;
    displayName: string;
};
declare const SecondaryActions: {
    ({ children, disabled, className }: ChildProps): JSX.Element;
    displayName: string;
};
/**
 * @public
 * @deprecated Use `className` on respective components to modify styles
 */
declare const getCardStyles: (theme: GrafanaTheme2) => {
    tagList: string;
    actions: string;
    secondaryActions: string;
    media: string;
    description: string;
    metadata: string;
    metadataItem: string;
    separator: string;
    heading: string;
    linkHack: string;
    inner: string;
};

interface Props$5 extends Omit<HTMLProps<HTMLDivElement>, 'className' | 'value' | 'style'> {
    value: FormattedValue;
    className?: string;
    style?: CSSProperties;
}
declare const FormattedValueDisplay: {
    ({ value, className, style, ...htmlProps }: Props$5): JSX.Element;
    displayName: string;
};

interface Props$4<T> extends HTMLAttributes<HTMLButtonElement> {
    className?: string;
    options: Array<SelectableValue<T>>;
    value?: SelectableValue<T>;
    onChange: (item: SelectableValue<T>) => void;
    tooltipContent?: PopoverContent;
    narrow?: boolean;
    variant?: ToolbarButtonVariant;
}
declare const ButtonSelect: {
    <T>(props: Props$4<T>): JSX.Element;
    displayName: string;
};

interface Props$3 {
    overlay: React__default.ReactElement | (() => React__default.ReactElement);
    placement?: TooltipPlacement;
    children: React__default.ReactElement | ((isOpen: boolean) => React__default.ReactElement);
    /** Amount in pixels to nudge the dropdown vertically and horizontally, respectively. */
    offset?: [number, number];
    onVisibleChange?: (state: boolean) => void;
}
declare const Dropdown: React__default.MemoExoticComponent<({ children, overlay, placement, offset, onVisibleChange }: Props$3) => JSX.Element>;

/**
 * @public
 */
interface PluginSignatureBadgeProps extends HTMLAttributes<HTMLDivElement> {
    status?: PluginSignatureStatus;
}
/**
 * @public
 */
declare const PluginSignatureBadge: {
    ({ status, ...otherProps }: PluginSignatureBadgeProps): JSX.Element;
    displayName: string;
};

interface Props$2 {
    children: ReactNode;
    className?: string;
    htmlFor?: string;
    isFocused?: boolean;
    isInvalid?: boolean;
    tooltip?: PopoverContent;
    width?: number | 'auto';
    /** Make tooltip interactive */
    interactive?: boolean;
}
declare const InlineFormLabel: ({ children, isFocused, isInvalid, className, htmlFor, tooltip, width, interactive, ...rest }: Props$2) => JSX.Element;

/**
 * @alpha
 */
declare const graphFieldOptions: {
    drawStyle: SelectableValue<GraphDrawStyle>[];
    lineInterpolation: SelectableValue<LineInterpolation>[];
    barAlignment: SelectableValue<BarAlignment>[];
    showPoints: SelectableValue<VisibilityMode>[];
    axisPlacement: SelectableValue<AxisPlacement>[];
    fillGradient: SelectableValue<GraphGradientMode>[];
    stacking: SelectableValue<StackingMode>[];
    thresholdsDisplayModes: SelectableValue<GraphTresholdsStyleMode>[];
};

declare type UPlotChartState = {
    plot: uPlot | null;
};
/**
 * @internal
 * uPlot abstraction responsible for plot initialisation, setup and refresh
 * Receives a data frame that is x-axis aligned, as of https://github.com/leeoniya/uPlot/tree/master/docs#data-format
 * Exposes context for uPlot instance access
 */
declare class UPlotChart extends Component<PlotProps, UPlotChartState> {
    plotContainer: React__default.RefObject<HTMLDivElement>;
    plotCanvasBBox: React__default.RefObject<DOMRect>;
    constructor(props: PlotProps);
    reinitPlot(): void;
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: PlotProps): void;
    render(): JSX.Element;
}

interface PlotLegendProps extends VizLegendOptions, Omit<VizLayoutLegendProps, 'children'> {
    data: DataFrame[];
    config: UPlotConfigBuilder;
}
declare const PlotLegend: React__default.MemoExoticComponent<({ data, config, placement, calcs, displayMode, ...vizLayoutLegendProps }: PlotLegendProps) => JSX.Element>;

interface EventsCanvasProps {
    id: string;
    config: UPlotConfigBuilder;
    events: DataFrame[];
    renderEventMarker: (dataFrame: DataFrame, dataFrameFieldIndex: DataFrameFieldIndex) => React__default.ReactNode;
    mapEventToXYCoords: (dataFrame: DataFrame, dataFrameFieldIndex: DataFrameFieldIndex) => {
        x: number;
        y: number;
    } | undefined;
}
declare function EventsCanvas({ id, events, renderEventMarker, mapEventToXYCoords, config }: EventsCanvasProps): JSX.Element | null;

interface MarkerProps {
    /** x position relative to plotting area bounding box*/
    x: number;
    /** y position relative to plotting area bounding box*/
    y: number;
}
declare const Marker: ({ x, y, children }: React__default.PropsWithChildren<MarkerProps>) => JSX.Element;

interface XYCanvasProps {
    top: number;
    left: number;
}
/**
 * Renders absolutely positioned element on top of the uPlot's plotting area (axes are not included!).
 * Useful when you want to render some overlay with canvas-independent elements on top of the plot.
 */
declare const XYCanvas: ({ children, left, top }: React__default.PropsWithChildren<XYCanvasProps>) => JSX.Element;

interface ZoomPluginProps {
    onZoom: (range: {
        from: number;
        to: number;
    }) => void;
    config: UPlotConfigBuilder;
}
/**
 * @alpha
 */
declare const ZoomPlugin: ({ onZoom, config }: ZoomPluginProps) => null;

interface TooltipPluginProps {
    timeZone: TimeZone;
    data: DataFrame;
    frames?: DataFrame[];
    config: UPlotConfigBuilder;
    mode?: TooltipDisplayMode;
    sortOrder?: SortOrder;
    sync?: () => DashboardCursorSync;
    renderTooltip?: (alignedFrame: DataFrame, seriesIdx: number | null, datapointIdx: number | null) => React__default.ReactNode;
}
/**
 * @alpha
 */
declare const TooltipPlugin: ({ mode, sortOrder, sync, timeZone, config, renderTooltip, ...otherProps }: TooltipPluginProps) => JSX.Element | null;

interface KeyboardPluginProps {
    config: UPlotConfigBuilder;
}
/**
 * @alpha
 */
declare const KeyboardPlugin: ({ config }: KeyboardPluginProps) => null;

/**
 * Event being triggered when the user interact with the Graph legend.
 * @alpha
 */
interface GraphNGLegendEvent {
    fieldIndex: DataFrameFieldIndex;
    mode: SeriesVisibilityChangeMode;
}
/** @alpha */
interface XYFieldMatchers {
    x: FieldMatcher;
    y: FieldMatcher;
}

/**
 * @internal -- not a public API
 */
declare const FIXED_UNIT = "__fixed";
/**
 * @internal -- not a public API
 */
declare type PropDiffFn<T extends any = any> = (prev: T, next: T) => boolean;
interface GraphNGProps extends Themeable2 {
    frames: DataFrame[];
    structureRev?: number;
    width: number;
    height: number;
    timeRange: TimeRange;
    timeZone: TimeZone[] | TimeZone;
    legend: VizLegendOptions;
    fields?: XYFieldMatchers;
    renderers?: Renderers;
    tweakScale?: (opts: ScaleProps, forField: Field$1) => ScaleProps;
    tweakAxis?: (opts: AxisProps, forField: Field$1) => AxisProps;
    onLegendClick?: (event: GraphNGLegendEvent) => void;
    children?: (builder: UPlotConfigBuilder, alignedFrame: DataFrame) => React__default.ReactNode;
    prepConfig: (alignedFrame: DataFrame, allFrames: DataFrame[], getTimeRange: () => TimeRange) => UPlotConfigBuilder;
    propsToDiff?: Array<string | PropDiffFn>;
    preparePlotFrame?: (frames: DataFrame[], dimFields: XYFieldMatchers) => DataFrame;
    renderLegend: (config: UPlotConfigBuilder) => React__default.ReactElement | null;
    /**
     * needed for propsToDiff to re-init the plot & config
     * this is a generic approach to plot re-init, without having to specify which panel-level options
     * should cause invalidation. we can drop this in favor of something like panelOptionsRev that gets passed in
     * similar to structureRev. then we can drop propsToDiff entirely.
     */
    options?: Record<string, any>;
}
/**
 * @internal -- not a public API
 */
interface GraphNGState {
    alignedFrame: DataFrame;
    alignedData?: AlignedData;
    config?: UPlotConfigBuilder;
}
/**
 * "Time as X" core component, expects ascending x
 */
declare class GraphNG extends Component<GraphNGProps, GraphNGState> {
    static contextType: React__default.Context<PanelContext>;
    panelContext: PanelContext;
    private plotInstance;
    private subscription;
    constructor(props: GraphNGProps);
    getTimeRange: () => TimeRange;
    prepState(props: GraphNGProps, withConfig?: boolean): GraphNGState;
    handleCursorUpdate(evt: DataHoverEvent | LegacyGraphHoverEvent): void;
    componentDidMount(): void;
    componentDidUpdate(prevProps: GraphNGProps): void;
    componentWillUnmount(): void;
    render(): JSX.Element | null;
}

declare const TimeSeries: React__default.FunctionComponent<{
    fields?: XYFieldMatchers | undefined;
    width: number;
    options?: Record<string, any> | undefined;
    timeZone: string | string[];
    structureRev?: number | undefined;
    legend: _grafana_schema.VizLegendOptions;
    children?: ((builder: UPlotConfigBuilder, alignedFrame: DataFrame) => React__default.ReactNode) | undefined;
    height: number;
    timeRange: TimeRange;
    frames: DataFrame[];
    renderers?: Renderers | undefined;
    tweakScale?: ((opts: ScaleProps, forField: _grafana_data.Field<any, _grafana_data.Vector<any>>) => ScaleProps) | undefined;
    tweakAxis?: ((opts: AxisProps, forField: _grafana_data.Field<any, _grafana_data.Vector<any>>) => AxisProps) | undefined;
    onLegendClick?: ((event: GraphNGLegendEvent) => void) | undefined;
    preparePlotFrame?: ((frames: DataFrame[], dimFields: XYFieldMatchers) => DataFrame) | undefined;
}>;

/**
 * @alpha
 * Exposes API for data frame inspection in Plot plugins
 */
declare const useGraphNGContext: () => {
    dimFields: XYFieldMatchers;
    mapSeriesIndexToDataFrameFieldIndex: (index: number) => DataFrameFieldIndex;
    getXAxisField: () => Field$1<any, _grafana_data.Vector<any>> | null;
    alignedData: DataFrame;
};

declare function preparePlotFrame(frames: DataFrame[], dimFields: XYFieldMatchers, timeRange?: TimeRange | null): DataFrame | null;
declare function buildScaleKey(config: FieldConfig<GraphFieldConfig>): string;

declare type OnLabelClick = (name: string, value: string | undefined, event: React__default.MouseEvent<HTMLElement>) => void;
interface Props$1 extends Omit<HTMLAttributes<HTMLElement>, 'onClick'> {
    name: string;
    active?: boolean;
    loading?: boolean;
    searchTerm?: string;
    value?: string;
    facets?: number;
    title?: string;
    highlightParts?: HighlightPart[];
    onClick?: OnLabelClick;
}
/**
 * @internal
 */
declare const Label: React__default.ForwardRefExoticComponent<Props$1 & React__default.RefAttributes<HTMLButtonElement>>;

declare type Props = DetailedHTMLProps<HTMLAttributes<HTMLDivElement>, HTMLDivElement>;
declare const PanelContainer: ({ children, className, ...props }: Props) => JSX.Element;

declare const LegacyForms: {
    SecretFormField: {
        ({ label, labelWidth, inputWidth, onReset, isConfigured, tooltip, placeholder, interactive, ...inputProps }: Props$1d): JSX.Element;
        displayName: string;
    };
    FormField: {
        ({ label, tooltip, labelWidth, inputWidth, inputEl, className, interactive, ...inputProps }: Props$1e): JSX.Element;
        displayName: string;
        defaultProps: {
            labelWidth: number;
            inputWidth: number;
        };
    };
    Select: typeof Select$1;
    AsyncSelect: typeof AsyncSelect$1;
    IndicatorsContainer: (props: any) => JSX.Element;
    NoOptionsMessage: <T extends unknown>(props: Props$1g<T>) => JSX.Element;
    Input: typeof Input$1;
    Switch: typeof Switch$1;
};

/**
 * @alpha
 */
declare function addAxisConfig(builder: FieldConfigEditorBuilder<AxisConfig>, defaultConfig: AxisConfig, hideScale?: boolean): void;
/**
 * @internal
 */
declare const ScaleDistributionEditor: ({ value, onChange }: StandardEditorProps<ScaleDistributionConfig>) => JSX.Element;

/**
 * @alpha
 */
declare function addHideFrom(builder: FieldConfigEditorBuilder<HideableFieldConfig>): void;

/**
 * @alpha
 */
declare function addLegendOptions<T extends OptionsWithLegend>(builder: PanelOptionsEditorBuilder<T>, includeLegendCalcs?: boolean): void;

declare function addTooltipOptions<T extends OptionsWithTooltip>(builder: PanelOptionsEditorBuilder<T>, singleOnly?: boolean): void;

/**
 * Adds common text control options to a visualization options
 * @param builder
 * @param withTitle
 * @public
 */
declare function addTextSizeOptions<T extends OptionsWithTextFormatting>(builder: PanelOptionsEditorBuilder<T>, withTitle?: boolean): void;

declare const StackingEditor: ({ value, context, onChange, item }: FieldOverrideEditorProps<StackingConfig, any>) => JSX.Element;
declare function addStackingConfig(builder: FieldConfigEditorBuilder<GraphFieldConfig>, defaultConfig?: StackingConfig, category?: string[]): void;

declare const index_d_addAxisConfig: typeof addAxisConfig;
declare const index_d_ScaleDistributionEditor: typeof ScaleDistributionEditor;
declare const index_d_addHideFrom: typeof addHideFrom;
declare const index_d_addLegendOptions: typeof addLegendOptions;
declare const index_d_addTooltipOptions: typeof addTooltipOptions;
declare const index_d_addTextSizeOptions: typeof addTextSizeOptions;
declare const index_d_StackingEditor: typeof StackingEditor;
declare const index_d_addStackingConfig: typeof addStackingConfig;
declare namespace index_d {
  export {
    index_d_addAxisConfig as addAxisConfig,
    index_d_ScaleDistributionEditor as ScaleDistributionEditor,
    index_d_addHideFrom as addHideFrom,
    index_d_addLegendOptions as addLegendOptions,
    index_d_addTooltipOptions as addTooltipOptions,
    index_d_addTextSizeOptions as addTextSizeOptions,
    index_d_StackingEditor as StackingEditor,
    index_d_addStackingConfig as addStackingConfig,
  };
}

declare function BracesPlugin(): Plugin;

declare function ClearPlugin(): Plugin;

declare function ClipboardPlugin(): Plugin;

declare function IndentationPlugin(): Plugin;

declare function NewlinePlugin(): Plugin;

declare function RunnerPlugin({ handler }: {
    handler?: (e: React__default.KeyboardEvent) => void;
}): Plugin;

declare function SelectionShortcutsPlugin(): Plugin;

interface OptionsFormat {
    onlyIn?: (node: Node) => boolean;
    getSyntax?: (node: Node) => string;
    renderMark?: ({ mark, children }: {
        mark: Mark;
        children: React__default.ReactNode;
    }) => void | React__default.ReactNode;
}

interface Token {
    content: string;
    offsets?: {
        start: number;
        end: number;
    };
    types: string[];
    aliases: string[];
    prev?: Token | null;
    next?: Token | null;
}
/**
 * A Slate plugin to highlight code syntax.
 */
declare function SlatePrism(optsParam?: OptionsFormat, prismLanguages?: Prism.LanguageMap): Plugin;

declare function SuggestionsPlugin({ onTypeahead, cleanText, onWillApplySuggestion, portalOrigin, }: {
    onTypeahead?: (typeahead: TypeaheadInput) => Promise<TypeaheadOutput>;
    cleanText?: (text: string) => string;
    onWillApplySuggestion?: (suggestion: string, state: SuggestionsState) => string;
    portalOrigin: string;
}): Plugin;

export { ALERTING_COLOR, ActionMeta, AdHocFilterItem, Alert, AlertVariant, AlertingSettings, AsyncMultiSelect, AsyncSelect, AsyncSelectProps, AsyncVirtualizedSelect, AutoSizeInput, Badge, BadgeColor, BadgeProps, BarGauge, BigValue, BigValueColorMode, BigValueGraphMode, BigValueJustifyMode, BigValueTextMode, BracesPlugin, Label as BrowserLabel, Button, ButtonCascader, ButtonGroup, ButtonProps, ButtonSelect, ButtonVariant, CallToActionCard, Card, CardContainer, CardContainerProps, Props$6 as CardProps, Cascader, CascaderOption, CertificationKey, Checkbox, ClearPlugin, ClickOutsideWrapper, ClipboardButton, ClipboardPlugin, CodeEditor, MonacoOptions as CodeEditorMonacoOptions, CodeEditorSuggestionItem, CodeEditorSuggestionItemKind, CollapsableSection, Collapse, ColorPicker, ColorPickerInput, Column, CompletionItem, CompletionItemGroup, CompletionItemKind, ComponentSize, ConfirmButton, ConfirmModal, ConfirmModalProps, Container, ContextMenu, ContextMenuProps, ControlComponent, ControlledCollapse, Counter, CustomComponentProps, CustomControlProps, CustomHeadersSettings, CustomScrollbar, DEFAULT_ANNOTATION_COLOR, dom_d as DOMUtil, DataLinkButton, DataLinkInput, DataLinksContextMenu, DataLinksContextMenuApi, DataLinksContextMenuProps, DataLinksInlineEditor, DataSourceHttpSettings, DatePicker, DatePickerProps, DatePickerWithInput, DatePickerWithInputProps, DateTimePicker, DeleteButton, Drawer, Dropdown, DropdownIndicator, DropzoneFile, EmptySearchResult, ErrorBoundary, ErrorBoundaryAlert, ErrorBoundaryAlertProps, ErrorWithStack, EventsCanvas, EventsWithValidation, FIXED_UNIT, FadeTransition, FeatureBadge, FeatureInfoBox, Field, FieldArray, FieldArrayApi, FieldLinkList, FieldProps, FieldSet, FieldValidationMessage, FileDropzone, FileDropzoneDefaultChildren, FileDropzoneProps, FileListItem, FileListItemProps, FileUpload, FilterInput, FilterPill, Form, FormAPI, FormInputSize, FormatOptionLabelMeta, FormattedValueDisplay, FullWidthButtonContainer, Gauge, GlobalStyles, Graph, GraphContextMenu, GraphContextMenuHeader, GraphNG, GraphNGLegendEvent, GraphNGProps, GraphSeriesToggler, GraphSeriesTogglerAPI, GraphWithLegend, HighlightPart, HorizontalGroup, Icon, IconButton, IconButtonVariant, IconSize, IconType, IndentationPlugin, InfoBox, InlineField, InlineFieldRow, InlineFormLabel, InlineLabel, InlineSegmentGroup, InlineSwitch, InlineToast, Input, InputActionMeta, InputControl, InteractiveTable, JSONFormatter, JsonExplorer, KeyboardPlugin, Label$1 as Label, LegacyForms, LegacyInputStatus, Legend, Link, LinkButton, List, LoadOptionsCallback, LoadingBar, LoadingBarProps, LoadingPlaceholder, LoadingPlaceholderProps, LogLabels, LogMessageAnsi, LogRows, Marker, Menu, MenuGroup, MenuGroupProps, MenuItem, MenuItemProps, MenuItemsGroup, MenuProps, Modal, ModalHeader, Props$R as ModalProps, ModalRoot, ModalTabContent, ModalTabsHeader, ModalsContext, ModalsController, ModalsProvider, Monaco, MonacoEditor, MultiSelect, MultiSelectCommonProps, NO_DATA_COLOR, NewlinePlugin, NodeGraphDataFrameFieldNames, OK_COLOR, OnTagClick, PENDING_COLOR, PageToolbar, Pagination, PanelChrome, ErrorIndicator as PanelChromeErrorIndicator, ErrorIndicatorProps as PanelChromeErrorIndicatorProps, LoadingIndicator as PanelChromeLoadingIndicator, LoadingIndicatorProps as PanelChromeLoadingIndicatorProps, PanelChromeProps, PanelChromeType, PanelContainer, PanelContext, PanelContextProvider, PanelContextRoot, PanelPadding, PlotLegend, PlotSelection, PlotTooltipInterpolator, PluginSignatureBadge, PluginSignatureBadgeProps, Popover, PopoverContent, PopoverController, Portal, PortalContainer, QueryField, QueryFieldProps, REGION_FILL_ALPHA, RadioButtonGroup, RadioButtonList, RangeSlider, ReactMonacoEditorLazy as ReactMonacoEditor, ReactSelectProps, reactUtils_d as ReactUtils, RefreshPicker, RelativeTimeRangePicker, RenderUserContentAsHTML, RunnerPlugin, SCHEMA, ScrollbarPosition, SearchFunction, SearchFunctionType, SecretInput, SecretTextArea, SecureSocksProxySettings, Segment, SegmentAsync, SegmentInput, SegmentSection, SegmentSelect, Select, SelectAsyncProps, SelectBaseProps, SelectCommonProps, SelectContainer, SelectContainerProps, SelectOptions, SelectValue, SelectableOptGroup, SelectionShortcutsPlugin, SeriesColorPicker, SeriesColorPickerPopover, SeriesColorPickerPopoverWithTheme, SeriesIcon, SeriesTable, SeriesTableProps, SeriesTableRow, SeriesTableRowProps, SeriesVisibilityChangeBehavior, SeriesVisibilityChangeMode, SetInterval, SingleStatBaseOptions, SlatePrism, SlideOutTransition, Slider, Sparkline, Spinner, StatsPicker, SuggestionsPlugin, SuggestionsState, Switch, TLSAuthSettings, Tab, TabConfig, TabContent, TabbedContainer, Table, TableFooterCalc, TableInputCSV, TableSortByFieldState, TabsBar, Tag, TagList, TagsInput, TextArea, ThemeContext, Themeable, Themeable2, TimeOfDayPicker, TimePickerTooltip, TimeRangeInput, TimeRangePicker, TimeRangePickerProps, TimeSeries, TimeZonePicker, Toggletip, Token, ToolbarButton, ToolbarButtonRow, Tooltip, TooltipPlugin, TypeaheadInput, TypeaheadOutput, UPLOT_AXIS_FONT_SIZE, UPlotChart, UPlotConfigBuilder, UPlotConfigPrepFn, UnitPicker, ValidationEvents, ValidationRule, ValuePicker, VerticalGroup, VerticalTab, VirtualizedSelect, VirtualizedSelectAsyncProps, VirtualizedSelectProps, VizLayout, VizLayoutComponentType, VizLayoutLegendProps, VizLayoutProps, VizLegend, VizLegendItem, VizLegendListItem, VizRepeater, VizRepeaterRenderValueProps, VizTooltip, VizTooltipContainer, WeekStartPicker, WithContextMenu, XYCanvas, ZoomPlugin, attachDebugger, buildScaleKey, calculateFontSize, clearButtonStyles, colors, index_d as commonOptionsBuilder, convertOldAngularValueMapping, createLogger, defaultIntervals, fieldMatchersUI, fuzzyMatch, getAvailableIcons, getCanvasContext, getCardStyles, getCellLinks, getFieldTypeIcon, getFieldTypeIconName, getInputStyles, getLogRowStyles, getPortalContainer, getScrollbarWidth, getSelectStyles, getTagColor, getTagColorsFromName, getTextColorForAlphaBackground, getTextColorForBackground, getTheme, graphFieldOptions, graphTickFormatter, graphTimeFormat, hasValidationEvent, isCompactUrl, linkModelToContextMenuItems, makeFragment, makeValue, measureText, mockTheme, mockThemeContext, preparePlotFrame, regexValidation, resetSelectStyles, sharedInputStyle, sharedSingleStatMigrationHandler, sharedSingleStatPanelChangedHandler, sortedColors, mixins_d as styleMixins, stylesFactory, useForceUpdate, useGraphNGContext, usePanelContext, useStyles, useStyles2, useTheme, useTheme2, validate, variableSuggestionToCodeEditorSuggestion, withErrorBoundary, withTheme, withTheme2 };
