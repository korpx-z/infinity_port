{"version":3,"file":"logParser.js","sources":["../../../../src/components/Logs/logParser.ts"],"sourcesContent":["import memoizeOne from 'memoize-one';\n\nimport { Field, FieldType, getParser, LinkModel, LogRowModel } from '@grafana/data';\n\nimport { MAX_CHARACTERS } from './LogRowMessage';\n\nconst memoizedGetParser = memoizeOne(getParser);\n\ntype FieldDef = {\n  key: string;\n  value: string;\n  links?: Array<LinkModel<Field>>;\n  fieldIndex?: number;\n};\n\n/**\n * Returns all fields for log row which consists of fields we parse from the message itself and additional fields\n * found in the dataframe (they may contain links).\n *\n * @deprecated will be removed in the next major version\n */\nexport const getAllFields = memoizeOne(\n  (row: LogRowModel, getFieldLinks?: (field: Field, rowIndex: number) => Array<LinkModel<Field>>) => {\n    const logMessageFields = parseMessage(row.entry);\n    const dataframeFields = getDataframeFields(row, getFieldLinks);\n    const fieldsMap = [...dataframeFields, ...logMessageFields].reduce((acc, field) => {\n      // Strip enclosing quotes for hashing. When values are parsed from log line the quotes are kept, but if same\n      // value is in the dataFrame it will be without the quotes. We treat them here as the same value.\n      // We need to handle this scenario:\n      // - we use derived-fields in Loki\n      // - we name the derived field the same as the parsed-field-name\n      // - the same field will appear twice\n      //   - in the fields coming from `logMessageFields`\n      //   - in the fields coming from `dataframeFields`\n      // - but, in the fields coming from `logMessageFields`, there might be doublequotes around the value\n      // - we want to \"merge\" data from both sources, so we remove quotes from the beginning and end\n      const value = field.value.replace(/(^\")|(\"$)/g, '');\n      const fieldHash = `${field.key}=${value}`;\n      if (acc[fieldHash]) {\n        acc[fieldHash].links = [...(acc[fieldHash].links || []), ...(field.links || [])];\n      } else {\n        acc[fieldHash] = field;\n      }\n      return acc;\n    }, {} as { [key: string]: FieldDef });\n\n    const allFields = Object.values(fieldsMap);\n    allFields.sort(sortFieldsLinkFirst);\n\n    return allFields;\n  }\n);\n\nconst parseMessage = memoizeOne((rowEntry): FieldDef[] => {\n  if (rowEntry.length > MAX_CHARACTERS) {\n    return [];\n  }\n  const parser = memoizedGetParser(rowEntry);\n  if (!parser) {\n    return [];\n  }\n  // Use parser to highlight detected fields\n  const detectedFields = parser.getFields(rowEntry);\n  const fields = detectedFields.map((field) => {\n    const key = parser.getLabelFromField(field);\n    const value = parser.getValueFromField(field);\n    return { key, value };\n  });\n\n  return fields;\n});\n\n// creates fields from the dataframe-fields, adding data-links, when field.config.links exists\nconst getDataframeFields = memoizeOne(\n  (row: LogRowModel, getFieldLinks?: (field: Field, rowIndex: number) => Array<LinkModel<Field>>): FieldDef[] => {\n    return row.dataFrame.fields\n      .map((field, index) => ({ ...field, index }))\n      .filter((field, index) => !shouldRemoveField(field, index, row))\n      .map((field) => {\n        const links = getFieldLinks ? getFieldLinks(field, row.rowIndex) : [];\n        return {\n          key: field.name,\n          value: field.values.get(row.rowIndex).toString(),\n          links: links,\n          fieldIndex: field.index,\n        };\n      });\n  }\n);\n\nfunction sortFieldsLinkFirst(fieldA: FieldDef, fieldB: FieldDef) {\n  if (fieldA.links?.length && !fieldB.links?.length) {\n    return -1;\n  }\n  if (!fieldA.links?.length && fieldB.links?.length) {\n    return 1;\n  }\n  return fieldA.key > fieldB.key ? 1 : fieldA.key < fieldB.key ? -1 : 0;\n}\n\nfunction shouldRemoveField(field: Field, index: number, row: LogRowModel) {\n  // Remove field if it is:\n  // \"labels\" field that is in Loki used to store all labels\n  if (field.name === 'labels' && field.type === FieldType.other) {\n    return true;\n  }\n  // \"id\" field which we use for react key\n  if (field.name === 'id') {\n    return true;\n  }\n  // entry field which we are showing as the log message\n  if (row.entryFieldIndex === index) {\n    return true;\n  }\n  // hidden field\n  if (field.config.custom?.hidden) {\n    return true;\n  }\n  // field that has empty value (we want to keep 0 or empty string)\n  if (field.values.get(row.rowIndex) == null) {\n    return true;\n  }\n  return false;\n}\n"],"names":[],"mappings":"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"}