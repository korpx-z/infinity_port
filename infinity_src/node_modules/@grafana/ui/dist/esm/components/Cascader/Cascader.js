import { css } from '@emotion/css';
import memoizeOne from 'memoize-one';
import RCCascader from 'rc-cascader';
import React__default, { PureComponent } from 'react';
import { Icon } from '../Icon/Icon.js';
import { Input } from '../Input/Input.js';
import { Select } from '../Select/Select.js';
import { onChangeCascader } from './optionMappings.js';

const disableDivFocus = css(`
&:focus{
  outline: none;
}
`);
const DEFAULT_SEPARATOR = "/";
class Cascader extends PureComponent {
  constructor(props) {
    super(props);
    this.flattenOptions = (options, optionPath = []) => {
      let selectOptions = [];
      for (const option of options) {
        const cpy = [...optionPath];
        cpy.push(option);
        if (!option.items) {
          selectOptions.push({
            singleLabel: cpy[cpy.length - 1].label,
            label: cpy.map((o) => o.label).join(this.props.separator || ` ${DEFAULT_SEPARATOR} `),
            value: cpy.map((o) => o.value)
          });
        } else {
          selectOptions = [...selectOptions, ...this.flattenOptions(option.items, cpy)];
        }
      }
      return selectOptions;
    };
    this.getSearchableOptions = memoizeOne((options) => this.flattenOptions(options));
    //For rc-cascader
    this.onChange = (value, selectedOptions) => {
      const activeLabel = this.props.hideActiveLevelLabel ? "" : this.props.displayAllSelectedLevels ? selectedOptions.map((option) => option.label).join(this.props.separator || DEFAULT_SEPARATOR) : selectedOptions[selectedOptions.length - 1].label;
      this.setState({
        rcValue: value,
        focusCascade: true,
        activeLabel
      });
      this.props.onSelect(selectedOptions[selectedOptions.length - 1].value);
    };
    //For select
    this.onSelect = (obj) => {
      const valueArray = obj.value || [];
      this.setState({
        activeLabel: this.props.displayAllSelectedLevels ? obj.label : obj.singleLabel || "",
        rcValue: valueArray,
        isSearching: false
      });
      this.props.onSelect(valueArray[valueArray.length - 1]);
    };
    this.onCreateOption = (value) => {
      this.setState({
        activeLabel: value,
        rcValue: [],
        isSearching: false
      });
      this.props.onSelect(value);
    };
    this.onBlur = () => {
      var _a, _b;
      this.setState({
        isSearching: false,
        focusCascade: false
      });
      if (this.state.activeLabel === "") {
        this.setState({
          rcValue: []
        });
      }
      (_b = (_a = this.props).onBlur) == null ? void 0 : _b.call(_a);
    };
    this.onBlurCascade = () => {
      var _a, _b;
      this.setState({
        focusCascade: false
      });
      (_b = (_a = this.props).onBlur) == null ? void 0 : _b.call(_a);
    };
    this.onInputKeyDown = (e) => {
      if (["ArrowDown", "ArrowUp", "Enter", "ArrowLeft", "ArrowRight", "Backspace"].includes(e.key)) {
        return;
      }
      this.setState({
        focusCascade: false,
        isSearching: true
      });
    };
    this.onSelectInputChange = (value) => {
      if (value === "") {
        this.setState({
          isSearching: false
        });
      }
    };
    const searchableOptions = this.getSearchableOptions(props.options);
    const { rcValue, activeLabel } = this.setInitialValue(searchableOptions, props.initialValue);
    this.state = {
      isSearching: false,
      focusCascade: false,
      rcValue,
      activeLabel
    };
  }
  setInitialValue(searchableOptions, initValue) {
    if (!initValue) {
      return { rcValue: [], activeLabel: "" };
    }
    for (const option of searchableOptions) {
      const optionPath = option.value || [];
      if (optionPath.indexOf(initValue) === optionPath.length - 1) {
        return {
          rcValue: optionPath,
          activeLabel: this.props.displayAllSelectedLevels ? option.label : option.singleLabel || ""
        };
      }
    }
    if (this.props.allowCustomValue) {
      return { rcValue: [], activeLabel: initValue };
    }
    return { rcValue: [], activeLabel: "" };
  }
  render() {
    const { allowCustomValue, formatCreateLabel, placeholder, width, changeOnSelect, options } = this.props;
    const { focusCascade, isSearching, rcValue, activeLabel } = this.state;
    const searchableOptions = this.getSearchableOptions(options);
    return /* @__PURE__ */ React__default.createElement("div", null, isSearching ? /* @__PURE__ */ React__default.createElement(
      Select,
      {
        allowCustomValue,
        placeholder,
        autoFocus: !focusCascade,
        onChange: this.onSelect,
        onBlur: this.onBlur,
        options: searchableOptions,
        onCreateOption: this.onCreateOption,
        formatCreateLabel,
        width,
        onInputChange: this.onSelectInputChange
      }
    ) : /* @__PURE__ */ React__default.createElement(
      RCCascader,
      {
        onChange: onChangeCascader(this.onChange),
        options,
        changeOnSelect,
        value: rcValue.value,
        fieldNames: { label: "label", value: "value", children: "items" },
        expandIcon: null,
        open: this.props.alwaysOpen
      },
      /* @__PURE__ */ React__default.createElement("div", { className: disableDivFocus }, /* @__PURE__ */ React__default.createElement(
        Input,
        {
          autoFocus: this.props.autoFocus,
          width,
          placeholder,
          onBlur: this.onBlurCascade,
          value: activeLabel,
          onKeyDown: this.onInputKeyDown,
          onChange: () => {
          },
          suffix: focusCascade ? /* @__PURE__ */ React__default.createElement(Icon, { name: "angle-up" }) : /* @__PURE__ */ React__default.createElement(Icon, { name: "angle-down", style: { marginBottom: 0, marginLeft: "4px" } })
        }
      ))
    ));
  }
}
Cascader.defaultProps = { changeOnSelect: true };

export { Cascader };
//# sourceMappingURL=Cascader.js.map
