{"version":3,"file":"deepEqual.js","sourceRoot":"","sources":["../../../src/utils/deepEqual.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,MAAM,CAAC;AAEnD,gDAAgD;AAChD,mGAAmG;AAEnG,MAAM,UAAU,SAAS,CAAC,CAAM,EAAE,CAAM;IACtC,IAAI,CAAC,KAAK,CAAC,EAAE;QACX,OAAO,IAAI,CAAC;KACb;IAED,yEAAyE;IACzE,IAAI,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,IAAI,KAAK,CAAC,CAAW,CAAC,EAAE;QAC/C,OAAO,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,IAAI,KAAK,CAAC,CAAW,CAAC,CAAC;KACpD;IAED,MAAM,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;IAC5B,MAAM,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;IAE5B,IAAI,QAAQ,KAAK,QAAQ,EAAE;QACzB,OAAO,KAAK,CAAC;KACd;IAED,IAAI,QAAQ,IAAI,QAAQ,EAAE;QACxB,MAAM,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;QAExB,IAAI,MAAM,KAAK,CAAC,CAAC,MAAM,EAAE;YACvB,OAAO,KAAK,CAAC;SACd;QAED,KAAK,IAAI,GAAG,GAAG,MAAM,EAAE,GAAG,EAAE,KAAK,CAAC,GAAI;YACpC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;gBAC9B,OAAO,KAAK,CAAC;aACd;SACF;QAED,OAAO,IAAI,CAAC;KACb;IAED,MAAM,SAAS,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;IAC9B,MAAM,SAAS,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;IAE9B,IAAI,SAAS,KAAK,SAAS,EAAE;QAC3B,OAAO,KAAK,CAAC;KACd;IAED,IAAI,CAAC,IAAI,CAAC,IAAI,SAAS,IAAI,SAAS,EAAE;QACpC,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAA0B,CAAC;QACtD,MAAM,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC7B,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC;QAC7B,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC;QAE7B,IAAI,OAAO,KAAK,OAAO,EAAE;YACvB,OAAO,KAAK,CAAC;SACd;QAED,KAAK,IAAI,IAAI,IAAI,KAAK,EAAE;YACtB,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;gBACzB,OAAO,KAAK,CAAC;aACd;SACF;QAED,KAAK,IAAI,IAAI,IAAI,KAAK,EAAE;YACtB,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,EAAE;gBAChC,OAAO,KAAK,CAAC;aACd;SACF;QAED,OAAO,IAAI,CAAC;KACb;IAED,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["import { isArray, isObject, isTypeof } from './is';\n\n// This function was inspired by fast-deep-equal\n// fast-deep-equal has issues with Rollup and also it checks for some edge cases that we don't need\n\nexport function deepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  // Using isTypeOf instead of isNumber as isNumber also checks against NaN\n  if (isTypeof(a, 'number') && isNaN(a as number)) {\n    return isTypeof(b, 'number') && isNaN(b as number);\n  }\n\n  const aIsArray = isArray(a);\n  const bIsArray = isArray(b);\n\n  if (aIsArray !== bIsArray) {\n    return false;\n  }\n\n  if (aIsArray && bIsArray) {\n    const length = a.length;\n\n    if (length !== b.length) {\n      return false;\n    }\n\n    for (let idx = length; idx-- !== 0; ) {\n      if (!deepEqual(a[idx], b[idx])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  const aIsObject = isObject(a);\n  const bIsObject = isObject(b);\n\n  if (aIsObject !== bIsObject) {\n    return false;\n  }\n\n  if (a && b && aIsObject && bIsObject) {\n    const aKeys = Object.keys(a) as Array<keyof typeof a>;\n    const bKeys = Object.keys(b);\n    const aLength = aKeys.length;\n    const bLength = bKeys.length;\n\n    if (aLength !== bLength) {\n      return false;\n    }\n\n    for (let aKey of aKeys) {\n      if (!bKeys.includes(aKey)) {\n        return false;\n      }\n    }\n\n    for (let aKey of aKeys) {\n      if (!deepEqual(a[aKey], b[aKey])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n"]}