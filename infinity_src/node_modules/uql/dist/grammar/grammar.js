"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
// Generated automatically by nearley, version 3.0.0-beta.2
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
var moo = require("moo");
var uqlLexer = moo.compile({
    ws: /[ \t]+/,
    comment: {
        match: /#[^\n]*/,
        value: function (s) { return s.substring(1); }
    },
    nl: {
        match: "\n",
        lineBreaks: true,
    },
    sq_string: {
        match: /'(?:[^\n\\']|\\['"\\ntbfr])*'/,
        value: function (s) { return s.slice(1, -1); },
    },
    string: {
        match: /"(?:[^\n\\"]|\\['"\\ntbfr])*"/,
        value: function (s) { return JSON.parse(s); },
    },
    number: {
        // @ts-ignore Ignore the error for now until finding a better regex
        match: /-?[\d.]+(?:e-?\d+)?/,
        value: function (s) { return Number(s); },
    },
    pipe: "|",
    plus: "+",
    dash: "-",
    mul: "*",
    divide: "/",
    mod: "%",
    gt: ">",
    lt: "<",
    eq: "==",
    ne: "!=",
    lparan: "(",
    rparan: ")",
    comma: ",",
    tilde: "~",
    exclaim: "!",
    assignment: "=",
    return: "\r\n",
    identifier: {
        match: /[a-z_][a-zA-Z_0-9]*/,
        type: moo.keywords({
            str: "str",
        }),
    },
});
var pick = function (idx) { return function (d) { return d[idx]; }; };
var merge = function (newIndex, oldIndex) { return function (d) { return __spreadArray([d[newIndex]], d[oldIndex], true); }; };
var as_array = function (idx) { return function (d) { return [d[idx]]; }; };
var as_string = function (d) { return d[0].value; };
var as_number = function (d) { return +d[0].value; };
var dispose = function () { return null; };
;
;
;
;
var grammar = {
    Lexer: uqlLexer,
    ParserRules: [
        { "name": "input", "symbols": ["commands"], "postprocess": pick(0) },
        { "name": "commands", "symbols": ["command", "__"], "postprocess": as_array(0) },
        { "name": "commands$ebnf$1", "symbols": [] },
        { "name": "commands$ebnf$1", "symbols": ["commands$ebnf$1", (uqlLexer.has("comment") ? { type: "comment" } : comment)], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "commands", "symbols": ["command", "__", "commands$ebnf$1", { "literal": "\r\n" }, "__", "pipeo", "__", "commands"], "postprocess": merge(0, 7) },
        { "name": "commands$ebnf$2", "symbols": [] },
        { "name": "commands$ebnf$2", "symbols": ["commands$ebnf$2", (uqlLexer.has("comment") ? { type: "comment" } : comment)], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "commands", "symbols": ["command", "__", "commands$ebnf$2", "nlo", "__", "pipeo", "__", "commands"], "postprocess": merge(0, 7) },
        { "name": "command", "symbols": ["line_comment"], "postprocess": pick(0) },
        { "name": "command", "symbols": [{ "literal": "hello" }], "postprocess": function (d) { return ({ type: "hello" }); } },
        { "name": "command", "symbols": [{ "literal": "ping" }], "postprocess": function (d) { return ({ type: "ping", value: "pong" }); } },
        { "name": "command", "symbols": [{ "literal": "echo" }, "__", "str"], "postprocess": function (d) { return ({ type: "echo", value: d[2] }); } },
        { "name": "command", "symbols": [{ "literal": "count" }], "postprocess": function (d) { return ({ type: "count" }); } },
        { "name": "command", "symbols": [{ "literal": "limit" }, "__", "number"], "postprocess": function (d) { return ({ type: "limit", value: d[2] }); } },
        { "name": "command", "symbols": ["function"], "postprocess": function (d) { return ({ type: "command", value: d[0] }); } },
        { "name": "command", "symbols": ["command_orderby"], "postprocess": function (d) { return ({ type: "orderby", value: d[0] }); } },
        { "name": "command", "symbols": ["command_extend"], "postprocess": function (d) { return ({ type: "extend", value: d[0] }); } },
        { "name": "command", "symbols": ["command_project_away"], "postprocess": function (d) { return ({ type: "project-away", value: d[0] }); } },
        { "name": "command", "symbols": ["command_project_reorder"], "postprocess": function (d) { return ({ type: "project-reorder", value: d[0] }); } },
        { "name": "command", "symbols": ["command_project"], "postprocess": function (d) { return ({ type: "project", value: d[0] }); } },
        { "name": "command", "symbols": ["command_parse_json"], "postprocess": function (d) { return ({ type: "parse-json", args: d[0] }); } },
        { "name": "command", "symbols": ["command_parse_csv"], "postprocess": function (d) { return ({ type: "parse-csv", args: d[0] }); } },
        { "name": "command", "symbols": ["command_parse_xml"], "postprocess": function (d) { return ({ type: "parse-xml", args: d[0] }); } },
        { "name": "command", "symbols": ["command_parse_yaml"], "postprocess": function (d) { return ({ type: "parse-yaml", args: d[0] }); } },
        { "name": "command", "symbols": ["command_scope"], "postprocess": function (d) { return ({ type: "scope", value: d[0] }); } },
        { "name": "command", "symbols": ["command_where"], "postprocess": function (d) { return ({ type: "where", value: d[0] }); } },
        { "name": "command", "symbols": ["command_distinct"], "postprocess": function (d) { return ({ type: "distinct", value: d[0] }); } },
        { "name": "command", "symbols": ["command_mv_expand"], "postprocess": function (d) { return ({ type: "mv-expand", value: d[0] }); } },
        { "name": "command", "symbols": ["command_summarize"], "postprocess": function (d) { return ({ type: "summarize", value: d[0] }); } },
        { "name": "command", "symbols": ["command_pivot"], "postprocess": function (d) { return ({ type: "pivot", value: d[0] }); } },
        { "name": "command", "symbols": ["command_range"], "postprocess": function (d) { return ({ type: "range", value: d[0] }); } },
        { "name": "command", "symbols": [{ "literal": "jsonata" }, "__", "str"], "postprocess": function (d) { return ({ type: "jsonata", expression: d[2] }); } },
        { "name": "function_assignments", "symbols": ["function_assignment"], "postprocess": as_array(0) },
        { "name": "function_assignments", "symbols": ["function_assignment", "__", { "literal": "," }, "__", "function_assignments"], "postprocess": merge(0, 4) },
        { "name": "function_assignment$ebnf$1", "symbols": [] },
        { "name": "function_assignment$ebnf$1", "symbols": ["function_assignment$ebnf$1", "str"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "function_assignment$ebnf$2", "symbols": [] },
        { "name": "function_assignment$ebnf$2", "symbols": ["function_assignment$ebnf$2", { "literal": "=" }], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "function_assignment", "symbols": ["function_assignment$ebnf$1", "function_assignment$ebnf$2", "expression"], "postprocess": function (d) { return (__assign({ alias: d[0][0] }, d[2])); } },
        { "name": "function_assignment$ebnf$3", "symbols": [] },
        { "name": "function_assignment$ebnf$3", "symbols": ["function_assignment$ebnf$3", "str"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "function_assignment$ebnf$4", "symbols": [] },
        { "name": "function_assignment$ebnf$4", "symbols": ["function_assignment$ebnf$4", { "literal": "=" }], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "function_assignment", "symbols": ["function_assignment$ebnf$3", "function_assignment$ebnf$4", "function"], "postprocess": function (d) { return (__assign({ alias: d[0][0] }, d[2])); } },
        { "name": "function_assignment$ebnf$5", "symbols": [] },
        { "name": "function_assignment$ebnf$5", "symbols": ["function_assignment$ebnf$5", "str"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "function_assignment$ebnf$6", "symbols": [] },
        { "name": "function_assignment$ebnf$6", "symbols": ["function_assignment$ebnf$6", { "literal": "=" }], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "function_assignment", "symbols": ["function_assignment$ebnf$5", "function_assignment$ebnf$6", "ref_type"], "postprocess": function (d) { return (__assign({ alias: d[0][0] }, d[2])); } },
        { "name": "function_assignment", "symbols": ["ref_type"], "postprocess": function (d) { return d[0]; } },
        { "name": "expression$ebnf$1", "symbols": [] },
        { "name": "expression$ebnf$1", "symbols": ["expression$ebnf$1", "expression_args"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "expression", "symbols": [(uqlLexer.has("lparan") ? { type: "lparan" } : lparan), "__", "expression$ebnf$1", (uqlLexer.has("rparan") ? { type: "rparan" } : rparan)], "postprocess": function (d) { return ({ type: "expression", args: d[2][0] || [] }); } },
        { "name": "expression_args", "symbols": ["expression_arg", "__"], "postprocess": as_array(0) },
        { "name": "expression_args", "symbols": ["expression_arg", "__", "expression_args"], "postprocess": merge(0, 2) },
        { "name": "expression_arg", "symbols": ["any_type"], "postprocess": function (d) { return d[0]; } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("lparan") ? { type: "lparan" } : lparan), "__", "function_args", "__", (uqlLexer.has("rparan") ? { type: "rparan" } : rparan)], "postprocess": function (d) { return ({ type: "value_array", value: d[2] }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("plus") ? { type: "plus" } : plus)], "postprocess": function (d) { return ({ type: "operation", value: "+" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("dash") ? { type: "dash" } : dash)], "postprocess": function (d) { return ({ type: "operation", value: "-" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("mul") ? { type: "mul" } : mul)], "postprocess": function (d) { return ({ type: "operation", value: "*" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("divide") ? { type: "divide" } : divide)], "postprocess": function (d) { return ({ type: "operation", value: "/" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("mod") ? { type: "mod" } : mod)], "postprocess": function (d) { return ({ type: "operation", value: "%" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("gt") ? { type: "gt" } : gt), (uqlLexer.has("assignment") ? { type: "assignment" } : assignment)], "postprocess": function (d) { return ({ type: "operation", value: ">=" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("gt") ? { type: "gt" } : gt)], "postprocess": function (d) { return ({ type: "operation", value: ">" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("lt") ? { type: "lt" } : lt), (uqlLexer.has("assignment") ? { type: "assignment" } : assignment)], "postprocess": function (d) { return ({ type: "operation", value: "<=" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("lt") ? { type: "lt" } : lt)], "postprocess": function (d) { return ({ type: "operation", value: "<" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("eq") ? { type: "eq" } : eq)], "postprocess": function (d) { return ({ type: "operation", value: "==" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("ne") ? { type: "ne" } : ne)], "postprocess": function (d) { return ({ type: "operation", value: "!=" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("assignment") ? { type: "assignment" } : assignment), (uqlLexer.has("tilde") ? { type: "tilde" } : tilde)], "postprocess": function (d) { return ({ type: "operation", value: "=~" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("exclaim") ? { type: "exclaim" } : exclaim), (uqlLexer.has("tilde") ? { type: "tilde" } : tilde)], "postprocess": function (d) { return ({ type: "operation", value: "!~" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "between" }], "postprocess": function (d) { return ({ type: "operation", value: "between" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "inside" }], "postprocess": function (d) { return ({ type: "operation", value: "inside" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "outside" }], "postprocess": function (d) { return ({ type: "operation", value: "outside" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "matches" }, "_", { "literal": "regex" }], "postprocess": function (d) { return ({ type: "operation", value: "matches regex" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("exclaim") ? { type: "exclaim" } : exclaim), { "literal": "matches" }, "_", { "literal": "regex" }], "postprocess": function (d) { return ({ type: "operation", value: "!matches regex" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "not" }, "_", { "literal": "matches" }, "_", { "literal": "regex" }], "postprocess": function (d) { return ({ type: "operation", value: "!matches regex" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "in" }], "postprocess": function (d) { return ({ type: "operation", value: "in" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("exclaim") ? { type: "exclaim" } : exclaim), { "literal": "in" }], "postprocess": function (d) { return ({ type: "operation", value: "!in" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "not" }, "_", { "literal": "in" }], "postprocess": function (d) { return ({ type: "operation", value: "!in" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "in" }, (uqlLexer.has("tilde") ? { type: "tilde" } : tilde)], "postprocess": function (d) { return ({ type: "operation", value: "in~" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("exclaim") ? { type: "exclaim" } : exclaim), { "literal": "in" }, (uqlLexer.has("tilde") ? { type: "tilde" } : tilde)], "postprocess": function (d) { return ({ type: "operation", value: "!in~" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "not" }, "_", { "literal": "in" }, (uqlLexer.has("tilde") ? { type: "tilde" } : tilde)], "postprocess": function (d) { return ({ type: "operation", value: "!in~" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "contains" }], "postprocess": function (d) { return ({ type: "operation", value: "contains" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("exclaim") ? { type: "exclaim" } : exclaim), { "literal": "contains" }], "postprocess": function (d) { return ({ type: "operation", value: "!contains" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "not" }, "_", { "literal": "contains" }], "postprocess": function (d) { return ({ type: "operation", value: "!contains" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "contains_cs" }], "postprocess": function (d) { return ({ type: "operation", value: "contains_cs" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("exclaim") ? { type: "exclaim" } : exclaim), { "literal": "contains_cs" }], "postprocess": function (d) { return ({ type: "operation", value: "!contains_cs" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "not" }, "_", { "literal": "contains_cs" }], "postprocess": function (d) { return ({ type: "operation", value: "!contains_cs" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "startswith" }], "postprocess": function (d) { return ({ type: "operation", value: "startswith" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("exclaim") ? { type: "exclaim" } : exclaim), { "literal": "startswith" }], "postprocess": function (d) { return ({ type: "operation", value: "!startswith" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "not" }, "_", { "literal": "startswith" }], "postprocess": function (d) { return ({ type: "operation", value: "!startswith" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "startswith_cs" }], "postprocess": function (d) { return ({ type: "operation", value: "startswith_cs" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("exclaim") ? { type: "exclaim" } : exclaim), { "literal": "startswith_cs" }], "postprocess": function (d) { return ({ type: "operation", value: "!startswith_cs" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "not" }, "_", { "literal": "startswith_cs" }], "postprocess": function (d) { return ({ type: "operation", value: "!startswith_cs" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "endswith" }], "postprocess": function (d) { return ({ type: "operation", value: "endswith" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("exclaim") ? { type: "exclaim" } : exclaim), { "literal": "endswith" }], "postprocess": function (d) { return ({ type: "operation", value: "!endswith" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "not" }, "_", { "literal": "endswith" }], "postprocess": function (d) { return ({ type: "operation", value: "!endswith" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "endswith_cs" }], "postprocess": function (d) { return ({ type: "operation", value: "endswith_cs" }); } },
        { "name": "expression_arg", "symbols": [(uqlLexer.has("exclaim") ? { type: "exclaim" } : exclaim), { "literal": "endswith_cs" }], "postprocess": function (d) { return ({ type: "operation", value: "!endswith_cs" }); } },
        { "name": "expression_arg", "symbols": [{ "literal": "not" }, "_", { "literal": "endswith_cs" }], "postprocess": function (d) { return ({ type: "operation", value: "!endswith_cs" }); } },
        { "name": "expression_arg", "symbols": ["function"], "postprocess": function (d) { return ({ type: "function", value: d[0] }); } },
        { "name": "function$ebnf$1", "symbols": [] },
        { "name": "function$ebnf$1", "symbols": ["function$ebnf$1", "function_args"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "function", "symbols": ["function_name", { "literal": "(" }, "__", "function$ebnf$1", { "literal": ")" }], "postprocess": function (d) { return ({ type: "function", operator: d[0], args: d[3][0] || [] }); } },
        { "name": "conditional_function_name", "symbols": [{ "literal": "countif" }], "postprocess": as_string },
        { "name": "conditional_function_name", "symbols": [{ "literal": "sumif" }], "postprocess": as_string },
        { "name": "conditional_function_name", "symbols": [{ "literal": "minif" }], "postprocess": as_string },
        { "name": "conditional_function_name", "symbols": [{ "literal": "maxif" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "add_datetime" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "array_from_entries" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "array_to_map" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "atob" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "bag_pack" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "btoa" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "ceil" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "cos" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "count" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "dcount" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "diff" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "distinct" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "div" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "extract" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "first" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "floor" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "format_datetime" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "kv" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "last" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "latest" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "log" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "log10" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "log2" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "max" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "mean" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "min" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "mul" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "pack" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "parse_url" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "parse_urlquery" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "percentage" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "pow" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "random" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "replace_string" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "reverse" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "round" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "sign" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "sin" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "split" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "startofday" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "startofhour" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "startofminute" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "startofmonth" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "startofweek" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "startofyear" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "strcat" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "strlen" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "substring" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "sum" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "tan" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "tobool" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "todatetime" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "todouble" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "tofloat" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "toint" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "tolong" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "tolower" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "tonumber" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "tostring" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "tounixtime" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "toupper" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "trim_end" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "trim_start" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "trim" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "unixtime_microseconds_todatetime" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "unixtime_milliseconds_todatetime" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "unixtime_nanoseconds_todatetime" }], "postprocess": as_string },
        { "name": "function_name", "symbols": [{ "literal": "unixtime_seconds_todatetime" }], "postprocess": as_string },
        { "name": "function_args", "symbols": ["function_arg", "__"], "postprocess": as_array(0) },
        { "name": "function_args", "symbols": ["function_arg", "__", { "literal": "," }, "__", "function_args"], "postprocess": merge(0, 4) },
        { "name": "function_arg", "symbols": ["any_type"], "postprocess": pick(0) },
        { "name": "function_arg", "symbols": [(uqlLexer.has("identifier") ? { type: "identifier" } : identifier)], "postprocess": function (d) { return { type: "identifier", value: d[0].value }; } },
        { "name": "command_orderby", "symbols": [{ "literal": "order" }, "_", { "literal": "by" }, "_", "orderby_args"], "postprocess": pick(4) },
        { "name": "orderby_args", "symbols": ["orderby_arg", "__"], "postprocess": as_array(0) },
        { "name": "orderby_args", "symbols": ["orderby_arg", "__", { "literal": "," }, "__", "orderby_args"], "postprocess": merge(0, 4) },
        { "name": "orderby_arg", "symbols": ["str", "__", { "literal": "asc" }], "postprocess": function (d) { return ({ field: d[0], direction: "asc" }); } },
        { "name": "orderby_arg", "symbols": ["str", "__", { "literal": "desc" }], "postprocess": function (d) { return ({ field: d[0], direction: "desc" }); } },
        { "name": "command_extend", "symbols": [{ "literal": "extend" }, "_", "function_assignments"], "postprocess": function (d) { return d[2]; } },
        { "name": "command_project", "symbols": [{ "literal": "project" }, "_", "function_assignments"], "postprocess": function (d) { return d[2]; } },
        { "name": "command_project_reorder", "symbols": [{ "literal": "project" }, (uqlLexer.has("dash") ? { type: "dash" } : dash), { "literal": "reorder" }, "_", "function_assignments"], "postprocess": function (d) { return d[4]; } },
        { "name": "command_project_away", "symbols": [{ "literal": "project" }, (uqlLexer.has("dash") ? { type: "dash" } : dash), { "literal": "away" }, "_", "ref_types"], "postprocess": function (d) { return d[4]; } },
        { "name": "command_scope", "symbols": [{ "literal": "scope" }, "_", "ref_type"], "postprocess": function (d) { return d[2]; } },
        { "name": "command_where", "symbols": [{ "literal": "where" }, "_", "expression_args"], "postprocess": function (d) { return d[2]; } },
        { "name": "command_distinct$ebnf$1", "symbols": [] },
        { "name": "command_distinct$ebnf$1", "symbols": ["command_distinct$ebnf$1", "ref_type"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "command_distinct", "symbols": [{ "literal": "distinct" }, "__", "command_distinct$ebnf$1"], "postprocess": function (d) { return d[2] ? d[2][0] : undefined; } },
        { "name": "command_mv_expand", "symbols": [{ "literal": "mv" }, (uqlLexer.has("dash") ? { type: "dash" } : dash), { "literal": "expand" }, "_", "ref_type"], "postprocess": function (d) { return d[4]; } },
        { "name": "command_mv_expand$ebnf$1", "symbols": [] },
        { "name": "command_mv_expand$ebnf$1", "symbols": ["command_mv_expand$ebnf$1", "str"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "command_mv_expand$ebnf$2", "symbols": [] },
        { "name": "command_mv_expand$ebnf$2", "symbols": ["command_mv_expand$ebnf$2", { "literal": "=" }], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "command_mv_expand", "symbols": [{ "literal": "mv" }, (uqlLexer.has("dash") ? { type: "dash" } : dash), { "literal": "expand" }, "_", "command_mv_expand$ebnf$1", "command_mv_expand$ebnf$2", "ref_type"], "postprocess": function (d) { return (__assign({ alias: d[4][0] }, d[6])); } },
        { "name": "command_parse_json$ebnf$1", "symbols": [] },
        { "name": "command_parse_json$ebnf$1", "symbols": ["command_parse_json$ebnf$1", "parse_args"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "command_parse_json", "symbols": [{ "literal": "parse" }, (uqlLexer.has("dash") ? { type: "dash" } : dash), { "literal": "json" }, "__", "command_parse_json$ebnf$1"], "postprocess": function (d) { return d[4]; } },
        { "name": "command_parse_csv$ebnf$1", "symbols": [] },
        { "name": "command_parse_csv$ebnf$1", "symbols": ["command_parse_csv$ebnf$1", "parse_args"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "command_parse_csv", "symbols": [{ "literal": "parse" }, (uqlLexer.has("dash") ? { type: "dash" } : dash), { "literal": "csv" }, "__", "command_parse_csv$ebnf$1"], "postprocess": function (d) { return d[4]; } },
        { "name": "command_parse_xml$ebnf$1", "symbols": [] },
        { "name": "command_parse_xml$ebnf$1", "symbols": ["command_parse_xml$ebnf$1", "parse_args"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "command_parse_xml", "symbols": [{ "literal": "parse" }, (uqlLexer.has("dash") ? { type: "dash" } : dash), { "literal": "xml" }, "__", "command_parse_xml$ebnf$1"], "postprocess": function (d) { return d[4]; } },
        { "name": "command_parse_yaml$ebnf$1", "symbols": [] },
        { "name": "command_parse_yaml$ebnf$1", "symbols": ["command_parse_yaml$ebnf$1", "parse_args"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "command_parse_yaml", "symbols": [{ "literal": "parse" }, (uqlLexer.has("dash") ? { type: "dash" } : dash), { "literal": "yaml" }, "__", "command_parse_yaml$ebnf$1"], "postprocess": function (d) { return d[4]; } },
        { "name": "parse_args", "symbols": ["parse_arg"], "postprocess": as_array(0) },
        { "name": "parse_args", "symbols": ["parse_arg", "__", "parse_args"], "postprocess": merge(0, 2) },
        { "name": "parse_arg", "symbols": [(uqlLexer.has("dash") ? { type: "dash" } : dash), (uqlLexer.has("dash") ? { type: "dash" } : dash), (uqlLexer.has("identifier") ? { type: "identifier" } : identifier), "__", "str"], "postprocess": function (d) { return ({ identifier: d[2].value, value: d[4] }); } },
        { "name": "parse_arg", "symbols": [(uqlLexer.has("dash") ? { type: "dash" } : dash), (uqlLexer.has("dash") ? { type: "dash" } : dash), (uqlLexer.has("identifier") ? { type: "identifier" } : identifier), "__", "str_type"], "postprocess": function (d) { return ({ identifier: d[2].value, value: d[4].value }); } },
        { "name": "parse_arg", "symbols": [(uqlLexer.has("dash") ? { type: "dash" } : dash), (uqlLexer.has("dash") ? { type: "dash" } : dash), (uqlLexer.has("identifier") ? { type: "identifier" } : identifier), "__", (uqlLexer.has("identifier") ? { type: "identifier" } : identifier)], "postprocess": function (d) { return ({ identifier: d[2].value, value: d[4].value }); } },
        { "name": "command_pivot$ebnf$1", "symbols": [] },
        { "name": "command_pivot$ebnf$1", "symbols": ["command_pivot$ebnf$1", { "literal": "," }], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "command_pivot$ebnf$2", "symbols": [] },
        { "name": "command_pivot$ebnf$2", "symbols": ["command_pivot$ebnf$2", "ref_types"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "command_pivot", "symbols": [{ "literal": "pivot" }, "__", "summarize_assignment", "__", "command_pivot$ebnf$1", "__", "command_pivot$ebnf$2"], "postprocess": function (d) { return ({ metric: d[2], fields: d[6] !== undefined && d[6].length > 0 ? d[6][0] : [] }); } },
        { "name": "command_summarize", "symbols": ["summarize_item"], "postprocess": pick(0) },
        { "name": "command_summarize$ebnf$1", "symbols": [] },
        { "name": "command_summarize$ebnf$1", "symbols": ["command_summarize$ebnf$1", "summarize_args"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "command_summarize", "symbols": ["summarize_item", "_", { "literal": "by" }, "_", "command_summarize$ebnf$1"], "postprocess": function (d) { return (__assign(__assign({}, d[0]), { by: d[4][0] })); } },
        { "name": "summarize_item", "symbols": [{ "literal": "summarize" }, "_", "summarize_assignments"], "postprocess": function (d) { return ({ metrics: d[2], by: [] }); } },
        { "name": "summarize_assignments", "symbols": ["summarize_assignment"], "postprocess": function (d) { return [d[0]]; } },
        { "name": "summarize_assignments", "symbols": ["summarize_assignment", "__", { "literal": "," }, "__", "summarize_assignments"], "postprocess": merge(0, 4) },
        { "name": "summarize_assignment$ebnf$1", "symbols": [] },
        { "name": "summarize_assignment$ebnf$1", "symbols": ["summarize_assignment$ebnf$1", "str"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "summarize_assignment$ebnf$2", "symbols": [] },
        { "name": "summarize_assignment$ebnf$2", "symbols": ["summarize_assignment$ebnf$2", { "literal": "=" }], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "summarize_assignment", "symbols": ["summarize_assignment$ebnf$1", "summarize_assignment$ebnf$2", "summarize_function"], "postprocess": function (d) {
                return d[2].condition ?
                    { operator: d[2].operator, alias: d[0][0], args: d[2].args, ref: d[2].ref, condition: d[2].condition } :
                    { operator: d[2].operator, alias: d[0][0], args: d[2].args };
            } },
        { "name": "summarize_function$ebnf$1", "symbols": [] },
        { "name": "summarize_function$ebnf$1", "symbols": ["summarize_function$ebnf$1", "summarize_args"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "summarize_function", "symbols": ["function_name", { "literal": "(" }, "summarize_function$ebnf$1", { "literal": ")" }], "postprocess": function (d) { return ({ operator: d[0], args: d[2][0] || [] }); } },
        { "name": "summarize_function", "symbols": ["conditional_function_name", { "literal": "(" }, "ref_type", "__", { "literal": "," }, "__", "expression_args", "__", { "literal": ")" }], "postprocess": function (d) { return ({ operator: d[0], ref: d[2], condition: d[6] }); } },
        { "name": "summarize_args", "symbols": ["summarize_arg", "__"], "postprocess": as_array(0) },
        { "name": "summarize_args", "symbols": ["summarize_arg", "__", { "literal": "," }, "__", "summarize_args"], "postprocess": merge(0, 4) },
        { "name": "summarize_arg", "symbols": ["ref_type"], "postprocess": pick(0) },
        { "name": "command_range", "symbols": ["range_item"], "postprocess": pick(0) },
        { "name": "command_range", "symbols": ["range_item", "_", { "literal": "step" }, "_", "number"], "postprocess": function (d) { return (__assign(__assign({}, d[0]), { step: d[4] })); } },
        { "name": "command_range", "symbols": ["range_item", "_", { "literal": "step" }, "_", "str"], "postprocess": function (d) { return (__assign(__assign({}, d[0]), { step: d[4] })); } },
        { "name": "range_item", "symbols": [{ "literal": "range" }, "_", { "literal": "from" }, "_", "number", "_", { "literal": "to" }, "_", "number"], "postprocess": function (d) { return ({ start: d[4], end: d[8], step: 1 }); } },
        { "name": "range_item", "symbols": [{ "literal": "range" }, "_", { "literal": "from" }, "_", "str", "_", { "literal": "to" }, "_", "str"], "postprocess": function (d) { return ({ start: d[4], end: d[8], step: "" }); } },
        { "name": "str_type", "symbols": [(uqlLexer.has("str") ? { type: "str" } : str), { "literal": "(" }, "str", { "literal": ")" }], "postprocess": function (d) { return ({ type: "string", value: d[2] }); } },
        { "name": "str_type", "symbols": [(uqlLexer.has("sq_string") ? { type: "sq_string" } : sq_string)], "postprocess": function (d) { return ({ type: "string", value: d[0].value }); } },
        { "name": "ref_type", "symbols": ["str"], "postprocess": function (d) { return ({ type: "ref", value: d[0] }); } },
        { "name": "ref_type", "symbols": [{ "literal": "[" }, "str", { "literal": "]" }], "postprocess": function (d) { return ({ type: "ref", value: d[1] }); } },
        { "name": "ref_type", "symbols": [{ "literal": "[" }, (uqlLexer.has("sq_string") ? { type: "sq_string" } : sq_string), { "literal": "]" }], "postprocess": function (d) { return ({ type: "ref", value: d[1] }); } },
        { "name": "num_type", "symbols": ["number"], "postprocess": function (d) { return ({ type: "number", value: d[0] }); } },
        { "name": "ref_types", "symbols": ["ref_type"], "postprocess": as_array(0) },
        { "name": "ref_types", "symbols": ["ref_type", "__", { "literal": "," }, "__", "ref_types"], "postprocess": merge(0, 4) },
        { "name": "any_type", "symbols": ["num_type"], "postprocess": pick(0) },
        { "name": "any_type", "symbols": ["str_type"], "postprocess": pick(0) },
        { "name": "any_type", "symbols": ["ref_type"], "postprocess": pick(0) },
        { "name": "line_comment", "symbols": [(uqlLexer.has("comment") ? { type: "comment" } : comment)], "postprocess": function (d) { var _a; return ({ type: "comment", value: ((_a = d[0]) === null || _a === void 0 ? void 0 : _a.value) || '' }); } },
        { "name": "str", "symbols": [(uqlLexer.has("string") ? { type: "string" } : string)], "postprocess": as_string },
        { "name": "number", "symbols": [(uqlLexer.has("number") ? { type: "number" } : number)], "postprocess": as_number },
        { "name": "nlo$ebnf$1", "symbols": [] },
        { "name": "nlo$ebnf$1", "symbols": ["nlo$ebnf$1", (uqlLexer.has("nl") ? { type: "nl" } : nl)], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "nlo", "symbols": ["nlo$ebnf$1"], "postprocess": dispose },
        { "name": "pipeo$ebnf$1", "symbols": [] },
        { "name": "pipeo$ebnf$1", "symbols": ["pipeo$ebnf$1", (uqlLexer.has("pipe") ? { type: "pipe" } : pipe)], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "pipeo", "symbols": ["pipeo$ebnf$1"], "postprocess": dispose },
        { "name": "__$ebnf$1", "symbols": [] },
        { "name": "__$ebnf$1", "symbols": ["__$ebnf$1", (uqlLexer.has("ws") ? { type: "ws" } : ws)], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "__", "symbols": ["__$ebnf$1"], "postprocess": dispose },
        { "name": "_$ebnf$1", "symbols": [(uqlLexer.has("ws") ? { type: "ws" } : ws)] },
        { "name": "_$ebnf$1", "symbols": ["_$ebnf$1", (uqlLexer.has("ws") ? { type: "ws" } : ws)], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": dispose }
    ],
    ParserStart: "input",
};
exports.default = grammar;
